/*
Copyright (c) 2014, American Institutes for Research. All rights reserved.
GENERATED: 7/25/2014 2:03:39 PM
MACHINE: DC1KHANMOLT
*/

// FILE: content_manager.js (503b601f) 5/2/2014 12:55:57 PM

var ContentManager = {
_pages: new Util.Structs.Map(),
_currentPage: null,
_contextHandlerMap: {},
_events: new Util.EventManager(ContentManager),
_contentEvents: new Util.EventManager(ContentManager),
accessibilityEnabled: false,
enableKeyEvents: true,
enableMouseEvents: true,
enableARIA: false,
_readOnly: false,
_debug: true
};
ContentManager.Modules = {};
ContentManager.setReadOnly = function(value) {
this._readOnly = value;
};
ContentManager.isReadOnly = function() {
return this._readOnly;
};
ContentManager._baseUrl = '';
ContentManager.getBaseUrl = function () {
return this._baseUrl;
};
ContentManager.setBaseUrl = function (baseUrl) {
this._baseUrl = baseUrl;
};
ContentManager.resolveBaseUrl = function(url) {
if (Util.String.isHttpProtocol(url)) {
return url;
}
return this._baseUrl + url;
};
ContentManager.enableAccessibility = function() {
this.accessibilityEnabled = true;
this.enableKeyEvents = false;
this.enableMouseEvents = false;
this.enableARIA = true;
};
ContentManager.isAccessibilityEnabled = function() {
return this.accessibilityEnabled;
};
ContentManager.init = function (baseUrl) {
if (YAHOO.lang.isString(baseUrl)) {
ContentManager.setBaseUrl(baseUrl);
}
ContentManager.addKeyEvents(document);
if (window != parent) {
try {
ContentManager.addKeyEvents(parent.document);
ContentManager.Menu.applyDocFix(parent);
} catch (ex) {
}
}
if (this.enableKeyEvents || this.enableMouseEvents) {
ContentManager.Menu.init();
}
if (Util.Browser.isTouchDevice()) {
ContentManager.listenForFocus(document);
}
ContentManager.fireEvent('init');
};
ContentManager.getAccommodations = function() {
return Accommodations.Manager.getDefault();
};
ContentManager.getAccs = ContentManager.getAccommodations;
ContentManager.getAccommodationProperties = function() {
var accommodations = this.getAccommodations();
return new Accommodations.Properties(accommodations);
};
ContentManager.getAccProps = ContentManager.getAccommodationProperties;
ContentManager.getLanguage = function() {
var accProps = this.getAccommodationProperties();
var language = accProps.getSelectedCode('Language');
return (language) ? language : 'ENU';
};
ContentManager.getPages = function() {
return this._pages.getValues();
};
ContentManager.getPage = function(id) {
return this._pages.get(id);
};
ContentManager.setCurrentPage = function(page) {
this._currentPage = page;
};
ContentManager.getCurrentPage = function() {
return this._currentPage;
};
ContentManager.createPage = function (content) {
if (!YAHOO.lang.isObject(content) || !YAHOO.lang.isString(content.id)) {
return null;
}
var existingPage = ContentManager.getPage(content.id);
if (existingPage) {
return existingPage;
}
var page = new ContentPage(content);
ContentManager._pages.set(content.id, page);
ContentManager.firePageEvent('init', page, [content], false);
if (content.passage) {
var passage = ContentManager._createPassage(page, content.passage);
ContentManager.fireEntityEvent('init', passage, [content.passage]);
}
Util.Array.each(content.items, function(itsItem) {
var item = ContentManager._createItem(page, itsItem);
ContentManager.fireEntityEvent('init', item, [itsItem]);
});
return page;
};
ContentManager._createPassage = function (page, itsPassage) {
var passage = new ContentPassage(page, itsPassage.bankKey, itsPassage.itemKey, itsPassage.filePath);
page.setPassage(passage);
passage.stemTTS = itsPassage.stemTTS;
passage.printed = itsPassage.printed;
passage.resources = itsPassage.resources;
passage.attachments = itsPassage.attachments;
passage.specs = itsPassage.specs;
return passage;
};
ContentManager._createItem = function (page, itsItem) {
var item = new ContentItem(page, itsItem.bankKey, itsItem.itemKey, itsItem.filePath,
itsItem.format, itsItem.responseType, itsItem.grade, itsItem.subject, itsItem.position);
page.addItem(item);
item.stemTTS = itsItem.stemTTS;
item.illustrationTTS = itsItem.illustrationTTS;
item.rendererSpec = itsItem.rendererSpec || null;
item.gridAnswerSpace = itsItem.gridAnswerSpace;
item.tutorial = itsItem.tutorial;
item.resources = itsItem.resources;
item.attachments = itsItem.attachments;
if (itsItem.resources) {
item.gtr = itsItem.resources['guideToRevision'];
item.coverPage = itsItem.resources['coverPage'];
}
item.value = itsItem.value;
item.printed = itsItem.printed;
item.rubric = itsItem.rubric;
if (itsItem.qti) {
item.qti = itsItem.qti;
}
item.specs = itsItem.specs;
return item;
};
ContentManager._processPage = function (page) {
var pageDoc = page.getDoc(),
pageWin = page.getWin();
if (pageWin.__tds_processed) {
return;
}
ContentManager.Menu.applyDocFix(pageDoc);
ContentManager.addKeyEvents(pageDoc);
Util.Dom.stopDragEvents(pageDoc);
Util.Dom.stopAllEvents(pageDoc, 'contextmenu');
YUE.on(pageDoc, 'mousedown', function (ev) {
if (ev.button == 1) {
YUE.stopEvent(ev);
}
});
pageWin.__tds_processed = true;
};
ContentManager.getItem = function (position) {
var pages = this.getPages();
for (var i = 0; i < pages.length; i++) {
var page = pages[i];
var item = page.getItem(position);
if (item) {
return item;
}
}
return null;
};
ContentManager.setItemCompleted = function(item) {
if (item == null) {
return;
}
ContentManager.fireEntityEvent('completed', item);
var page = item.getPage();
var items = page.getItems();
if (items.length == 1) {
ContentManager.firePageEvent('completed', page);
}
};
ContentManager.removePage = function (page) {
if (page.isShowing()) {
page.hide();
}
ContentManager.Renderer.removePage(page);
this._pages.remove(page.id);
page.dispose();
};
ContentManager.onEvent = function(name, callback, cancellable) {
this._events.subscribe(name, callback, null, cancellable);
};
ContentManager.onPageEvent = function(name, callback, cancellable) {
this._contentEvents.subscribe('page' + name, callback, null, cancellable);
};
ContentManager.onEntityEvent = function(name, callback) {
this._contentEvents.subscribe('entity' + name, callback);
};
ContentManager.onItemEvent = function(name, callback) {
this._contentEvents.subscribe('item' + name, callback);
};
ContentManager.onPassageEvent = function(name, callback) {
this._contentEvents.subscribe('passage' + name, callback);
};
ContentManager.onComponentEvent = function(name, callback) {
this._contentEvents.subscribe('component' + name, callback);
};
ContentManager.fireEvent = function(name, args) {
var ret = this._events.notify(name, args);
return ret;
};
ContentManager.firePageEvent = function (name, page, args, fireEntityEvents) {
if (YLang.isString(page)) {
page = ContentManager.getPage(page);
}
if (!(page instanceof ContentPage)) {
return null;
}
var pageArgs = [page].concat(args || []);
var ret = this._contentEvents.notify('page' + name, pageArgs);
if (fireEntityEvents === true && ret !== false) {
var passage = page.getPassage();
if (passage) {
this.fireEntityEvent(name, passage, args);
}
var items = page.getItems();
for (var i = 0; i < items.length; i++) {
this.fireEntityEvent(name, items[i], args);
}
}
return ret;
};
ContentManager.fireEntityEvent = function (name, entity, args) {
var unsupported = (entity instanceof ContentItem && entity.isSupported() === false);
if (unsupported && name != 'unsupported') {
return;
}
var page = entity.getPage();
var entityArgs = [page, entity].concat(args || []);
this._contentEvents.notify('entity' + name, entityArgs);
if (entity instanceof ContentItem) {
this._contentEvents.notify('item' + name, entityArgs);
} else if (entity instanceof ContentPassage) {
this._contentEvents.notify('passage' + name, entityArgs);
}
};
ContentManager.fireComponentEvent = function(name, entity, component, args) {
var page = entity.getPage();
var componentArgs = [page, entity, component].concat(args || []);
this._contentEvents.notify('component' + name, componentArgs);
};
(function(CM) {
var lookup = {};
CM.registerResponseHandler = function(responseType, callbackGet, callbackSet) {
lookup[responseType.toLowerCase()] = {
getter: callbackGet,
setter: callbackSet
};
};
CM.getResponseHandler = function(responseType) {
return lookup[responseType.toLowerCase()];
};
CM.getResponseHandlers = function() {
return Util.Object.getValues(lookup);
};
CM.removeResponseHandler = function(responseType) {
return Util.Object.remove(lookup, responseType);
};
CM.removeResponseHandlers = function() {
var responseTypes = Util.Object.keys(lookup);
for (var i = 0; i < responseTypes.length; i++) {
CM.removeResponseHandler(responseTypes[i]);
}
};
})(ContentManager);
(function(CM) {
var lookup = {};
CM.registerSupportHandler = function(responseType, check) {
lookup[responseType.toLowerCase()] = check;
};
CM.getSupportHandler = function(responseType) {
return lookup[responseType.toLowerCase()];
};
CM.getSupportHandlers = function() {
return Util.Object.getValues(lookup);
};
CM.removeSupportHandler = function(responseType) {
return Util.Object.remove(lookup, responseType);
};
CM.removeSupportHandlers = function() {
var responseTypes = Util.Object.keys(lookup);
for (var i = 0; i < responseTypes.length; i++) {
CM.removeSupportHandler(responseTypes[i]);
}
};
})(ContentManager);
ContentManager.addMouseEvents = function (entity, element) {
if (!this.enableMouseEvents) {
return false;
}
if (element == null) {
return false;
}
if (element.__tds_mouseEventsEnabled === true) {
return false;
}
var page = entity.getPage();
var activeElementEvent = Util.Browser.isIOS() ? 'touchstart' : 'mousedown';
YUE.on(element, activeElementEvent, function (evt) {
entity.setActive(evt);
var target = YUE.getTarget(evt);
var clickedComponent = entity.findComponent(target);
if (clickedComponent) {
entity.setActiveComponent(clickedComponent);
}
else if (entity.getActiveComponent() == null) {
entity.resetComponent();
}
}, this, true);
var fireMouseEvent = function (evt) {
this.firePageEvent('mouseevent', page, [evt], false);
this.fireEntityEvent('mouseevent', entity, [evt]);
if (Util.Browser.isSecure() && Util.Browser.isMac()) {
if (evt.type == 'mousedown' && evt.button == 2) {
setTimeout(function() {
ContentManager.Menu.show(evt);
}, 0);
}
} else if (evt.type == 'contextmenu') {
ContentManager.Menu.show(evt);
}
};
YUE.on(element, 'mousedown', fireMouseEvent, this, true);
YUE.on(element, 'mouseup', fireMouseEvent, this, true);
YUE.on(element, 'contextmenu', fireMouseEvent, this, true);
element.__tds_mouseEventsEnabled = true;
return true;
};
ContentManager.getEventXY = function(domEvent, clickXY) {
var element = YUE.getTarget(domEvent);
if (!clickXY) {
clickXY = YUE.getXY(domEvent);
}
while (Util.Dom.getWindow(element.ownerDocument).frameElement &&
!Util.Dom.getWindow(element.ownerDocument).its) {
element = Util.Dom.getWindow(element.ownerDocument).frameElement;
var elementXY = YUD.getXY(element);
clickXY[0] = clickXY[0] + elementXY[0];
clickXY[1] = clickXY[1] + elementXY[1];
}
return clickXY;
};
ContentManager.getJavaString = function(value) {
if (value != null && typeof (value) == 'object') {
value = new String(value).toString();
}
return value;
};
ContentManager.resetActiveComponent = function() {
var page = ContentManager.getCurrentPage();
if (page) {
var entity = page.getActiveEntity();
if (entity instanceof ContentItem) {
entity.resetComponent();
}
}
};
ContentManager.enableCaretMode = function(enable) {
var enabled = Mozilla.enableCaretMode(enable);
if (enabled) {
var entity = ContentManager.getCurrentPage().getActiveEntity();
entity.resetCaretPosition();
}
};
ContentManager.focus = function(obj) {
if (ContentManager.enableARIA) {
return false;
}
return Util.Dom.focus(obj);
};
ContentManager.blur = function(obj) {
if (ContentManager.enableARIA) {
return false;
}
return Util.Dom.blur(obj);
};
ContentManager.preventFocus = function(el) {
YUE.onFocus(el, function() {
ContentManager.blur(el);
});
};
ContentManager.isLinkClickable = function(link) {
var mediaType = link.getAttribute('type');
if (mediaType == null) {
return false;
}
var supportedMediaTypes = ['application/rtf', 'application/pdf'];
return (supportedMediaTypes.indexOf(mediaType) != -1);
};
ContentManager.getAncestor = Util.Dom.getAncestor;
ContentManager.isElement = Util.Dom.isElement;
ContentManager.isVisible = Util.Dom.isVisible;
ContentManager.CSS = {
CONTEXT_AREA: 'contextArea',
CONTEXT_AREA_ALT: 'contextArea-hasalt',
CONTEXT_AREA_FOCUS: 'contextArea-focused',
CONTEXT_BODY_FOCUS: 'contextBody-focused',
CONTEXT_AREA_SELECT: 'contextArea-selected',
CONTEXT_BODY_SELECT: 'contextBody-selected',
MARK_REVIEW_OFF: 'markReview',
MARK_REVIEW_ON: 'markReviewMarked',
HIGHLIGHT: 'highlight'
};
ContentManager._labels = {};
ContentManager._labels['TTS_SPEAKTEXT'] = { classname: 'speaktext', text: 'TDSContentJS.Label.SpeakSelected' };
ContentManager._labels['TTS_SPEAKSECTION'] = { classname: 'speaksection', text: 'Speak {title}' };
ContentManager._labels['TTS_SPEAKSECTION_ALT'] = { classname: 'speaksection', text: 'Speak {title}' };
ContentManager._labels['TTS_STOP'] = { classname: 'speakstop', text: 'TDSContentJS.Label.StopSpeaking' };
ContentManager._labels['HIGHLIGHT_TEXT'] = { classname: 'highlighttext', text: 'TDSContentJS.Label.Highlight' };
ContentManager._labels['HIGHLIGHT_CLEAR'] = { classname: 'highlightclear', text: 'TDSContentJS.Label.ResetHighlight' };
ContentManager.getLabel = function(id) {
var label = ContentManager._labels[id.toUpperCase()];
if (label) {
return { classname: label.classname, text: Messages.get(label.text) };
}
return null;
};
ContentManager.getCommentCode = function() {
var accProps = Accommodations.Manager.getCurrentProperties();
return accProps.getStudentComments();
};
ContentManager.getCommentLabel = function() {
var commentCode = ContentManager.getCommentCode();
var label = 'Comments';
if (commentCode == 'TDS_SCDropDown') {
label = Messages.getAlt('TestShell.Comments.DropDown', 'Comments');
} else if (commentCode == 'TDS_SCNotepad') {
label = Messages.getAlt('TestShell.Comments.Notepad', 'Notepad');
} else if (commentCode == 'TDS_SCTextArea') {
label = Messages.getAlt('TestShell.Comments.TextArea', 'Comments');
}
return label;
};
ContentManager.isDialogShowing = function() {
return YUD.hasClass(document.body, 'showingLoading') ||
YUD.hasClass(document.body, 'showingDialog');
};
ContentManager.log = function(message) {
if (typeof Util == 'object') {
Util.log(message);
}
else if (typeof console == 'object') {
console.log(message);
}
};
ContentManager.requiresSelectionFix = function() {
return (Util.Browser.isMac() &&
Util.Browser.getSecureVersion() > 0 &&
Util.Browser.getSecureVersion() < 4.0);
};
ContentManager.fixItemFrame = function (item, win, doc) {
ContentManager.Menu.applyDocFix(win);
ContentManager.addMouseEvents(item, doc);
ContentManager.addKeyEvents(doc);
Util.Dom.stopAllEvents(doc, 'contextmenu');
if (ContentManager.requiresSelectionFix()) {
YUE.addListener(doc, 'mousedown', function(e) {
ContentManager.focus(top);
});
YUE.addListener(doc, 'mouseup', function(e) {
ContentManager.focus(win);
});
}
var page = item.getPage();
var pageAccommodations = page.getAccommodations();
pageAccommodations.applyCSS(doc.body);
var zoom = page.getZoom();
zoom.addDocument(doc);
zoom.refresh();
};
ContentManager.setReadOnlyKeyEvent = function(item, input) {
var readOnlyFunc = function(evt) {
if (item.isReadOnly()) {
YUE.stopEvent(evt);
}
};
YUE.on(input, 'keypress', readOnlyFunc);
YUE.on(input, 'mousedown', readOnlyFunc);
};
ContentManager.createRange = function(doc) {
if (typeof window.rangy == 'object') {
try {
return window.rangy.createRange(doc);
} catch (ex) {
}
}
return null;
};
ContentManager.getSelection = function(doc) {
if (typeof window.rangy == 'object') {
try {
return window.rangy.getSelection(doc);
} catch (ex) {
}
}
return null;
};
ContentManager.applyRedrawFix = function() {
setTimeout(function() {
YUD.addClass(document.body, 'forceRedraw');
setTimeout(function() {
YUD.removeClass(document.body, 'forceRedraw');
}, 0);
}, 0);
};
ContentManager.listenForFocus = function(doc) {
var focused = false;
var setFocused = function() {
YUD.addClass(document.body, 'inputFocus');
focused = true;
};
var setBlurred = function() {
YUD.removeClass(document.body, 'inputFocus');
focused = false;
};
YUE.onFocus(doc, function(ev) {
if (Util.Event.inTextInput(ev)) {
var targetEl = YUE.getTarget(ev);
if (YUD.getAttribute(targetEl, 'autocorrect') != 'off') {
YUD.setAttribute(targetEl, 'autocorrect', 'off');
YUD.setAttribute(targetEl, 'autocapitalize', 'off');
YUD.setAttribute(targetEl, 'autocomplete', 'off');
}
ContentManager.applyRedrawFix();
setFocused();
}
});
YUE.onBlur(doc, function(ev) {
setBlurred();
});
var win = Util.Dom.getWindow(doc);
YUE.on(win, 'scroll', function(ev) {
if (focused && !Util.Dom.isTextInput(document.activeElement)) {
setBlurred();
}
});
};
YUD.toggleClass = function(node, className, force) {
var add = (force !== undefined) ? force : !(YUD.hasClass(node, className));
if (add) {
YUD.addClass(node, className);
} else {
YUD.removeClass(node, className);
}
};

// FILE: content_page.js (69743fd9) 3/7/2014 11:24:06 AM

var ContentPage = function(content) {
this.id = content.id;
this.segmentID = content.segmentID;
this.layout = content.layout;
this.soundCue = content.soundCue;
this.autoPlayQueue = TDS.Audio.Player.createQueue();
this._html = content.html;
this._container = null;
this._doc = null;
this._passage = null;
this._items = [];
this._itemHash = {};
this._activeEntity = null;
this._zoom = null;
this._lastEntity = null;
this._imagesLoading = [];
this._imagesLoaded = [];
this._imagesFailed = [];
this._imagesAborted = [];
this._imagesTimer = null;
this._imagesRetry = 0;
this._resourceCollection = new ResourceLoader.Collection();
this._status = ContentPage.State.Init;
this._statusNames = {};
this._statusNames[ContentPage.State.Init] = 'init';
this._statusNames[ContentPage.State.Rendering] = 'rendering';
this._statusNames[ContentPage.State.Rendered] = 'rendered';
this._statusNames[ContentPage.State.Available] = 'available';
this._statusNames[ContentPage.State.Loaded] = 'loaded';
this._enableScroll = true;
};
ContentPage.imageTimeout = 90;
ContentPage.imageMaxRetry = 2;
ContentPage.State = {
Init: 0,
Rendering: 1,
Rendered: 2,
Available: 3,
Loaded: 4
};
ContentPage.prototype.getState = function() {
return this._status;
};
ContentPage.prototype.setState = function(newState) {
if (!YAHOO.lang.isNumber(newState) ||
newState < ContentPage.State.Init ||
newState > ContentPage.State.Loaded) {
throw 'Invalid page state';
}
var currentState = this.getState();
var currentStateName = this._statusNames[currentState];
var newStateName = this._statusNames[newState];
if (newStateName == null) {
throw 'No page state name found';
}
var statusError = 'Invalid page state transition (' + currentStateName + ' --> ' + newStateName + ')';
if (newState == ContentPage.State.Init && currentState >= ContentPage.State.Init) {
throw statusError;
} else if (newState == ContentPage.State.Rendering &&
currentState != ContentPage.State.Init) {
throw statusError;
} else if (newState == ContentPage.State.Rendered &&
currentState != ContentPage.State.Rendering) {
throw statusError;
} else if (newState == ContentPage.State.Available &&
currentState != ContentPage.State.Rendered) {
throw statusError;
} else if (newState == ContentPage.State.Loaded &&
currentState != ContentPage.State.Available) {
throw statusError;
}
this._status = newState;
this._log(newStateName);
ContentManager.firePageEvent(newStateName, this, null, true);
};
ContentPage.prototype.getHtml = function() { return this._html; };
ContentPage.prototype.setHtml = function(html) {
if (this.getState() <= ContentPage.State.Rendering) {
this._html = html;
return true;
}
return false;
};
ContentPage.prototype.getContainer = function() {
return this._container;
};
ContentPage.prototype.getDoc = function() {
return this._doc;
};
ContentPage.prototype.getActiveDoc = function() {
var activeEntity = this.getActiveEntity();
if (activeEntity != null) {
var activeComponent = activeEntity.getActiveComponent();
if (activeComponent != null && YAHOO.lang.isFunction(activeComponent.getDoc)) {
return activeComponent.getDoc();
}
}
return this.getDoc();
};
ContentPage.prototype.getBody = function() {
var doc = this.getDoc();
return doc ? doc.body : null;
};
ContentPage.prototype.getForm = function() {
var doc = this.getDoc();
return doc ? doc.forms['contentForm'] : null;
};
ContentPage.prototype.getWin = function() {
var doc = this.getDoc();
return doc ? (doc.parentWindow || doc.defaultView) : null;
};
ContentPage.prototype.getActiveWin = function() {
var activeEntity = this.getActiveEntity();
if (activeEntity != null) {
var activeComponent = activeEntity.getActiveComponent();
if (activeComponent != null && YAHOO.lang.isFunction(activeComponent.getWin)) {
return activeComponent.getWin();
}
}
return this.getWin();
};
ContentPage.prototype.getFrameElement = function() {
var win = this.getWin();
return win ? win.frameElement : null;
};
ContentPage.prototype.getElement = function() {
var doc = this.getDoc();
return doc ? doc.getElementById('Page_' + this.id) : null;
};
ContentPage.prototype.getCompoundElement = function() {
var pageDoc = this.getDoc();
var items = this.getItems();
if (pageDoc && items.length > 0) {
var firstItem = items[0];
return pageDoc.getElementById('compound_' + firstItem.position);
}
return null;
};
ContentPage.prototype.getHeader = function() {
var pageElement = this.getElement();
var headers = pageElement.getElementsByTagName('h3');
if (headers.length > 0) {
return headers[0];
}
return null;
};
ContentPage.prototype.getAccommodations = function() {
return Accommodations.Manager.get(this.segmentID);
};
ContentPage.prototype.getAccs = ContentPage.prototype.getAccommodations;
ContentPage.prototype.getAccommodationProperties = function() {
return Accommodations.Manager.getProperties(this.segmentID);
};
ContentPage.prototype.getAccProps = ContentPage.prototype.getAccommodationProperties;
ContentPage.prototype.zoomIn = function() {
return this._zoom.zoomIn();
};
ContentPage.prototype.zoomOut = function() {
return this._zoom.zoomOut();
};
ContentPage.prototype.getZoom = function() {
return this._zoom;
};
ContentPage.prototype.getZoomFactor = function() {
var zoomInfo = this.getZoom();
return (zoomInfo == null) ? 1 : zoomInfo.levels[zoomInfo.currentLevel].factor;
};
ContentPage.prototype.setPassage = function(passage) {
this._passage = passage;
};
ContentPage.prototype.getPassage = function(visible) {
if (visible && this._passage && !this._passage.isVisible()) {
return null;
}
return this._passage;
};
ContentPage.prototype.addItem = function(item) {
this._items.push(item);
this._itemHash[item.position] = item;
};
ContentPage.prototype.getItems = function(visible) {
var items = this._items.slice(0);
if (visible) {
items = Util.Array.filter(items, function(item) {
return item.isVisible();
});
}
return items;
};
ContentPage.prototype.getItem = function(position) {
return this._itemHash[position];
};
ContentPage.prototype.getEntities = function(visible) {
var entities = this.getItems(visible);
var passage = this.getPassage(visible);
if (passage) {
entities.push(passage);
}
return entities;
};
ContentPage.prototype.getEntitiesIterator = function(visible) {
var entities = this.getEntities(visible);
var iter = Util.Iterator(entities);
iter.jumpTo(this.getActiveEntity());
return iter;
};
ContentPage.prototype.getActiveEntity = function() {
return this._activeEntity;
};
ContentPage.prototype.clearEntity = function() {
var activeEntity = this.getActiveEntity();
if (activeEntity == null) {
return false;
}
activeEntity.clearActive();
return true;
};
ContentPage.prototype.prevEntity = function() {
var items = this.getItems(true);
var currentEntity = this.getActiveEntity();
if (currentEntity == null || currentEntity instanceof ContentPassage) {
currentEntity = items[items.length - 1];
} else {
for (var i = 0; i < items.length; i++) {
var item = items[i];
if (currentEntity == item) {
currentEntity = items[i - 1] || this.getPassage(true) || items[items.length - 1];
break;
}
}
}
if (currentEntity) {
currentEntity.setActive();
return currentEntity;
} else {
return null;
}
};
ContentPage.prototype.nextEntity = function() {
var items = this.getItems(true);
var currentEntity = this.getActiveEntity();
if (currentEntity == null || currentEntity instanceof ContentPassage) {
currentEntity = items[0];
} else {
for (var i = 0; i < items.length; i++) {
var item = items[i];
if (currentEntity == item) {
currentEntity = items[i + 1] || this.getPassage(true) || items[0];
break;
}
}
}
if (currentEntity) {
currentEntity.setActive();
return currentEntity;
} else {
return null;
}
};
ContentPage.prototype.isShowing = function() {
return (this == ContentManager.getCurrentPage());
};
ContentPage.prototype.collapseSelection = function() {
var pageDoc = this.getActiveDoc();
var pageSelection = ContentManager.getSelection(pageDoc);
if (pageSelection && pageSelection.rangeCount > 0) {
pageSelection.collapseToStart();
}
};
ContentPage.prototype.getImages = function() {
var frameDoc = this.getDoc();
var images = [];
for (var i = 0; i < frameDoc.images.length; i++) {
var image = frameDoc.images[i];
if (image.className == 'Image') {
images.push(image);
}
}
return images;
};
ContentPage.prototype.getScrollableElement = function() {
var pageElement = this.getElement();
if (pageElement != null) {
var entity = this.getActiveEntity();
if (this.writing) {
return Util.Dom.getElementByClassName('writeWrap', 'div', pageElement);
}
else if (entity instanceof ContentPassage) {
return entity.getElement();
}
else if (entity instanceof ContentItem) {
return Util.Dom.getElementByClassName('theQuestions', 'div', pageElement);
}
}
return null;
};
ContentPage.prototype.enableScroll = function(){
this._enableScroll = true;
};
ContentPage.prototype.disableScroll = function(){
this._enableScroll = false;
};
ContentPage.prototype.scroll = function(direction) {
var el = this.getScrollableElement();
if (el == null || !this._enableScroll) {
return;
}
switch (direction) {
case 'Up':
el.scrollTop -= 50;
break;
case 'Down':
el.scrollTop += 50;
break;
case 'Left':
el.scrollLeft -= 100;
break;
case 'Right':
el.scrollLeft += 100;
break;
}
};
ContentPage.prototype._log = function(message) {
if (!ContentManager._debug) {
return;
}
ContentManager.log('PAGE ' + this.id + ': ' + message);
};
ContentPage.prototype.toString = function() { return 'Page ' + this.id; };
ContentPage.prototype.render = function() {
if (this.getState() > ContentPage.State.Init) {
return false;
}
YAHOO.lang.later(1, this, function() {
this.setState(ContentPage.State.Rendering);
ContentManager.Renderer.writePage(this);
});
return true;
};
ContentPage.prototype.onRendered = function(pageDoc, pageContainer) {
YUD.addClass(pageDoc.body, 'yui-skin-sam');
YUD.addClass(pageDoc.body, Util.Browser.isTouchDevice() ? 'touch' : 'no-touch');
this._doc = pageDoc;
this._container = pageContainer;
var pageElement = this.getElement();
if (pageElement == null) {
throw new Error('The page element could not be found.');
}
var pageForm = this.getForm();
if (pageForm != null) {
YUE.on(pageForm, 'submit', function(ev) {
YUE.stopEvent(ev);
return false;
});
}
YUD.batch(pageElement.getElementsByTagName('img'), this.addImage, this, true);
this.setState(ContentPage.State.Rendered);
YAHOO.lang.later(1, this, this.onAvailable);
var items = this.getItems();
for (var i = 0; i < items.length; i++) {
var item = items[i];
if (!item.isSupported()) {
ContentManager.fireEntityEvent('unsupported', item);
}
}
};
ContentPage.prototype.onAvailable = function() {
ContentManager._processPage(this);
this._zoom = new ContentZoom(this.getDoc(), null, this);
var pageElement = this.getElement();
this.setState(ContentPage.State.Available);
YUD.batch(pageElement.getElementsByTagName('a'), function(link) {
if (ContentManager.enableARIA === false) {
link.setAttribute('tabindex', '-1');
YUE.on(link, 'mousedown', function(ev) { YUE.stopEvent(ev); });
YUE.on(link, 'mouseup', function(ev) { YUE.stopEvent(ev); });
}
if (!ContentManager.isLinkClickable(link)) {
YUE.on(link, 'click', function(ev) { YUE.stopEvent(ev); });
}
});
if (this._resourceCollection.hasLoaders()) {
this._resourceCollection.subscribe(ResourceLoader.Status.COMPLETE, this.checkLoaded, this);
this._resourceCollection.subscribe(ResourceLoader.Status.ERROR, this.checkLoaded, this);
this._resourceCollection.subscribe(ResourceLoader.Status.ABORT, this.checkLoaded, this);
this._resourceCollection.load();
}
YAHOO.lang.later(1, this, this.checkLoaded);
};
ContentPage.prototype.hide = function() {
if (!this.isShowing()) {
return false;
}
this._log('hide');
this.clearEntity();
var currentPage = ContentManager.getCurrentPage();
if (currentPage == this) {
ContentManager.setCurrentPage(null);
}
var pageContainer = this.getContainer();
if (pageContainer) {
ContentManager.firePageEvent('beforeHide', this, null, true);
ContentManager.Renderer.hide(pageContainer);
} else {
return false;
}
ContentManager.firePageEvent('hide', this, null, true);
return true;
};
ContentPage.prototype.show = function() {
if (this.isShowing()) {
return false;
}
this._log('show');
var currentPage = ContentManager.getCurrentPage();
if (currentPage && currentPage != this) {
currentPage.hide();
}
var pageContainer = this.getContainer();
if (pageContainer == null) {
return false;
}
var cancelShow = ContentManager.firePageEvent('beforeShow', this, null, true);
if (cancelShow === false) {
return false;
}
ContentManager.Renderer.show(pageContainer);
ContentManager.setCurrentPage(this);
var activeEntity = null;
if (this._lastEntity != null) {
activeEntity = this._lastEntity;
} else {
var items = this.getItems(true);
var passage = this.getPassage(true);
if (items.length > 0) {
activeEntity = items[0];
}
else if (passage) {
activeEntity = passage;
}
}
if (activeEntity) {
activeEntity.setActive(null, true);
}
YAHOO.lang.later(1, this, function() {
ContentManager.firePageEvent('show', this, null, true);
});
return true;
};
ContentPage.prototype.checkLoaded = function() {
if (this._imagesLoading.length > 0) {
return;
}
if (this._imagesTimer != null) {
this._imagesTimer.cancel();
this._imagesTimer = null;
}
if (this._resourceCollection.hasLoaders() &&
this._resourceCollection.getStatus() == ResourceLoader.Status.LOADING) {
return;
}
if (this.getState() == ContentPage.State.Available) {
this.setState(ContentPage.State.Loaded);
}
};
ContentPage.prototype.getResourceLoaders = function() { return this._resourceCollection; };
ContentPage.prototype.addResourceLoader = function(resource) {
this._resourceCollection.add(resource);
};
ContentPage.prototype.getImagesLoading = function() { return this._imagesLoading; };
ContentPage.prototype.getImagesLoaded = function() { return this._imagesLoaded; };
ContentPage.prototype.getImagesFailed = function() { return this._imagesFailed; };
ContentPage.prototype.getImagesAborted = function() { return this._imagesAborted; };
ContentPage.prototype.addImage = function(image) {
if (image.id == '') {
image.id = YUD.generateId();
}
this._imagesLoading.push(image);
var loadEvent = YAHOO.env.ua.ie ? 'readystatechange' : 'load';
YUE.addListener(image, loadEvent, this._onImageEvent, image, this);
YUE.addListener(image, 'abort', this._onImageEvent, image, this);
YUE.addListener(image, 'error', this._onImageEvent, image, this);
image.dateRequested = Util.Date.now();
this._startImageTimer();
};
ContentPage.prototype._startImageTimer = function() {
if (this._imagesTimer != null) {
this._imagesTimer.cancel();
}
this._imagesTimer = YAHOO.lang.later((ContentPage.imageTimeout * 1000), this, this._onImagesTimeout);
};
ContentPage.prototype._onImagesTimeout = function() {
Util.log('image timeout');
if (this._imagesRetry < ContentPage.imageMaxRetry) {
this._imagesRetry++;
Util.Array.each(this._imagesLoading, function(image) {
image.src = image.src;
image.dateRequested = Util.Date.now();
});
this._startImageTimer();
} else {
Util.Array.each(this._imagesLoading, function(image) {
var evt = { type: 'abort' };
this._onImageEvent(evt, image);
}, this);
}
};
ContentPage.prototype._onImageEvent = function(evt, image) {
if (!Util.Array.contains(this._imagesLoading, image)) {
return;
}
if (evt.type == 'readystatechange') {
if (image.readyState == 'complete') {
evt = { type: 'load' };
} else {
return;
}
}
if (typeof image.naturalWidth == 'undefined') {
if (evt.type == 'load') {
image.naturalWidth = image.width;
image.naturalHeight = image.height;
} else {
image.naturalWidth = 0;
image.naturalHeight = 0;
}
}
var loadEvent = YAHOO.env.ua.ie ? 'readystatechange' : 'load';
YUE.removeListener(image, loadEvent, this._onImageEvent);
YUE.removeListener(image, 'abort', this._onImageEvent);
YUE.removeListener(image, 'error', this._onImageEvent);
Util.Array.remove(this._imagesLoading, image);
if (evt.type == 'load') {
this._imagesLoaded.push(image);
} else if (evt.type == 'abort') {
this._imagesAborted.push(image);
} else {
this._imagesFailed.push(image);
}
image.dateCompleted = Util.Date.now();
this.checkLoaded();
};
ContentPage.prototype.fireEvent = function(name, args, fireEntityEvents) {
this._events.notify(name, args);
if (fireEntityEvents) {
if (page.passage) {
this.fireEntityEvent(name, page.passage, args);
}
var items = page.getItems();
for (var i = 0; i < items.length; i++) {
this.fireEntityEvent(name, items[i], args);
}
}
};
ContentPage.prototype.dispose = function() {
if (this._passage) {
this._passage.dispose();
delete this._passage;
}
if (this._items) {
for (var i = 0; i < this._items.length; i++) {
this._items[i].dispose();
delete this._items[i];
}
}
this._items = null;
this._itemHash = null;
this.id = null;
this.segmentID = null;
this.layout = null;
this.soundCue = null;
this._html = null;
this._container = null;
this._doc = null;
this._activeEntity = null;
this._zoom = null;
this._lastEntity = null;
this._imagesLoading = null;
this._imagesLoaded = null;
this._imagesFailed = null;
this._imagesAborted = null;
this._imagesTimer = null;
this._imagesRetry = null;
};

// FILE: content_entity.js (fb36bcd3) 3/7/2014 11:24:06 AM

var ContentEntity = function(page, bankKey, itemKey, filePath) {
this._page = page;
this.bankKey = bankKey;
this.itemKey = itemKey;
this.filePath = filePath;
this.audioLinks = [];
this.printed = false;
this._components = [];
this._activeComponent = null;
this.init();
};
ContentEntity.prototype.init = function() {};
ContentEntity.prototype.getElement = function() {
return null;
};
ContentEntity.prototype.getText = function() {
var el = this.getElement();
if (el) {
var text = Util.Dom.getTextContent(el);
text = YAHOO.lang.trim(text);
return text;
}
return '';
};
ContentEntity.prototype.isEmpty = function() {
return (this.getText().length == 0);
};
ContentEntity.prototype.getPage = function() {
return this._page;
};
ContentEntity.prototype.getResource = function(type) {
return (this.resources) ? this.resources[type] : null;
};
ContentEntity.prototype.isVisible = function() {
var element = this.getElement();
return Util.Dom.isVisible(element);
};
ContentEntity.prototype.isActive = function() {
return this == this._page._activeEntity;
};
ContentEntity.prototype.clearActive = function() {
var activeEntity = this._page.getActiveEntity();
if (activeEntity && activeEntity == this) {
this._log('blur entity');
var element = activeEntity.getElement();
ContentManager.blur(element);
this._page._activeEntity = null;
ContentManager.fireEntityEvent('blur', this);
return true;
}
return false;
};
ContentEntity.prototype.setActive = function(domEvent, force)
{
var activeEntity = this._page.getActiveEntity() || null;
if (!force && this == activeEntity) {
return false;
}
this._page.clearEntity();
this._log('focus entity');
this._page._activeEntity = this;
this._page._lastEntity = this;
this.focus();
if (typeof(domEvent) == 'undefined') {
this.scrollTo();
}
ContentManager.fireEntityEvent('focus', this              , activeEntity               );
return true;
};
ContentEntity.prototype.focus = function() {
var entityElement = this.getElement();
ContentManager.focus(entityElement);
};
ContentEntity.prototype.scrollTo = function() {
var element = this.getElement();
element.scrollIntoView(false);
};
ContentEntity.prototype.addComponent = function(element) {
if (element == null) {
return false;
}
this._components.push(element);
return true;
};
ContentEntity.prototype.getComponents = function(visible) {
var components = this._components;
if (visible) {
components = Util.Array.filter(components, function(component) {
if (YAHOO.lang.isFunction(component.isVisible)) {
return component.isVisible();
} else if (Util.Dom.isElement(component)) {
return Util.Dom.isVisible(component);
}
return true;
});
}
return components;
};
ContentEntity.prototype.findComponent = function(element) {
return ContentManager.getAncestor(element, this._components);
};
ContentEntity.prototype.getActiveComponent = function() {
return this._activeComponent;
};
ContentEntity.prototype.setActiveComponent = function(component, force) {
if (!force && this._activeComponent == component) {
return;
}
if (this._activeComponent != null) {
this._log('blur component - \'' + this._activeComponent.id + '\'');
ContentManager.blur(this._activeComponent);
ContentManager.fireComponentEvent('blur', this, this._activeComponent);
this._activeComponent = null;
}
if (component == null) {
return;
}
if (!this.isActive()) {
throw new Error('The entity must have focus before setting a component.');
}
var components = this.getComponents();
var componentFound = false;
for (var i = 0; i < components.length; i++) {
if (component == components[i]) {
componentFound = true;
break;
}
}
if (!componentFound) {
throw new Error('Component not found for this item.');
}
this._activeComponent = component;
this._log('focus component - \'' + this._activeComponent.id + '\'');
if (TDS.Audio.Java.isReady()) {
ContentManager.focus(this.getPage().getWin());
}
ContentManager.focus(this._activeComponent);
ContentManager.fireComponentEvent('focus', this, this._activeComponent);
};
ContentEntity.prototype.prevComponent = function() {
var components = this.getComponents(true);
var focusedComponent = this.getActiveComponent();
if (focusedComponent == null) {
focusedComponent = components[components.length - 1];
} else {
for (var i = 0; i < components.length; i++) {
var component = components[i];
if (component == focusedComponent) {
focusedComponent = components[i - 1] || components[components.length - 1];
break;
}
}
}
this.setActiveComponent(focusedComponent);
return focusedComponent;
};
ContentEntity.prototype.nextComponent = function() {
var components = this.getComponents(true);
var focusedComponent = this.getActiveComponent();
if (focusedComponent == null) {
focusedComponent = components[0];
} else {
for (var i = 0; i < components.length; i++) {
var component = components[i];
if (component == focusedComponent) {
focusedComponent = components[i + 1] || components[0];
break;
}
}
}
this.setActiveComponent(focusedComponent);
return focusedComponent;
};
ContentEntity.prototype.clearComponent = function() {
this.setActiveComponent(null);
};
ContentEntity.prototype.resetComponent = function() {
this.setActiveComponent(this._components[0]);
};
ContentEntity.prototype.resetCaretPosition = function() {
var page = this.getPage();
var pageWin = page.getWin();
var pageDoc = page.getDoc();
var element = this.getActiveComponent();
if (!ContentManager.isElement(element)) {
return false;
}
if (!YUD.inDocument(element, pageDoc)) {
return false;
}
ContentManager.focus(pageWin);
var xPathResult = pageDoc.evaluate(".//text()", element, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
var textNode = null;
for (var i = 0, l = xPathResult.snapshotLength; i < l; i++) {
var node = xPathResult.snapshotItem(i);
var text = node.textContent;
text = text.replace(/\s+/g, ' ');
text = text.replace(/^\s+|\s+$/g, '');
textNode = node;
if (text.length > 0) {
break;
}
}
if (!textNode) {
return false;
}
var selection = pageWin.getSelection();
selection.removeAllRanges();
var range = pageDoc.createRange();
range.setStart(textNode, 0);
range.setEnd(textNode, 0);
selection.addRange(range);
selection.collapseToStart();
return true;
};
ContentEntity.prototype.dispose = function() {
this._activeComponent = null;
if (this._components) {
for (var i = 0; i < this._components.length; i++) {
if (this._components[i].dispose) {
this._components[i].dispose();
}
delete this._components[i];
}
}
this._components = null;
this._page = null;
this.bankKey = null;
this.itemKey = null;
this.audioLinks = null;
};

// FILE: content_passage.js (8e7462cf) 3/7/2014 11:24:06 AM

var ContentPassage = function(page, bankKey, itemKey, filePath) {
ContentPassage.superclass.constructor.call(this, page, bankKey, itemKey, filePath);
};
YAHOO.lang.extend(ContentPassage, ContentEntity);
ContentPassage.prototype.getID = function() {
return 'G-' + this.bankKey + '-' + this.itemKey;
};
ContentPassage.prototype.getElement = function() {
var pageElement = this.getPage().getElement();
return Util.Dom.getElementByClassName('thePassage', 'div', pageElement);
};
ContentPassage.prototype.clearActive = function() {
var itemElement = this.getElement();
YUD.removeClass(itemElement, 'activePassage');
ContentPassage.superclass.clearActive.call(this);
};
ContentPassage.prototype.setActive = function(domEvent, force)
{
var activated = ContentPassage.superclass.setActive.call(this, domEvent, force);
if (activated) {
var element = this.getElement();
YUD.addClass(element, 'activePassage');
}
};
ContentPassage.prototype._log = function(message) {
if (ContentManager._debug) {
ContentManager.log('PASSAGE G-' + this.bankKey + '-' + this.itemKey + ': ' + message);
}
};
ContentPassage.prototype.toString = function() {
return 'Passage G-' + this.bankKey + '-' + this.itemKey;
};

// FILE: content_item.js (5f2665f5) 5/2/2014 12:55:57 PM

var ContentItem = function(page, bankKey, itemKey, filePath, format, responseType, grade, subject, position) {
this.format = format;
this.responseType = responseType;
this.grade = grade;
this.subject = subject;
this.position = position;
this.isDirty = false;
this.value = null;
this.stemTTS = null;
this.illustrationTTS = null;
this.gridAnswerSpace = null;
this.tutorial = null;
this.gtr = null;
this.saveOptions =
{
auto: false,
explicit: false,
implicit: false
};
ContentItem.superclass.constructor.call(this, page, bankKey, itemKey, filePath);
};
YAHOO.lang.extend(ContentItem, ContentEntity);
ContentItem.prototype.getParentPage = function() { return this._page; };
ContentItem.prototype.getID = function() {
return 'I-' + this.bankKey + '-' + this.itemKey;
};
ContentItem.prototype.init = function() {
var format = this.format.toLowerCase();
var type = this.responseType.toLowerCase();
if (type == 'grid' || type == 'simulator' || type == 'scratchpad') {
this.saveOptions.auto = false;
this.saveOptions.implicit = true;
this.saveOptions.explicit = true;
} else if (type == 'microphone') {
this.saveOptions.auto = false;
this.saveOptions.implicit = true;
this.saveOptions.explicit = true;
} else if (format == 'mc' || format == 'si'                    ) {
this.saveOptions.auto = false;
this.saveOptions.implicit = false;
this.saveOptions.explicit = false;
} else if (format == 'eq'                      ) {
this.saveOptions.auto = false;
this.saveOptions.implicit = true;
this.saveOptions.explicit = true;
} else if (format == 'asi'                  ) {
this.saveOptions.auto = false;
this.saveOptions.implicit = true;
this.saveOptions.explicit = false;
} else if (type == 'na') {
this.saveOptions.auto = false;
this.saveOptions.implicit = false;
this.saveOptions.explicit = false;
} else {
this.saveOptions.auto = true;
this.saveOptions.implicit = true;
this.saveOptions.explicit = true;
}
};
ContentItem.prototype.isReadOnly = function() {
return ContentManager.isReadOnly();
};
ContentItem.prototype.isResponseType = function(type) {
return type.toLowerCase() == this.responseType.toLowerCase();
};
ContentItem.prototype.getElement = function() {
var compoundEl = this._page.getCompoundElement();
if (compoundEl) {
return compoundEl;
} else {
var doc = this._page.getDoc();
if (doc) {
return doc.getElementById('Item_' + this.position);
}
}
return null;
};
ContentItem.prototype.getIllustrationElement = function() {
var doc = this._page.getDoc();
return doc ? doc.getElementById('Illustration_' + this.position) : null;
};
ContentItem.prototype.getStemElement = function() {
var doc = this._page.getDoc();
return doc ? doc.getElementById('Stem_' + this.position) : null;
};
ContentItem.prototype.getResponseArea = function() {
var doc = this._page.getDoc();
if (!doc) return null;
var pageEl = this._page.getElement();
if (this.MC) {
var options = this.MC.getOptions();
var optionElements = [];
if (options && options.length > 0) {
for (var i = 0; i < options.length; i++) {
var optionEl = options[i].getElement();
if (optionEl) {
optionElements.push(optionEl);
}
}
}
return optionElements;
}
return null;
};
ContentItem.prototype.getResponse = function() {
var responseHandler = ContentManager.getResponseHandler(this.responseType);
if (responseHandler == null || responseHandler.getter == null) {
return null;
}
var response =
{
value: null,
isSelected: false,
isValid: false,
isAvailable: false
};
responseHandler.getter(this, response);
return response;
};
ContentItem.prototype.setResponse = function(value) {
var responseHandler = ContentManager.getResponseHandler(this.responseType);
if (responseHandler == null || responseHandler.setter == null) {
return false;
}
return responseHandler.setter(this, value);
};
ContentItem.prototype.isSupported = function() {
var supportedHandler = ContentManager.getSupportHandler(this.responseType);
if (typeof supportedHandler == 'function') {
return supportedHandler(this);
}
return true;
};
ContentItem.prototype.clearActive = function() {
var itemElement = this.getElement();
YUD.removeClass(itemElement, 'activeItem');
ContentItem.superclass.clearActive.call(this);
};
ContentItem.prototype.setActive = function(domEvent, force) {
var activated = ContentItem.superclass.setActive.call(this, domEvent, force);
if (activated) {
var element = this.getElement();
YUD.addClass(element, 'activeItem');
}
};
ContentItem.prototype.showFeedback = function() {
var itemEl = this.getElement();
if (itemEl) {
YUD.addClass(itemEl, 'showFeedback');
}
};
ContentItem.prototype.hideFeedback = function() {
var itemEl = this.getElement();
if (itemEl) {
YUD.removeClass(itemEl, 'showFeedback');
}
};
ContentItem.prototype._log = function(message) {
if (ContentManager._debug) {
ContentManager.log('ITEM I-' + this.bankKey + '-' + this.itemKey + ' (' + this.position + '): ' + message);
}
};
ContentItem.prototype.toString = function() {
return 'Item I-' + this.bankKey + '-' + this.itemKey;
};

// FILE: content_item_tools.js (f6be5853) 3/7/2014 11:24:06 AM

ContentItem.prototype.getToolsContainer = function()
{
var itemEl = this.getElement();
return Util.Dom.getElementByClassName('markComment', 'span', itemEl);
};
ContentItem.prototype.hasCommentLink = function()
{
var doc = this._page.getDoc();
var commentLink = doc.getElementById('Item_CommentLink_' + this.position);
return ContentManager.isVisible(commentLink);
};
ContentItem.prototype.toggleComment = function()
{
ContentManager.fireEntityEvent('comment', this);
};
ContentItem.prototype.getMarkLink = function()
{
var doc = this._page.getDoc();
return doc.getElementById('Item_MarkLink_' + this.position);
};
ContentItem.prototype.getMarkCheckBox = function()
{
var doc = this._page.getDoc();
return doc.getElementById('Item_Mark_' + this.position);
};
ContentItem.prototype.hasMarkLink = function()
{
var markLink = this.getMarkLink();
return ContentManager.isVisible(markLink);
};
ContentItem.prototype.isMarked = function()
{
var checkMark = this.getMarkCheckBox();
return (checkMark && checkMark.checked);
};
ContentItem.prototype.toggleMark = function()
{
var markCheck = this.getMarkCheckBox();
if (markCheck == null) return;
if (this.isMarked())
{
markCheck.checked = false;
}
else
{
markCheck.checked = true;
}
this.updateMarkLink();
if (typeof (window.tdsUpdateItemMark) == 'function')
{
window.tdsUpdateItemMark(this.position, markCheck.checked);
}
};
ContentItem.prototype.updateMarkLink = function()
{
var markLink = this.getMarkLink();
if (markLink == null) return;
if (this.isMarked())
{
YUD.removeClass(markLink, 'markReview');
YUD.addClass(markLink, 'markReviewMarked');
markLink.setAttribute('aria-checked', 'true');
}
else
{
YUD.removeClass(markLink, 'markReviewMarked');
YUD.addClass(markLink, 'markReview');
markLink.setAttribute('aria-checked', 'false');
}
};
ContentItem.prototype.getPrintLink = function()
{
var doc = this._page.getDoc();
return doc.getElementById('Item_PrintLink_' + this.position);
};
ContentItem.prototype.hasPrintLink = function()
{
var printLink = this.getPrintLink();
return ContentManager.isVisible(printLink);
};
ContentItem.prototype.print = function()
{
if (typeof (window.tdsItemPrint) == 'function')
{
window.tdsItemPrint(this.position);
}
};
ContentItem.prototype.getHelpLink = function()
{
var doc = this._page.getDoc();
return doc.getElementById('Item_HelpLink_' + this.position);
};
ContentItem.prototype.hasHelpLink = function()
{
var helpLink = this.getHelpLink();
return ContentManager.isVisible(helpLink);
};
ContentItem.prototype.openHelp = function()
{
if (typeof (window.tdsItemResource) == 'function')
{
window.tdsItemResource('help', this.tutorial.bankKey, this.tutorial.itemKey);
}
};
ContentItem.prototype.getGTRLink = function()
{
var doc = this._page.getDoc();
return doc.getElementById('Item_GTRLink_' + this.position);
};
ContentItem.prototype.hasGTRLink = function()
{
var gtrLink = this.getGTRLink();
return ContentManager.isVisible(gtrLink);
};
ContentItem.prototype.openGTR = function()
{
if (typeof (window.tdsItemResource) == 'function')
{
window.tdsItemResource('gtr_' + this.position, this.gtr.bankKey, this.gtr.itemKey);
}
};
ContentItem.prototype.getRemoveResponseLink = function()
{
var itemDoc = this.getParentPage().getDoc();
return itemDoc.getElementById('Item_RemoveResponse_' + this.position);
};
ContentItem.prototype.hasRemoveResponseLink = function()
{
var removeResponseLink = this.getRemoveResponseLink();
return ContentManager.isVisible(removeResponseLink);
};
ContentItem.prototype.addRemoveResponseLink = function()
{
var removeResponseLink = this.getRemoveResponseLink();
if (removeResponseLink != null) return;
var itemDoc = this.getParentPage().getDoc();
removeResponseLink = itemDoc.createElement('a');
removeResponseLink.id = 'Item_RemoveResponse_' + this.position;
YUD.addClass(removeResponseLink, 'removeResponse');
Util.Dom.setTextContent(removeResponseLink, 'Remove Response');
YUD.setStyle(removeResponseLink, 'display', 'block');
YUE.on(removeResponseLink, 'click', function (ev) {
YUE.stopEvent(ev);
});
YUE.on(removeResponseLink, 'click', this.removeResponse, this, true);
var toolsEl = this.getToolsContainer();
if (toolsEl) toolsEl.appendChild(removeResponseLink);
};
ContentItem.prototype.removeResponse = function()
{
if (typeof (window.tdsRemoveResponse) == 'function')
{
window.tdsRemoveResponse(this.position);
}
};
ContentManager.onItemEvent('available', function(page, item)
{
var doc = page.getDoc();
var commentLink = doc.getElementById('Item_CommentLink_' + item.position);
var commentCloseLink = doc.getElementById('Item_CommentCloseLink_' + item.position);
YUE.on(commentLink, 'click', item.toggleComment, item, true);
YUE.on(commentCloseLink, 'click', item.toggleComment, item, true);
var markLink = item.getMarkLink();
YUE.on(markLink, 'click', item.toggleMark, item, true);
item.updateMarkLink();
var printLink = item.getPrintLink();
YUE.on(printLink, 'click', item.print, item, true);
var helpLink = item.getHelpLink();
YUE.on(helpLink, 'click', item.openHelp, item, true);
var gtrLink = item.getGTRLink();
YUE.on(gtrLink, 'click', item.openGTR, item, true);
var accProps = page.getAccommodationProperties();
if (TDS.isProxyLogin && accProps.hasResponseReset())
item.addRemoveResponseLink();
});

// FILE: content_menu.js (cdc08fce) 3/7/2014 11:24:06 AM

ContentManager.Menu =
{
_instance: null
};
ContentManager.Menu.getInstance = function() { return this._instance; };
ContentManager.Menu.init = function()
{
var menuId = "menu_" + Math.random().toString().split('.')[1];
var contextMenu = new YAHOO.widget.ContextMenu(menuId, {
zindex: 1000,
iframe: false,
shadow: false
});
ContentManager.Menu._instance = contextMenu;
contextMenu.showEvent.subscribe(function() {
var body = ContentManager.getCurrentPage().getDoc().body;
YUD.addClass(body, 'contextMenuShowing');
});
contextMenu.beforeHideEvent.subscribe(function() {
if (contextMenu.activeItem &&
contextMenu.activeItem._oAnchor) {
Util.Dom.blur(contextMenu.activeItem._oAnchor);
}
if (document.activeElement &&
YUD.hasClass(document.activeElement, 'yuimenuitemlabel')) {
Util.Dom.blur(document.activeElement);
}
contextMenu.clearActiveItem();
});
contextMenu.hideEvent.subscribe(function() {
var page = ContentManager.getCurrentPage();
if (page == null) return;
var body = page.getDoc().body;
if (body) YUD.removeClass(body, 'contextMenuShowing');
var entity = page.getActiveEntity();
if (entity == null) return;
var pageWin = page.getWin();
ContentManager.focus(pageWin);
try {
ContentManager.fireEntityEvent('menuhide', entity);
}
catch (ex) { }
});
ContentManager.Menu.applyTextSelectionFix(contextMenu);
};
ContentManager.Menu.isShowing = function()
{
return (ContentManager.Menu._instance &&
ContentManager.Menu._instance.cfg.getProperty('visible'));
};
ContentManager.Menu.show = function(evt, menuItems        , menuXY        )
{
if (this._instance == null) return;
if (ContentManager.Menu.hide()) return;
if (menuItems == null && ContentManager.isReadOnly()) return;
var page = ContentManager.getCurrentPage();
if (page == null) return;
var entity = page.getActiveEntity();
if (entity == null) return;
var activeComponent = entity.getActiveComponent();
if (activeComponent == null) return;
if (!menuXY) {
try {
if (YAHOO.lang.isFunction(activeComponent.getXY)) {
menuXY = activeComponent.getXY(evt);
}
else if (evt == null || evt.keyCode) {
menuXY = YUD.getXY(activeComponent);
}
else {
menuXY = ContentManager.getEventXY(evt);
}
}
catch (ex) {
Util.log('showContextMenu: error getting XY - \'' + ex + '\'');
}
}
if (!menuXY) menuXY = [0, 0];
if (menuItems == null)
{
var contentMenu = new ContentMenu();
var pageActiveDoc = page.getActiveDoc();
var pageSelection = ContentManager.getSelection(pageActiveDoc);
ContentManager.fireEntityEvent('menushow', entity, [contentMenu, evt, pageSelection]);
if (contentMenu.cancel) return;
menuItems = contentMenu.getMenuItems();
}
if (menuItems.length == 0) return;
ContentManager.Menu._instance.clearContent();
ContentManager.Menu._instance.contextEventTarget = activeComponent;
var frameXY = [0, 0];
var frameEl = page.getFrameElement();
if (frameEl) frameXY = YUD.getXY(frameEl);
var menuPosition = [menuXY[0] + frameXY[0], menuXY[1] + frameXY[1]];
ContentManager.Menu._instance.cfg.setProperty('xy', menuPosition);
ContentManager.Menu._instance.addItems(menuItems);
Util.Dom.focusWindow();
ContentManager.Menu._instance.render(document.body);
ContentManager.Menu._instance.show();
};
ContentManager.Menu.hide = function()
{
if (ContentManager.Menu._instance && ContentManager.Menu.isShowing())
{
ContentManager.Menu._instance.hide();
return true;
}
return false;
};
ContentManager.Menu.applyDocFix = function(contentDoc)
{
if (document == contentDoc) return;
new YAHOO.widget.Menu('preload');
var docListeners = YAHOO.util.Event.getListeners(document);
if (docListeners == null) return;
var focusBlurAssigned = false;
for (var i = 0; i < docListeners.length; i++)
{
var listener = docListeners[i];
if (listener.obj == YAHOO.widget.MenuManager)
{
YUE.on(contentDoc, listener.type, listener.fn, YAHOO.widget.MenuManager, true);
if (!focusBlurAssigned)
{
YUE.onFocus(contentDoc, listener.fn, YAHOO.widget.MenuManager, true);
YUE.onBlur(contentDoc, listener.fn, YAHOO.widget.MenuManager, true);
focusBlurAssigned = true;
}
}
}
};
ContentManager.Menu.applyTextSelectionFix = function(contextMenu) {
if (YAHOO.env.ua.ie) return;
var makeSelection = function (rangeData) {
var range = document.createRange();
if (range) {
range.setStart(rangeData.anchorNode, rangeData.anchorOffset);
range.setEnd(rangeData.focusNode, rangeData.focusOffset);
var selection = window.getSelection();
if (selection) {
if (selection.removeAllRanges) selection.removeAllRanges();
else if (selection.empty) selection.empty();
selection.addRange(range);
}
}
};
var onFocus = function(type, args, rangeData) {
this.unsubscribe('focus', onFocus);
setTimeout(function() {
try { makeSelection(rangeData); }
catch(ex) {}
}, 0);
};
var onBeforeShow = function() {
if (!ContentManager.Renderer.isDirect()) return;
var selection = window.getSelection(),
rangeData;
if (selection && !selection.isCollapsed) {
rangeData = {
anchorNode: selection.anchorNode,
anchorOffset: selection.anchorOffset,
focusNode: selection.focusNode,
focusOffset: selection.focusOffset
};
this.subscribe('focus', onFocus, rangeData);
}
};
contextMenu.subscribe('beforeShow', onBeforeShow);
};
var ContentMenu = function()
{
this._global = [];
this._entity = [];
this._component = [];
this.cancel = false;
};
ContentMenu.prototype.getMenuItems = function()
{
if (this._component.length > 0) return this._component;
else if (this._entity.length > 0) return this._entity;
else if (this._global.length > 0) return this._global;
return [];
};
ContentMenu.prototype.addMenuItem = function(level, label, fn, disabled, checked, insert)
{
var menuItem;
if (YAHOO.lang.isString(label))
{
menuItem = { text: label };
}
else if (YAHOO.lang.isObject(label))
{
menuItem = label;
}
else return;
if (YAHOO.lang.isFunction(fn))
{
if (YAHOO.env.ua.gecko)
{
var scheduledFunc = function()
{
YAHOO.lang.later(0, this, fn);
};
menuItem.onclick = { fn: scheduledFunc };
}
else
{
menuItem.onclick = { fn: fn };
}
}
if (YAHOO.lang.isBoolean(disabled)) menuItem.disabled = disabled;
if (YAHOO.lang.isBoolean(checked)) menuItem.checked = checked;
var collection = this['_' + level];
if (collection)
{
if (insert) collection.unshift(menuItem);
else collection.push(menuItem);
}
};
ContentMenu.prototype.insertMenuItem = function(level, label, fn, disabled, checked)
{
this.addMenuItem(level, label, fn, disabled, checked, true);
};

// FILE: content_dialog.js (72c599d1) 3/7/2014 11:24:06 AM

(function(CM) {
var currentFrame = null;
var Dialog = {
urlFrame: null,
onBeforeShow: new Util.Event.Custom(),
onShow: new Util.Event.Custom(),
onBeforeHide: new Util.Event.Custom(),
onHide: new Util.Event.Custom(),
onLoad: new Util.Event.Custom()
};
function update() {
if (currentFrame == null ||
currentFrame.loadState != 2) {
return;
}
Util.Dom.copyCSSFrame(currentFrame);
var frameWin = currentFrame.getWindow();
if (frameWin) {
setTimeout(function () { CM.focus(frameWin); }, 0);
}
}
function load(id, bankKey, itemKey) {
var frame = YUD.get(id);
if (frame != null) {
return frame;
}
if (Dialog.urlFrame == null) {
throw new Error('There is no url defined for content dialog frame.');
}
var accProps = Accommodations.Manager.getDefaultProps();
var lang = accProps ? accProps.getLanguage() : 'ENU';
var url = Dialog.urlFrame;
url += '?language=' + lang;
url += '&bankKey=' + bankKey;
url += '&itemKey=' + itemKey;
var dialogsEl = YUD.get('dialogContentFrames');
if (dialogsEl == null) {
dialogsEl = document.createElement('div');
dialogsEl.id = 'dialogContentFrames';
document.body.appendChild(dialogsEl);
}
frame = Util.Frame.create(id, dialogsEl);
frame.load(url);
frame.onLoaded.subscribe(function() {
var frameWin = frame.getWindow();
var frameDoc = frame.getDocument();
if (typeof KeyManager == 'object') {
KeyManager.attachListener(YAHOO.env.ua.gecko ? frameWin : frameDoc);
}
update();
Dialog.onLoad.fire(frame);
});
return frame;
}
Dialog.show = function(id, bankKey, itemKey) {
if (TDS.Audio.isActive()) {
if (window.TestShell) {
TestShell.UI.showWarning(ErrorCodes.get('NavigateAudioPlaying'));
}
return;
}
TTS.getInstance().stop();
CM.Menu.hide();
var frame = load(id, bankKey, itemKey);
Dialog.onBeforeShow.fire(frame);
frame.show();
YUD.addClass('dialogContent', 'enable');
YUE.addListener('dialogContentClose', 'click', Dialog.hide);
currentFrame = frame;
update();
Dialog.onShow.fire(frame);
};
Dialog.hide = function() {
if (currentFrame == null) return;
Dialog.onBeforeHide.fire(currentFrame);
currentFrame.hide();
YUD.removeClass('dialogContent', 'enable');
YUE.purgeElement('dialogContentClose');
Dialog.onHide.fire(currentFrame);
currentFrame = null;
Util.Dom.focusWindow(2);
};
Dialog.isShowing = function() {
return YUD.hasClass('dialogContent', 'enable');
};
Dialog.containsElement = function(el) {
if (!currentFrame || !el || !el.ownerDocument) {
return false;
}
var frameDoc = currentFrame.getDocument();
return (frameDoc == el.ownerDocument);
};
Dialog.onLoad.subscribe(function(frame)
{
var frameWin = frame.getWindow();
var frameDoc = frame.getDocument();
if (frame.id.indexOf('gtr', 0) != -1)
{
var container = frameDoc.getElementById('pageLayout');
YUE.delegate(container, 'click', function(ev, li, container) {
YUD.toggleClass(li, 'checked');
}, 'li');
}
});
CM.Dialog = Dialog;
window.DialogContent = Dialog;
})(ContentManager);
function tdsItemResource(name, bankKey, itemKey)
{
TDS.ToolManager.hideAll();
if (ContentManager.Dialog.isShowing()) {
ContentManager.Dialog.hide();
} else {
var id = name + '_' + bankKey + '_' + itemKey;
ContentManager.Dialog.show(id, bankKey, itemKey);
}
}

// FILE: content_events.js (282f83bf) 3/7/2014 11:24:06 AM

ContentManager.onPageEvent('beforeShow', function(page)
{
var pageAccs = page.getAccommodations();
if (pageAccs != null) {
Accommodations.Manager.updateCSS(page.getBody(), pageAccs.getId());
}
});
ContentManager.onPageEvent('available', function(page)
{
if (page.getPassage() != null) return;
var pageElement = page.getElement();
var passageElement = Util.Dom.getElementByClassName('thePassage', 'div', pageElement);
if (passageElement == null) return;
var firstItem = page.getItems()[0];
var passage = ContentManager._createPassage(page, { bankKey: firstItem.bankKey, itemKey: 0 });
page.setPassage(passage);
});
ContentManager.onPassageEvent('available', function(page, passage)
{
var passageElement = passage.getElement();
if (passageElement != null) passage.addComponent(passageElement);
});
ContentManager.onPassageEvent('available', function(page, passage)
{
var accProps = page.getAccommodationProperties();
if (!accProps || !accProps.showExpandablePassages()) return;
var css_collapsed = 'passage-collapsed';
var css_expanded = 'passage-expanded';
var expandEl = ContentManager.Renderer.isDirect() ?
page.getElement() :
page.getBody();
YUD.addClass(expandEl, css_collapsed);
var expandLink = page.getDoc().createElement('a');
YUD.setAttribute(expandLink, 'href', '#');
YUD.addClass(expandLink, 'expand-collapse-passage');
YUE.on(expandLink, 'click', function(clickEv)
{
YUE.stopEvent(clickEv);
if (YUD.hasClass(expandEl, css_expanded))
{
YUD.removeClass(expandEl, css_expanded);
YUD.addClass(expandEl, css_collapsed);
}
else if (YUD.hasClass(expandEl, css_collapsed))
{
YUD.removeClass(expandEl, css_collapsed);
YUD.addClass(expandEl, css_expanded);
}
});
var passageEl = passage.getElement();
if (passageEl == null) return;
var paddingEl = Util.Dom.getElementByClassName('padding', 'div', passageEl);
if (paddingEl)
{
var paddingChildEl = YUD.getFirstChild(paddingEl);
if (paddingChildEl) YUD.insertBefore(expandLink, paddingChildEl);
else paddingEl.appendChild(expandLink);
}
});
ContentManager.onItemEvent('available', function(page, item)
{
var layoutElements = [];
var stemElement = item.getStemElement();
layoutElements.push(stemElement);
var illustrationElement = item.getIllustrationElement();
if (illustrationElement)
{
YUD.addClass(illustrationElement, 'illustrationContainer');
var illustrationText = Util.Dom.getTextContent(illustrationElement);
illustrationText = YAHOO.lang.trim(illustrationText);
if (illustrationText.length > 0)
{
layoutElements.push(illustrationElement);
}
}
Util.Array.sort(layoutElements, Util.Dom.compareNodeOrder);
Util.Array.each(layoutElements, function(layoutElement)
{
item.addComponent(layoutElement);
});
});
ContentManager.onEntityEvent('focus', function(page, entity)
{
entity.resetComponent();
});
ContentManager.onEntityEvent('blur', function(page, entity)
{
entity.clearComponent();
page.collapseSelection();
});
ContentManager.onComponentEvent('focus', function(page, entity, component)
{
if (ContentManager.isElement(component))
{
YUD.addClass(component, 'contextAreaFocus');
}
});
ContentManager.onComponentEvent('blur', function(page, entity, component)
{
if (ContentManager.isElement(component))
{
YUD.removeClass(component, 'contextAreaFocus');
}
ContentManager.enableCaretMode(false);
});
ContentManager.onPageEvent('show', function(page)
{
var pageContainer = page.getContainer();
if (pageContainer == null || pageContainer.nodeName != 'IFRAME') return;
var pageBody = page.getBody();
if (pageBody == null) return;
YUD.addClass(pageBody, 'forceRedraw');
setTimeout(function()
{
YUD.removeClass(pageBody, 'forceRedraw');
}, 1);
});
ContentManager.onEntityEvent('available', function(page, item)
{
var element = item.getElement();
ContentManager.addMouseEvents(item, element);
});
ContentManager.onItemEvent('unsupported', function(page, item) {
var itemEl = item.getElement();
YUD.addClass(itemEl, 'unsupported');
});
ContentManager.onItemEvent('available', function (page, item) {
var itemEl = item.getElement();
if (itemEl) {
var markCommentEl = Util.Dom.getElementByClassName('markComment', 'span', itemEl);
if (markCommentEl) {
markCommentEl.setAttribute('data-tts-skip', 'true');
}
var posEl = Util.Dom.queryTag('h2', itemEl);
if (posEl && Util.Dom.getTextContent(posEl) == item.position) {
posEl.setAttribute('data-tts-skip', 'true');
}
}
var pageDoc = page.getDoc();
if (pageDoc) {
var commentBoxEl = pageDoc.getElementById('Item_CommentBox_' + item.position);
if (commentBoxEl) {
commentBoxEl.setAttribute('data-tts-skip', 'true');
}
}
});

// FILE: content_keyboard.js (6729b86f) 3/7/2014 11:24:06 AM

ContentManager.addKeyEvents = function(keyEventObj)
{
if (!this.enableKeyEvents) return false;
if (keyEventObj == null) return false;
if (keyEventObj.__tds_keyEventsEnabled === true) return false;
YUE.addListener(keyEventObj, "keydown", this.onKeyEvent, this, true);
YUE.addListener(keyEventObj, "keypress", this.onKeyEvent, this, true);
YUE.addListener(keyEventObj, "keyup", this.onKeyEvent, this, true);
keyEventObj.__tds_keyEventsEnabled = true;
return true;
};
ContentManager.onKeyEvent = function(evt)
{
if (ContentManager.isDialogShowing()) return;
if (evt.ctrlKey && evt.keyCode == 77)
{
YUE.stopEvent(evt);
if (evt.type == 'keydown') {
ContentManager.Menu.show(evt);
}
};
if (ContentManager.Menu.isShowing()) return;
if (ContentManager.isDialogShowing()) return;
if (evt.keyCode == 9) YUE.stopEvent(evt);
var currentPage = ContentManager.getCurrentPage();
if (currentPage == null) return;
var currentEntity = currentPage.getActiveEntity();
if (currentEntity == null) return;
if (!evt.key) {
switch (evt.keyCode) {
case 9:  evt.key = 'Tab'; break;
case 13: evt.key = 'Enter'; break;
case 27: evt.key = 'Esc'; break;
case 32: evt.key = 'Space'; break;
case 37: evt.key = 'Left'; break;
case 38: evt.key = 'Up'; break;
case 39: evt.key = 'Right'; break;
case 40: evt.key = 'Down'; break;
}
}
this.firePageEvent('keyevent', currentPage, [evt], false);
this.fireEntityEvent('keyevent', currentEntity, [evt], false);
};
ContentManager.onPageEvent('keyevent', function(page, evt)
{
if (evt.type != 'keydown') return;
if (evt.key == 'Tab' && !evt.ctrlKey && !evt.altKey)
{
if (evt.shiftKey) page.prevEntity();
else page.nextEntity();
}
});
ContentManager.onEntityEvent('keyevent', function(page, entity, evt)
{
var keyCode = evt.keyCode;
var arrowKeys = (keyCode >= 37 && keyCode <= 40);
if (!arrowKeys) return;
if (Util.Event.hasModifier(evt)) return;
if (Mozilla.inCaretMode()) return;
var target = YAHOO.util.Event.getTarget(evt);
if (Util.Event.inTextInput(evt)) return;
if (Util.Dom.isFormElement(target)) return;
if (target.tagName == 'svg') return;
YUE.stopEvent(evt);
if (evt.type != 'keydown') return;
page.scroll(evt.key);
});
ContentManager.onEntityEvent('keyevent', function(page, entity, evt)
{
if (evt.type != 'keydown') return;
if (Mozilla.inCaretMode())
{
if (evt.key == 'Esc')
{
ContentManager.enableCaretMode(false);
}
return;
}
if (evt.key == 'Tab' && evt.ctrlKey && !evt.altKey)
{
if (evt.shiftKey) entity.prevComponent();
else entity.nextComponent();
YUE.stopEvent(evt);
return;
}
});
(function()
{
var lastRange = null;
ContentManager.onEntityEvent('keyevent', function(page, entity, evt)
{
if (!Mozilla.inCaretMode()) return;
var caretMoveKey = (evt.key == 'Up' || evt.key == 'Down' || evt.key == 'Left' || evt.key == 'Right');
if (!caretMoveKey) return;
var pageWin = entity.getPage().getWin();
var selection = pageWin.getSelection();
var range;
try
{
range = selection.getRangeAt(0);
}
catch (ex) { return; }
if (!range) return;
var activeElement = entity.getActiveComponent();
var startElement = range.startContainer;
var endElement = range.endContainer;
var outOfBounds = (ContentManager.getAncestor(startElement, [activeElement]) == null);
if (!outOfBounds) outOfBounds = (ContentManager.getAncestor(endElement, [activeElement]) == null);
if (outOfBounds)
{
if (!lastRange) return;
try
{
selection.collapseToStart();
selection.removeAllRanges();
selection.addRange(lastRange);
}
catch (ex) { return; }
}
else
{
lastRange = range.cloneRange();
}
});
})();
(function()
{
var needsSelectionFix = (Util.Browser.isMac() && Util.Browser.isSecure() && Util.Browser.getFirefoxVersion() == 2);
if (!needsSelectionFix) return;
var applyfix = function(el)
{
YUD.addClass(el, 'selectionFix');
YUE.on(el, 'focus', function() { top.focus(); });
YUE.on(el, 'mouseover', function() { top.focus(); });
};
ContentManager.onPassageEvent('available', function(page, passage)
{
applyfix(passage.getElement());
});
ContentManager.onItemEvent('available', function(page, item)
{
applyfix(item.getStemElement());
});
})();
ContentManager.onEntityEvent('keyevent', function(page, entity, evt)
{
if (evt.type != 'keyup') return;
if (evt.key == 'Esc')
{
setTimeout(function()
{
var activeComponent = entity.getActiveComponent();
if (activeComponent)
{
entity.setActiveComponent(activeComponent, true);
}
}, 0);
}
});

// FILE: content_xml.js (7c710b4a) 3/7/2014 11:24:06 AM

(function(CM) {
var getNode = Util.Dom.queryTag;
var getNodes = Util.Dom.queryTags;
var batchNodes = Util.Dom.queryTagsBatch;
var getAttribInt = Util.Xml.getAttributeInt;
var getAttribBool = Util.Xml.getAttributeBool;
var getAttrib = Util.Xml.getAttribute;
var getText = Util.Xml.getNodeText;
var getCData = Util.Xml.getCData;
function parse(contentsNode) {
var contents = [];
batchNodes('content', contentsNode, function(contentNode) {
var content = parseContent(contentNode);
contents.push(content);
});
return contents;
};
function parseContent(contentNode) {
var content = {
id: getAttrib(contentNode, 'groupID'),
segmentID: getAttrib(contentNode, 'segmentID'),
layout: getAttrib(contentNode, 'layout'),
language: getAttrib(contentNode, 'language'),
passage: null,
items: []
};
var soundCueNode = getNode('soundCue', contentNode);
if (soundCueNode) {
content.soundCue = {
bankKey: getAttribInt(soundCueNode, 'bankKey'),
itemKey: getAttribInt(soundCueNode, 'itemKey')
};
}
var passageNode = getNode('passage', contentNode);
if (passageNode) {
content.passage = parsePassage(passageNode);
}
var itemsNode = getNode('items', contentNode);
if (itemsNode) {
batchNodes('item', itemsNode, function(itemNode) {
var item = parseItem(itemNode);
content.items.push(item);
});
}
content.html = getCData(contentNode, 'html');
return content;
};
function parseResources(contentNode)
{
var resources = {};
var resourcesNode = getNode('resources',contentNode);
if (resourcesNode) {
batchNodes('resource', resourcesNode, function (resourceNode) {
var resourceType = getAttrib(resourceNode, 'type');
var resource = {
bankKey: getAttribInt(resourceNode, 'bankKey'),
itemKey: getAttribInt(resourceNode, 'itemKey')
};
resources[resourceType] = resource;
});
}
return resources;
};
function parseAttachments(contentNode) {
var attachments = [];
var attachmentsNode = getNode('attachments', contentNode);
if (attachmentsNode) {
batchNodes('attachment', attachmentsNode, function (attachmentNode) {
var attachment = {
id: getAttrib(attachmentNode, 'id'),
type: getAttrib(attachmentNode, 'type'),
subType: getAttrib(attachmentNode, 'subType'),
target: getAttrib(attachmentNode, 'target'),
url: getAttrib(attachmentNode, 'url')
};
attachments.push(attachment);
});
}
return attachments;
};
function parseMedia(contentNode) {
var mediaResources = [];
var mediaNode = getNode('media', contentNode);
if (mediaNode) {
batchNodes('resource', mediaNode, function (resourceNode) {
var mediaResource = {
file: getAttrib(resourceNode, 'file'),
type: getAttrib(resourceNode, 'type'),
data: getText(resourceNode)
};
mediaResources.push(mediaResource);
});
}
return mediaResources;
};
function parseSpecs(node) {
var specs = [];
var constraintsNode = getNode('constraints', node);
if (constraintsNode != null) {
constraintsNode.parentNode.removeChild(constraintsNode);
specs.push(constraintsNode);
}
var searchNode = getNode('search', node);
if (searchNode != null) {
searchNode.parentNode.removeChild(searchNode);
specs.push(searchNode);
}
return specs;
}
function parsePassage(passageNode) {
var passage = {
bankKey: getAttribInt(passageNode, 'bankKey'),
itemKey: getAttribInt(passageNode, 'itemKey'),
printed: getAttribBool(passageNode, 'printed'),
filePath: getCData(passageNode, 'filePath')
};
passage.resources = parseResources(passageNode);
passage.attachments = parseAttachments(passageNode);
passage.media = parseMedia(passageNode);
passage.specs = parseSpecs(passageNode);
return passage;
}
function parseItem(itemNode)
{
var item = {
bankKey: getAttribInt(itemNode, 'bankKey'),
itemKey: getAttribInt(itemNode, 'itemKey'),
subject: getAttrib(itemNode, 'subject'),
grade: getAttrib(itemNode, 'grade'),
format: getAttrib(itemNode, 'format'),
disabled: getAttribBool(itemNode, 'disabled'),
responseType: getAttrib(itemNode, 'responseType'),
position: getAttribInt(itemNode, 'position'),
positionOnPage: getAttribInt(itemNode, 'positionOnPage'),
filePath: getCData(itemNode, 'filePath'),
printed: getAttribBool(itemNode, 'printed')
};
var tutorialNode = getNode('tutorial', itemNode);
if (tutorialNode) {
item.tutorial = {
bankKey: getAttribInt(tutorialNode, 'bankKey'),
itemKey: getAttribInt(tutorialNode, 'itemKey')
};
}
item.resources = parseResources(itemNode);
item.attachments = parseAttachments(itemNode);
item.media = parseMedia(itemNode);
item.rendererSpec = getCData(itemNode, 'rendererSpec');
item.gridAnswerSpace = getCData(itemNode, 'gridAnswerSpace');
var optionsNode = getNode('options', itemNode);
if (optionsNode) {
item.optionsConfig = {
minChoices: getAttribInt(optionsNode, 'minChoices'),
maxChoices: getAttribInt(optionsNode, 'maxChoices')
};
item.options = [];
batchNodes('option', optionsNode, function(optionNode) {
var option = parseOption(optionNode);
item.options.push(option);
});
}
item.value = getCData(itemNode, 'response');
var rubricNode = getNode('rubric', itemNode);
if (rubricNode) {
item.rubric = {
type: getAttrib(rubricNode, 'type'),
data: getText(rubricNode)
};
}
var qtiNode = getNode('qti', itemNode);
if (qtiNode) {
var qtiSpec = getAttrib(qtiNode, 'spec');
var qtiXml = getText(qtiNode);
item.qti = { spec: qtiSpec, xml: qtiXml };
}
item.specs = parseSpecs(itemNode);
return item;
};
function parseOption(optionNode)
{
var option = {
key: getAttrib(optionNode, 'key')
};
option.value = getCData(optionNode, 'value');
option.sound = getCData(optionNode, 'sound');
option.feedback = getCData(optionNode, 'feedback');
return option;
};
function create (root) {
var contentsNode = getNode('contents', root);
var contents = parse(contentsNode);
return contents;
};
CM.Xml = {};
CM.Xml.create = create;
})(ContentManager);

// FILE: content_frame.js (3e001ccb) 3/7/2014 11:24:06 AM

ContentManager.Frame =
{
_container: window.document.body,
_callbacks: new Util.Structs.Map(),
_baseUrl: '',
_overrideFrameUrl: false
};
ContentManager.Frame.setBaseUrl = function(baseUrl, overrideFrameUrl)
{
this._baseUrl = baseUrl || '';
this._overrideFrameUrl = overrideFrameUrl || false;
};
ContentManager.Frame.resolveUrl = function(url)
{
if (Util.String.isHttpProtocol(url)) return url;
if (url.indexOf(this._baseUrl) != -1) return url;
return this._baseUrl + url;
};
ContentManager.Frame.setContainer = function(element) { this._container = element; };
ContentManager.Frame.getDocType = function()
{
if (YAHOO.env.ua.webkit > 0) return Util.Frame.DOCTYPE_HTML5;
if (YAHOO.env.ua.ie >= 9) return Util.Frame.DOCTYPE_HTML5;
return Util.Frame.DOCTYPE_XHTML1_TRANSITIONAL;
};
ContentManager.Frame.getTemplate = function()
{
var html = [];
var docType = ContentManager.Frame.getDocType();
html.push(docType);
html.push('<html xmlns="http://www.w3.org/1999/xhtml">');
html.push('<head>');
html.push('<title>Content</title>');
html.push('<meta http-equiv="X-UA-Compatible" content="IE=IE7,chrome=1" />');
html.push('<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />');
var frameURI;
if (this._overrideFrameUrl && this._baseUrl.length > 0)
{
frameURI = this._baseUrl;
}
else
{
var baseURI = document.baseURI || document.URL;
frameURI = baseURI.replace(/[^/]*$/, '');
}
html.push('<base href="' + frameURI + '" />');
Util.Array.each(ContentManager.Renderer.getScripts(), function(script)
{
html.push('<script type="text/javascript" src="');
html.push(ContentManager.Frame.resolveUrl(script));
html.push('"></script>');
});
html.push('<script type="text/javascript">function createAnArray() { return []; }</script>');
Util.Array.each(ContentManager.Renderer.getStyles(), function(style)
{
html.push('<link type="text/css" rel="stylesheet" href="');
html.push(ContentManager.Frame.resolveUrl(style));
html.push('" />');
});
html.push('</head>');
html.push('<body onload="this.its = true; parent.ContentManager.Frame.onLoad(this);"><div id="main"><form id="contentForm" name="contentForm"></form></div></body>');
html.push('</html>');
return html.join('');
};
ContentManager.Frame.create = function(id, callback)
{
var frame = Util.Frame.createBlank();
frame.id = id;
frame.className = 'contentFrame';
this._container.appendChild(frame);
if (YAHOO.lang.isFunction(callback))
{
this._callbacks.set(id, callback);
}
var htmlTemplate = this.getTemplate();
Util.Frame.writeContent(frame, htmlTemplate);
return frame;
};
ContentManager.Frame.remove = function(id)
{
var frame = document.getElementById(id);
Util.Dom.removeNode(frame);
};
ContentManager.Frame.onLoad = function(frameWin)
{
var frame = frameWin.frameElement;
var callback = this._callbacks.get(frame.id);
if (callback)
{
this._callbacks.remove(frame.id);
callback(frame);
}
};

// FILE: content_qti.js (5944cf80) 3/7/2014 11:24:06 AM

ContentManager.QTI = {};
(function (QTI) {
var validHtmlTags = [
'abbr', 'acronym', 'address', 'blockquote', 'br', 'cite', 'code', 'dfn', 'div', 'em',
'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'kbd', 'p', 'pre', 'q', 'samp', 'span', 'strong', 'var',
'dl', 'dlElement', 'dt', 'dd', 'ol', 'ul', 'li',
'b', 'big', 'hr', 'i', 'small', 'sub', 'sup', 'tt',
'caption', 'col', 'colgroup', 'table', 'tableCell', ' tableCellScope', 'tbody', 'td', 'tfoot',
'th', 'thead', 'tr',
'img',
'a'
];
function adopt(oldParent, newParent) {
if (oldParent && newParent) {
var orphans = YUD.getChildren(oldParent);
if (orphans && orphans.length) {
var orphanCount = orphans.length;
for (var j = 0; j < orphanCount; j++) {
var orphan = orphans[j];
newParent.appendChild(oldParent.removeChild(orphan));
}
}
}
};
function pruneNonHtml(doc) {
var allNodes = [];
var traverseTreeRecursive = function (parentNode) {
if (parentNode) {
allNodes.push(parentNode);
var children = YUD.getChildren(parentNode);
if (children) {
for (var i = 0; i < children.length; i++) {
traverseTreeRecursive(children[i]);
}
}
}
};
var itemNode = doc.documentElement;
traverseTreeRecursive(itemNode);
var nodeCount = allNodes.length;
for (var i = 0; i < nodeCount; i++) {
var currentNode = allNodes.pop();
if ((validHtmlTags.indexOf(currentNode.nodeName) < 0) &&
(currentNode.parentNode != doc)) {
var grandParentNode = currentNode.parentNode;
adopt(currentNode, grandParentNode);
grandParentNode.removeChild(currentNode);
};
}
};
function loadStem(item) {
var stemEl = item.getStemElement();
var xmlString = item.qti.xml;
xmlString = xmlString.replace(/<prompt/g, '<p');
xmlString = xmlString.replace(/<\/prompt/g, '<\/p');
var xmlDoc = Util.Xml.parseFromString(xmlString);
pruneNonHtml(xmlDoc);
adopt(xmlDoc.documentElement, stemEl);
};
QTI.validHtmlTags = validHtmlTags;
QTI.loadStem = loadStem;
})(ContentManager.QTI);

// FILE: content_renderer.js (b3169e15) 3/7/2014 11:24:06 AM

ContentManager.Renderer =
{
_instance: null,
_client: null,
_customScripts: [],
_customStyles: [],
_customFormatter: null
};
ContentManager.Renderer.isDirect = function() {
return this._instance instanceof ContentManager.Renderer.Direct;
};
ContentManager.Renderer.getClient = function() { return this._client; };
ContentManager.Renderer.setClient = function(client) { this._client = client; };
ContentManager.Renderer.getCustomFormatter = function() { return this._customFormatter; };
ContentManager.Renderer.setCustomFormatter = function(formatterFunc) { this._customFormatter = formatterFunc; };
ContentManager.Renderer.processResources = function(resources)
{
if (YAHOO.lang.isFunction(this._customFormatter))
{
for (var i = 0; i < resources.length; i++)
{
resources[i] = this._customFormatter(resources[i]);
}
}
};
ContentManager.Renderer.clearCustomScripts = function() { this._customScripts = []; };
ContentManager.Renderer.getCustomScripts = function() { return this._customScripts; };
ContentManager.Renderer.addCustomScript = function(path) { this._customScripts.push(path); };
ContentManager.Renderer.getScripts = function()
{
var scripts =
[
'Scripts/Libraries/YUI/yahoo-dom-event/yahoo-dom-event.js',
'Scripts/Libraries/YUI/dragdrop/dragdrop-min.js',
'Scripts/Libraries/jwplayer/jwplayer.js'
];
for (var i = 0; i < this._customScripts.length; i++)
{
scripts.push(this._customScripts[i]);
}
ContentManager.Renderer.processResources(scripts);
return scripts;
};
ContentManager.Renderer.clearCustomStyles = function() { this._customStyles = []; };
ContentManager.Renderer.getCustomStyles = function() { return this._customStyles; };
ContentManager.Renderer.addCustomStyle = function(path) { this._customStyles.push(path); };
ContentManager.Renderer.getStyles = function()
{
var styles =
[
'Scripts/Libraries/YUI/menu/assets/skins/sam/menu.css',
'Scripts/Libraries/YUI/button/assets/skins/sam/button.css',
'Scripts/Libraries/YUI/container/assets/skins/sam/container.css',
'Scripts/Libraries/YUI/editor/assets/skins/sam/editor.css',
'Shared/CSS/items.css',
'Shared/CSS/elpa.css',
'Shared/CSS/accommodations.css',
'Shared/CSS/frame.css',
'Scripts/Simulator2/Renderer/CSS/simulator.css',
'Scripts/Simulator2/Renderer/CSS/slider.css'
];
if (this._client)
{
styles.push('Projects/' + this._client + '/css/items.css');
styles.push('Projects/' + this._client + '/css/elpa.css');
}
for (var i = 0; i < this._customStyles.length; i++)
{
styles.push(this._customStyles[i]);
}
if (YAHOO.env.ua.webkit)
{
styles.push('Shared/CSS/Browsers/webkit.css');
}
else if (YAHOO.env.ua.ie)
{
styles.push('Shared/CSS/Browsers/ie.css');
}
ContentManager.Renderer.processResources(styles);
return styles;
};
ContentManager.Renderer.applyStyles = function(doc, client)
{
var styles = this.getStyles(client);
var links = document.getElementsByTagName('link');
styles = Util.Array.reject(styles, function(style) {
return Util.Array.find(links, function(link) {
return (link.href.toLowerCase().indexOf(style.toLowerCase()) != -1);
});
});
for(var i = 0; i < styles.length; i++)
{
styles[i] = ContentManager.resolveBaseUrl(styles[i]);
}
Util.dir(styles);
var win = (doc.parentWindow || doc.defaultView);
YAHOO.util.Get.css(styles, { win: win });
};
ContentManager.Renderer.init = function(container, rendererClass)
{
container = YUD.get(container);
var rendererInstance = new rendererClass(container);
this._instance = rendererInstance;
this._instance.init();
};
ContentManager.Renderer.writeHtml = function(parentNode, html)
{
var parentDoc = Util.Dom.getOwnerDocument(parentNode);
var pageWrapper = parentDoc.createElement('div');
YUD.addClass(pageWrapper, 'pageWrapper');
if (html) {
if (html.documentElement) {
html = html.documentElement;
}
if (html.nodeType > 0) {
pageWrapper.appendChild(html);
} else {
pageWrapper.innerHTML = html;
}
}
pageWrapper.setAttribute('aria-hidden', 'true');
parentNode.appendChild(pageWrapper);
return pageWrapper;
};
ContentManager.Renderer.show = function(pageContainer) {
pageContainer.setAttribute('aria-hidden', 'false');
YUD.removeClass(pageContainer, 'hiding');
YUD.addClass(pageContainer, 'showing');
};
ContentManager.Renderer.hide = function(pageContainer) {
pageContainer.setAttribute('aria-hidden', 'true');
YUD.removeClass(pageContainer, 'showing');
YUD.addClass(pageContainer, 'hiding');
};
ContentManager.Renderer.writePage = function(page)
{
return this._instance.write(page);
};
ContentManager.Renderer.removePage = function(page)
{
return this._instance.remove(page);
};
ContentManager.Renderer.MultiFrame = function(rootContainer)
{
this.init = function()
{
ContentManager.Frame.setContainer(rootContainer);
};
this.write = function(page)
{
var frame = ContentManager.Frame.create(page.id, function(frame)
{
var frameDoc = Util.Dom.getFrameContentDocument(frame);
var frameForm = frameDoc.forms['contentForm'];
ContentManager.Renderer.writeHtml(frameForm, page.getHtml());
page.onRendered(frameDoc             , frame              );
});
ContentManager.Renderer.hide(frame);
};
this.remove = function(page)
{
ContentManager.Frame.remove(page.id);
};
};
ContentManager.Renderer.SingleFrame = function(rootContainer)
{
this._frame = null;
this.init = function()
{
ContentManager.Frame.setContainer(rootContainer);
ContentManager.Frame.create('contentFrame');
};
this.write = function(page)
{
var frame = document.getElementById('contentFrame');
var frameDoc = Util.Dom.getFrameContentDocument(frame);
var frameForm = frameDoc.forms['contentForm'];
var pageContainer = ContentManager.Renderer.writeHtml(frameForm, page.getHtml());
ContentManager.Renderer.hide(pageContainer);
page.onRendered(frameDoc, pageContainer);
};
this.remove = function(page)
{
var pageContainer = page.getContainer();
Util.Dom.removeNode(pageContainer);
};
};
ContentManager.Renderer.Direct = function(rootContainer)
{
this.init = function()
{
var contentForm = HTML.FORM({ id: 'contentForm', name: 'contentForm' });
rootContainer.appendChild(contentForm);
};
this.write = function(page)
{
var form = document.forms['contentForm'];
var pageContainer = ContentManager.Renderer.writeHtml(form, page.getHtml());
ContentManager.Renderer.hide(pageContainer);
page.onRendered(document, pageContainer);
};
this.remove = function(page)
{
var pageContainer = page.getContainer();
Util.Dom.removeNode(pageContainer);
};
};

// FILE: video_manager.js (de7c9fcf) 7/23/2014 4:30:37 PM

var VideoManager = {};
VideoManager.parseData = function(link)
{
if (link == null) return null;
var getAttrib = function(name) {
return YUD.getAttribute(link, 'data-' + name) ||
YUD.getAttribute(link, name);
};
var autoplay = getAttrib('autoplay');
autoplay = (autoplay) ? (autoplay.toLowerCase() == 'true') : false;
var dialog = getAttrib('dialog');
dialog = (dialog) ? (dialog.toLowerCase() == 'true') : false;
var controls = getAttrib('controls');
controls = (controls) ? (controls.toLowerCase() == 'true') : true;
return {
autoplay: autoplay,
dialog: dialog,
controls: controls,
url: YUD.getAttribute(link, 'href'),
type: YUD.getAttribute(link, 'type'),
width: (getAttrib('width') * 1),
height: (getAttrib('height') * 1)
};
};
VideoManager.canPlay = function(url)
{
if (typeof jwplayer != 'function') return false;
if (!jwplayer.utils.exists(url)) return false;
var extension = jwplayer.utils.extension(url);
if (!jwplayer.utils.exists(extension)) return false;
if (extension == 'm4a') return false;
var extPlayers = jwplayer.utils.extensionmap[extension];
if (!jwplayer.utils.exists(extPlayers)) return false;
return (Util.String.startsWith(extPlayers.html5, 'video') ||
Util.String.startsWith(extPlayers.flash, 'video'));
};
VideoManager.embed = function(pageWin, linkVideo,zoomFactor)
{
if (typeof pageWin.jwplayer != 'function') return false;
var id = YUD.generateId().replace('yui', 'video');
linkVideo.setAttribute('id', id);
var flashPath = ContentManager.resolveBaseUrl('Scripts/Libraries/jwplayer/player.swf');
var skinPath = ContentManager.resolveBaseUrl('Scripts/Libraries/jwplayer/skins/simple/simple.zip');
var videoData = VideoManager.parseData(linkVideo);
var config = {
provider: 'video',
autostart: videoData.autoplay,
fullscreen: false,
skin: skinPath
};
if (!videoData.controls) {
config['controlbar.position'] = 'none';
}
if (videoData.width > 0 && videoData.height > 0) {
config.width = videoData.width;
config.height = videoData.height;
} else {
config.width = 400;
config.height = 226;
}
var createAnArray = function() {
return (typeof pageWin.createAnArray == 'function') ? pageWin.createAnArray() : [];
};
config.levels = createAnArray();
config.levels.push({ file: videoData.url, type: videoData.type });
config.modes = createAnArray();
config.modes.push({ type: 'html5' });
config.modes.push({ type: 'flash', src: flashPath });
var player = pageWin.jwplayer(linkVideo).setup(config);
if (zoomFactor) {
var zoomWidth = config.width * zoomFactor;
var zoomHeight = config.height * zoomFactor;
player.resize(zoomWidth, zoomHeight);
}
return player;
};
VideoManager.stop = function(page)
{
VideoManager.SWF.forEach(page, function(swfAPI)
{
swfAPI.stop();
});
var pageWin = page.getWin();
if (YAHOO.lang.isFunction(pageWin.jwplayer))
{
var players = pageWin.jwplayer.getPlayers();
for (var i = 0; i < players.length; i++)
{
var player = players[i];
if (player.getState() == 'PLAYING') player.pause();
}
}
};
VideoManager.openDialog = function(ev, pageLink,zoomFactor)
{
TDS.ToolManager.hideAll();
var id = 'video-' + Util.String.hashCode(pageLink.href);
var videoDialog = TDS.ToolManager.get(id);
if (videoDialog == null)
{
var header = pageLink.title || '';
videoDialog = TDS.ToolManager.createPanel(id, 'video', header);
videoDialog.body.innerHTML = '';
var aslLink = pageLink.cloneNode(true);
videoDialog.body.appendChild(aslLink);
var videoPlayer = VideoManager.embed(window, aslLink, zoomFactor);
videoDialog.showEvent.subscribe(function()
{
videoPlayer.play();
});
videoDialog.hideEvent.subscribe(function()
{
videoPlayer.stop();
});
videoDialog.refresh = function()
{
var width = videoPlayer.getWidth();
var height = videoPlayer.getHeight();
if (width > 0 && height > 0)
{
height += videoDialog.header.offsetHeight;
height += (YUD.getStyle(videoDialog.body, 'padding-top').replace('px', '') * 1);
height += (YUD.getStyle(videoDialog.body, 'padding-bottom').replace('px', '') * 1);
width += (YUD.getStyle(videoDialog.body, 'padding-left').replace('px', '') * 1);
width += (YUD.getStyle(videoDialog.body, 'padding-right').replace('px', '') * 1);
videoDialog.cfg.setProperty('width', width + 'px');
videoDialog.cfg.setProperty('height', height + 'px');
}
};
videoPlayer.onReady(function()
{
videoDialog.refresh();
TDS.ToolManager.bottomLeft(videoDialog);
});
}
videoDialog.show();
};
VideoManager.patchJWPlayer = function(player)
{
if (player.__tds_fixedOuterHTML !== true)
{
player.utils.setOuterHTML = Util.Dom.setOuterHTML;
player.__tds_fixedOuterHTML = true;
}
if (player.__tds_fixedExt !== true)
{
player.utils.extension = function(path)
{
if (!path) { return ""; }
path = path.substring(path.lastIndexOf("/") + 1, path.length);
var pathPieces = path.split("?");
path = pathPieces[0];
if (pathPieces.length > 1)
{
var querystring = Util.QueryString.parse(pathPieces[1]);
if (querystring.file != null) path = querystring.file;
}
if (path.lastIndexOf('.') > -1) {
return path.substr(path.lastIndexOf('.') + 1, path.length).toLowerCase();
}
return null;
};
player.__tds_fixedExt = true;
}
};
(function()
{
if (typeof window.jwplayer == 'function')
{
VideoManager.patchJWPlayer(window.jwplayer);
}
})();

// FILE: video_swf.js (9c4a4bf0) 3/7/2014 11:24:14 AM

VideoManager.SWF = function(embed, data)
{
this._embed = embed;
this._data = data;
this._ready = false;
};
VideoManager.SWF.parseData = function(link)
{
if (link == null) return null;
var getAttrib = function(name) {
return YUD.getAttribute(link, 'data-' + name) ||
YUD.getAttribute(link, name);
};
var width = (getAttrib('width') * 1);
var height = (getAttrib('height') * 1);
var autoplay = getAttrib('autoplay');
autoplay = (autoplay) ? (autoplay.toLowerCase() == 'true') : false;
var html5 = getAttrib('anim-html5');
html5 = (html5) ? (html5.toLowerCase() == 'true') : false;
var flash = getAttrib('anim-flash');
flash = (flash) ? (flash.toLowerCase() == 'true') : YUD.hasClass(link, 'flashvideo');
var shell = getAttrib('anim-shell');
if (shell) {
shell = (shell.toLowerCase() == 'true');
} else {
if (html5) {
shell = false;
} else if (flash) {
shell = true;
} else {
shell = false;
}
}
return {
url: YUD.getAttribute(link, 'href'),
type: YUD.getAttribute(link, 'type'),
width: width,
height: height,
autoplay: autoplay,
shell: shell,
html5: html5,
flash: flash
};
};
VideoManager.SWF.prototype.getElement = function() { return this._embed; };
VideoManager.SWF.prototype.autoplay = function() { return this._data.autoplay; };
VideoManager.SWF.prototype.isReady = function() { return this._ready; };
VideoManager.SWF.prototype.getStatus = function()
{
if (!YAHOO.lang.isFunction(this._embed.getStatus))
{
return 'uninitialized';
}
var status = this._embed.getStatus();
if (status == 'notstarted') status = 'initialized';
return status;
};
VideoManager.SWF.prototype.isLoaded = function()
{
if (this.isReady()) return true;
return (this.getStatus() != 'uninitialized');
};
VideoManager.SWF.prototype.setReady = function() { this._ready = true; };
VideoManager.SWF.prototype.isPlaying = function()
{
return (this.getStatus() == 'playing');
};
VideoManager.SWF.prototype.play = function()
{
if (!this.isReady()) return false;
if (this.isPlaying()) return false;
if (YAHOO.lang.isFunction(this._embed.JSPlay))
{
this._embed.JSPlay();
return true;
}
return false;
};
VideoManager.SWF.prototype.stop = function()
{
if (!this.isReady()) return false;
if (!this.isPlaying()) return false;
if (YAHOO.lang.isFunction(this._embed.JSStop))
{
this._embed.JSStop();
return true;
}
return false;
};
VideoManager.SWF.collection = new Util.Structs.Map();
VideoManager.SWF.Status =
{
LOADING: 'loading',
LOADED: 'loaded',
PLAYING: 'playing',
PAUSED: 'paused',
STOPPED: 'stopped'
};
VideoManager.SWF.Events = new Util.EventManager();
VideoManager.SWF._animationStatusChange = function()
{
var data = [];
if (arguments.length == 1)
{
data.push(null);
data.push(arguments[0]);
}
else if (arguments.length == 2)
{
data.push(arguments[0]);
data.push(arguments[1]);
}
if (data.length == 0) return;
if (data[1] == 'notstarted') data[1] = 'initialized';
YAHOO.lang.later(0, VideoManager.SWF, VideoManager.SWF.processStatusChange, data);
};
VideoManager.SWF.processStatusChange = function(id, status)
{
if (status == 'initialized')
{
var apis = VideoManager.SWF.collection.getValues();
for (var i = 0; i < apis.length; i++)
{
var swfAPI = apis[i];
if (!swfAPI.isReady() && swfAPI.isLoaded())
{
swfAPI.setReady();
VideoManager.SWF.Events.fire(VideoManager.SWF.Status.LOADED, swfAPI);
}
}
}
if (status == 'playing')
{
VideoManager.SWF.Events.fire(VideoManager.SWF.Status.PLAYING, null);
}
if (status == 'stopped')
{
VideoManager.SWF.Events.fire(VideoManager.SWF.Status.STOPPED, null);
}
};
VideoManager.SWF.embed = function(win, linkVideo, overrideAutoplay, disableShell)
{
if (!YAHOO.lang.isFunction(win.animationStatusChange))
{
win.animationStatusChange = VideoManager.SWF._animationStatusChange;
win.checkAutoPlay = function() { return false; };
}
var id = 'Animation-' + YAHOO.util.Dom.generateId();
var animData = VideoManager.SWF.parseData(linkVideo);
if (YAHOO.lang.isBoolean(overrideAutoplay)) animData.autoplay = overrideAutoplay;
var linkDoc = Util.Dom.getOwnerDocument(linkVideo);
var divVideo = linkDoc.createElement('div');
YUD.addClass(divVideo, 'AnimationContainer');
YUD.setStyle(divVideo, 'width', animData.width + 'px');
YUD.setStyle(divVideo, 'height', animData.height + 'px');
divVideo.innerHTML = this.createHtml(id, animData, disableShell);
YUD.insertAfter(divVideo, linkVideo);
var parentNode = linkVideo.parentNode;
parentNode.removeChild(linkVideo);
var children = YUD.getChildren(divVideo);
var embed = (children && children.length > 0) ? children[0] : null;
VideoManager.SWF.stopRightClick(embed);
var swfAPI = new VideoManager.SWF(embed, animData);
VideoManager.SWF.collection.set(id, swfAPI);
VideoManager.SWF.Events.fire(VideoManager.SWF.Status.LOADING, swfAPI);
return swfAPI;
};
VideoManager.SWF.createHtml = function(id, animData, disableShell)
{
var wmode;
if (Util.Browser.isMac() && Util.Browser.getFirefoxVersion() == 2)
{
wmode = 'window';
}
else
{
wmode = 'opaque';
}
var embedBuilder = [];
embedBuilder.push('<embed');
embedBuilder.push('id="' + id + '"');
embedBuilder.push('type="application/x-shockwave-flash"');
if (disableShell || !animData.shell)
{
embedBuilder.push('src="' + animData.url + '"');
}
else
{
var shellPath = ContentManager.resolveBaseUrl('Scripts/Video/AnimationShell.swf');
var animPath = encodeURIComponent(animData.url);
var vars = 'animID=' + id + '&animURL=' + animPath;
embedBuilder.push('src="' + shellPath + '"');
embedBuilder.push('flashvars="' + vars + '"');
}
embedBuilder.push('width="100%"');
embedBuilder.push('height="100%"');
embedBuilder.push('play="' + animData.autoplay + '"');
embedBuilder.push('loop="false"');
embedBuilder.push('menu="false"');
embedBuilder.push('allowscriptaccess="always"');
embedBuilder.push('allowfullscreen="false"');
embedBuilder.push('quality="autohigh"');
embedBuilder.push('wmode="' + wmode + '"');
embedBuilder.push('></embed>');
return embedBuilder.join(' ');
};
VideoManager.SWF.forEach = function(page, fn)
{
var pageEl = page.getElement();
var pageEmbeds = pageEl.getElementsByTagName('embed');
for (var i = 0; i < pageEmbeds.length; i++)
{
var embed = pageEmbeds[i];
var swfAPI = VideoManager.SWF.collection.get(embed.id);
if (swfAPI != null)
{
try { fn(swfAPI); }
catch (ex) { Util.log('SWF ERROR: ' + ex); }
}
}
};
VideoManager.SWF.stopPlaying = function()
{
var page = ContentManager.getCurrentPage();
if (page == null) return;
VideoManager.SWF.forEach(page, function(api)
{
if (api.isPlaying()) api.stop();
});
};
VideoManager.SWF.stopRightClick = function(embed)
{
var flashDoc = Util.Dom.getOwnerDocument(embed);
var flashWin = (flashDoc.parentWindow || flashDoc.defaultView);
if (flashWin.addEventListener)
{
flashWin.addEventListener('mousedown', VideoManager.SWF._onGeckoMouse, true);
}
else
{
embed.onmouseup = function() { embed.releaseCapture(); };
}
};
VideoManager.SWF._onGeckoMouse = function(evt)
{
var target = YUE.getTarget(evt);
if (target && target.type == 'application/x-shockwave-flash' && evt.button != 0)
{
VideoManager.SWF._killEvents(evt);
}
};
VideoManager.SWF._killEvents = function(evt)
{
if (evt)
{
if (evt.stopPropagation) evt.stopPropagation();
if (evt.preventDefault) evt.preventDefault();
if (evt.preventCapture) evt.preventCapture();
if (evt.preventBubble) evt.preventBubble();
}
};

// FILE: animation_manager.js (bfb84190) 3/7/2014 11:24:06 AM

(function() {
var CSS_FRAME_ANIMATION = 'frame-anim-html5';
var AnimationManager = {};
AnimationManager.canPlayHTML5 = function (pageLink) {
var animData = VideoManager.SWF.parseData(pageLink);
if (animData.html5) {
if (YAHOO.env.ua.ie > 0 &&
YAHOO.env.ua.ie < 9) {
return false;
}
if (Util.Browser.getFirefoxVersion() > 0 &&
Util.Browser.getFirefoxVersion() < 4) {
return false;
}
return true;
}
return false;
};
AnimationManager.injectHTML5 = function (pageLink, scriptUrl) {
var animData = VideoManager.SWF.parseData(pageLink);
var animUrl = animData.url.replace('.swf', '.html');
if (animUrl.indexOf('?') != -1) {
var id = Util.Date.now();
if (typeof TDS == 'object') {
if (TDS.buildNumber) {
id = TDS.buildNumber;
} else if (TDS.Cache && TDS.Cache.id) {
id = TDS.Cache.id;
}
}
animUrl = animUrl.replace('?', '?cid=' + id + '&');
}
if (scriptUrl && animUrl.indexOf('?') != -1) {
scriptUrl = encodeURIComponent(scriptUrl);
animUrl = animUrl.replace('?', '?scriptUrl=' + scriptUrl + '&');
}
var animWidth = (animData.width || 400);
var animHeight = (animData.height || 400);
var animDoc = Util.Dom.getOwnerDocument(pageLink);
var animFrame = animDoc.createElement('iframe');
animFrame.className = CSS_FRAME_ANIMATION;
animFrame.setAttribute('width', animWidth + 'px');
animFrame.setAttribute('height', animHeight + 'px');
animFrame.setAttribute('src', animUrl);
pageLink.parentNode.replaceChild(animFrame, pageLink);
return animFrame;
};
AnimationManager.reloadHTML5 = function(currentFrame) {
var animUrl = YUD.getAttribute(currentFrame, 'src');
var animWidth = YUD.getAttribute(currentFrame, 'width');
var animHeight = YUD.getAttribute(currentFrame, 'height');
var animDoc = Util.Dom.getOwnerDocument(currentFrame);
var animFrame = animDoc.createElement('iframe');
animFrame.className = CSS_FRAME_ANIMATION;
animFrame.setAttribute('width', animWidth);
animFrame.setAttribute('height', animHeight);
animFrame.setAttribute('src', animUrl);
currentFrame.parentNode.replaceChild(animFrame, currentFrame);
return animFrame;
};
AnimationManager.getHTML5Frames = function(el) {
var animFrames = [],
frames = el.getElementsByTagName('iframe');
YUD.batch(frames, function(frame) {
if (YUD.hasClass(frame, CSS_FRAME_ANIMATION)) {
animFrames.push(frame);
}
});
return animFrames;
};
AnimationManager.stop = function(animFrame) {
console.log('Content Dialog: Stop HTML5 animation');
var animWin = Util.Dom.getFrameContentWindow(animFrame);
if (animWin) {
if (typeof animWin.stopAnimation == 'function') {
animWin.stopAnimation();
} else {
}
}
};
AnimationManager.resume = function(animFrame) {
console.log('Content Dialog: Resume HTML5 animation');
var animWin = Util.Dom.getFrameContentWindow(animFrame);
if (animWin) {
if (typeof animWin.playAnimation == 'function') {
setTimeout(function() {
animWin.playAnimation();
}, 30);
} else {
}
}
};
window.AnimationManager = AnimationManager;
})();

// FILE: module_animation.js (6e8fc5bd) 3/7/2014 11:24:06 AM

(function ()
{
function processLinks(parentEl) {
var processed = false;
var scriptUrl = ContentManager.resolveBaseUrl('Scripts/Libraries/');
var pageLinks = parentEl.getElementsByTagName('a');
YUD.batch(pageLinks, function (pageLink) {
if (AnimationManager.canPlayHTML5(pageLink)) {
AnimationManager.injectHTML5(pageLink, scriptUrl);
processed = true;
}
});
return processed;
}
ContentManager.onPageEvent('available', function (page) {
var pageEl = page.getElement();
processLinks(pageEl);
});
ContentManager.onPageEvent('show', function (page) {
var pageEl = page.getElement();
var animFrames = AnimationManager.getHTML5Frames(pageEl);
if (animFrames.length > 0) {
AnimationManager.reloadHTML5(animFrames[0]);
}
});
ContentManager.Dialog.onLoad.subscribe(function(frame) {
var frameDoc = frame.getDocument();
if (Util.String.contains(frame.id, 'help')) {
processLinks(frameDoc);
}
});
ContentManager.Dialog.onBeforeHide.subscribe(function(frame) {
var dialogFrame = frame.getDocument();
if (dialogFrame) {
var animFrames = AnimationManager.getHTML5Frames(dialogFrame);
if (animFrames.length > 0) {
AnimationManager.stop(animFrames[0]);
}
}
});
ContentManager.Dialog.onShow.subscribe(function(frame) {
var dialogFrame = frame.getDocument();
if (dialogFrame) {
var animFrames = AnimationManager.getHTML5Frames(dialogFrame);
if (animFrames.length > 0) {
AnimationManager.resume(animFrames[0]);
}
}
});
})();

// FILE: common.js (815f4e7e) 3/7/2014 11:24:07 AM

var Lang = YAHOO.util.Lang;
var ErrorHandler =
{
report: function(name, ex)
{
if (typeof console != 'object') return;
console.error(name + ' ' + ex.name + ': ' + ex.message + ' - ' + ex.fileName + ' (line ' + ex.lineNumber + ')');
},
wrapFunction: function(context, name)
{
var fn = context[name];
if (YAHOO.lang.isObject(context) && YAHOO.lang.isFunction(fn))
{
context[name] = function()
{
try
{
return fn.apply(context, arguments);
}
catch (ex)
{
ErrorHandler.report(name, ex);
throw ex;
}
};
}
},
wrapFunctions: function(context, names)
{
if (YAHOO.lang.isArray(names))
{
for (var i = 0; i < names.length; i++)
{
ErrorHandler.wrapFunction(context, names[i]);
}
}
}
};
var EventLazyProvider = function() {};
EventLazyProvider.prototype =
{
_scope: null,
setScope: function(obj) { this._scope = obj; },
fireLazy: function(name, obj)
{
if (!this.hasEvent(name))
{
if (this._scope) this.createEvent(name, { scope: this._scope });
else this.createEvent(name);
}
return this.fireEvent(name, obj);
}
};
YAHOO.lang.augmentProto(EventLazyProvider, YAHOO.util.EventProvider);
(function() {
var con;
try {
con = top.console;
} catch (ex) {
con = console;
}
function Logger(prefix) {
var enabled = true;
this.enable = function() {
enabled = true;
};
this.disable = function() {
enabled = false;
};
function log(level, message, params) {
if (!enabled) {
return;
}
if (level == 'error') {
level = 'warn';
}
if (!con || !con[level]) {
return;
}
if (prefix) {
message = prefix + message;
}
if (params) {
message = YAHOO.lang.substitute(message, params);
}
try {
con[level](message);
} catch (ex) {
}
}
this.debug = function (message, params) { log('debug', message, params); };
this.info = function (message, params) { log('info', message, params); };
this.warn = function (message, params) { log('warn', message, params); };
this.error = function (message, params) { log('error', message, params); };
};
window.Logger = Logger;
})();
var logger = new Logger('GRID: ');

// FILE: grid.js (19b0410c) 3/7/2014 11:24:07 AM

var Grid = function(element, svgFile)
{
this._element = YAHOO.util.Dom.get(element);
this._svgFile = svgFile;
this.view = null;
this.ui = null;
this.model = null;
this.question = null;
this.importexport = null;
this.palette = null;
this.toolbar = null;
this.feedback = null;
this.canvas = null;
this._currentPanel = null;
this._currentMode = null;
this._state = Grid.State.Uninitialized;
this._canvasComponents = [];
this.showCoordinates = false;
this.allowTab = true;
this._debug = false;
this.view = this.ui = new Grid.View(this._svgFile);
this.model = this.question = new Grid.Model();
this.importexport = new Grid.ImportExport(this.model);
this.palette = new Grid.Palette(this);
this.toolbar = new Grid.Toolbar(this);
this.canvas = new Grid.Canvas(this);
if (Grid.Utils.hasSVGWeb())
{
ErrorHandler.wrapFunctions(this, ['_svgRendered', 'init', 'update', 'loadItemXml', 'loadResponseXml', 'getResponseXml']);
}
Grid.Events.fireLazy('onNew', this);
};
Grid.Events = new EventLazyProvider();
YAHOO.lang.augmentProto(Grid, EventLazyProvider);
Grid.State =
{
Error: -1,
Uninitialized: 0,
Initialized: 1,
Created: 2,
Ready: 3,
Loading: 4,
Loaded: 5
};
GridState = Grid.State;
Grid.prototype.isReadOnly = function() { return false; };
Grid.prototype._setState = function(state, data)
{
this._state = state;
var stateName = 'Unknown';
switch (this._state)
{
case Grid.State.Error: stateName = 'Error'; break;
case Grid.State.Uninitialized: stateName = 'Uninitialized'; break;
case Grid.State.Initialized: stateName = 'Initialized'; break;
case Grid.State.Created: stateName = 'Created'; break;
case Grid.State.Ready: stateName = 'Ready'; break;
case Grid.State.Loading: stateName = 'Loading'; break;
case Grid.State.Loaded: stateName = 'Loaded'; break;
}
this.fireLazy('onStateChange', { grid: this, state: state, name: stateName, data: data });
};
Grid.prototype.getState = function() { return this._state; };
Grid.prototype.reportError = function(msg, ex, silent)
{
this.fireLazy('onError', { message: msg, exception: ex });
if (ex && !silent) throw ex;
};
Grid.prototype._processKeyEvent = function(evt)
{
evt.preventDefault();
if (this.isReadOnly()) return;
var key = '';
switch (evt.keyCode)
{
case 9: key = 'tab'; break;
case 13: key = 'enter'; break;
case 27: key = 'esc'; break;
case 32: key = 'space'; break;
case 37: key = 'left'; break;
case 38: key = 'up'; break;
case 39: key = 'right'; break;
case 40: key = 'down'; break;
}
var keyEvent =
{
dom: evt,
key: key
};
var area = this.getArea();
if (this.allowTab && evt.ctrlKey && key == 'tab')
{
this.view._svgWin.focus();
if (area == 'canvas')
{
if (this.model.options.showPalette) this.setArea('palette');
else if (this.model.options.showButtons.length > 0) this.setArea('toolbar');
}
else if (area == 'palette') this.setArea('toolbar');
else if (area == 'toolbar') this.setArea('canvas');
return;
}
if (area == 'canvas' && typeof this.canvas.processKeyEvent == 'function') this.canvas.processKeyEvent(keyEvent);
else if (area == 'palette' && typeof this.palette.processKeyEvent == 'function') this.palette.processKeyEvent(keyEvent);
else if (area == 'toolbar' && typeof this.toolbar.processKeyEvent == 'function') this.toolbar.processKeyEvent(keyEvent);
};
Grid.prototype._svgRendered = function()
{
var grid = this;
var groupPalette = this.view.getElementById('groupPalette');
var groupToolbar = this.view.getElementById('groupToolbar');
var groupCanvas = this.view.getElementById('groupCanvas');
if (groupPalette) {
Grid.Utils.addMouseListener(groupPalette, 'mousedown', function (evt) {
if (!grid.isReadOnly()) {
grid.setArea('palette');
}
});
}
if (groupToolbar) {
Grid.Utils.addMouseListener(groupToolbar, 'mousedown', function (evt) {
if (!grid.isReadOnly()) {
grid.setArea('toolbar');
}
});
}
Grid.Utils.addMouseListener(groupCanvas, 'mousedown', function (evt) {
if (!grid.isReadOnly()) {
grid.setArea('canvas');
}
});
this.view._svgRoot.addEventListener("keyup", function(evt) { evt.preventDefault(); }, false);
this.view._svgRoot.addEventListener("keypress", function(evt) { evt.preventDefault(); }, false);
this.view._svgRoot.addEventListener("keydown", function(evt)
{
try { grid._processKeyEvent(evt); }
catch (ex) { grid.reportError('Error processing key event', ex); }
}, false);
grid.view._svgRoot.addEventListener('contextmenu', function(evt) {
evt.preventDefault();
}, false);
this.addMouseListener('groupCanvas', function(evt)
{
if (grid.isReadOnly()) return;
try
{
var i = grid._canvasComponents.length;
while (i--)
{
var canvasComponent = grid._canvasComponents[i];
var success;
if (typeof canvasComponent.processMouseEvent == 'function')
{
success = canvasComponent.processMouseEvent(evt);
}
if (success === false) return;
}
}
catch (ex) { grid.reportError('Error processing canvas mouse event', ex); }
});
this.registerCanvasComponent(grid.canvas);
this.addMouseListener('groupWrapper', function(evt)
{
if (grid.isReadOnly()) return;
try { grid.palette.processMouseEvent(evt); }
catch (ex) { grid.reportError('Error processing palette mouse event', ex); }
});
this.addMouseListener('groupCanvas', function(evt)
{
if (grid.showCoordinates)
{
grid.view.setCoordinatesText('(' + evt.currentPosition.x + ',' + (grid.model.options.canvasHeight - evt.currentPosition.y) + ')');
}
});
grid.palette.subscribeToModelEvents();
grid.canvas.subscribeToModelEvents();
if (groupToolbar)
{
this.toolbar.init();
}
this.setMode('move');
if (YAHOO.env.ua.gecko < 1.91)
{
this.view._suspendRedrawEnabled = true;
this.view._attributeBatchEnabled = true;
}
setTimeout(function()
{
grid._setState(Grid.State.Ready);
}, 0);
};
Grid.prototype.registerCanvasComponent = function(obj)
{
this._canvasComponents.push(obj);
};
Grid.prototype.getArea = function() { return this._currentPanel; };
Grid.prototype.setArea = function(panelName)
{
if (this._currentPanel == panelName) return false;
this.canvas.stopAction();
this.canvas.clearFocused();
if (this._currentPanel != null)
{
switch (this._currentPanel)
{
case 'canvas': this.view.setAttributes('backgroundCanvas', { 'stroke': 'black' }); break;
case 'palette': this.view.setAttributes('backgroundPalette', { 'stroke': 'black' }); break;
case 'toolbar': this.view.setAttributes('backgroundToolbar', { 'stroke': 'white' }); break;
}
}
this._currentPanel = panelName;
if (this._currentPanel != null)
{
switch (this._currentPanel)
{
case 'canvas': this.view.setAttributes('backgroundCanvas', { 'stroke': 'blue' }); break;
case 'palette': this.view.setAttributes('backgroundPalette', { 'stroke': 'blue' }); break;
case 'toolbar': this.view.setAttributes('backgroundToolbar', { 'stroke': 'blue' }); break;
}
}
this.fireLazy('onAreaChange', { grid: this, name: panelName });
return true;
};
Grid.prototype.getMode = function() { return this._currentMode; };
Grid.prototype.setMode = function(mode)
{
if (this.palette.moving) return;
if (this._currentMode != null && mode == this._currentMode && mode == 'move') return;
if (mode == this._currentMode)
{
mode = 'move';
}
var currentButton;
if (this._currentMode)
{
currentButton = this.toolbar.getButton(this._currentMode);
if (currentButton) currentButton.deselect();
}
this._currentMode = mode;
currentButton = this.toolbar.getButton(this._currentMode);
if (currentButton) currentButton.select();
this.canvas.stopAction();
this.setModeCursor();
this.setModeHint();
this.fireLazy('onModeChange', { grid: this, name: mode });
};
Grid.prototype.init = function()
{
var grid = this;
if (this.getState() != Grid.State.Uninitialized)
{
throw Error('Grid has already been initialized.');
}
this.view.subscribe('loaded', function()
{
grid._setState(Grid.State.Created);
grid._svgRendered();
});
this._setState(Grid.State.Initialized);
this.view.render(this._element);
};
Grid.prototype.getLayout = function() {
if (this.model == null || this.model.options == null) return null;
var options = this.model.options;
var layout = new Grid.Layout();
layout.setContainerPadding(
options.containerPaddingTop,
options.containerPaddingRight,
options.containerPaddingBottom,
options.containerPaddingLeft);
layout.setPaletteWidth(options.paletteWidth, options.paletteGutter);
layout.setToolbarHeight(options.toolbarHeight, options.toolbarGutter);
layout.setCanvasWidth(options.canvasWidth + options.canvasWidthExt);
layout.setCanvasHeight(options.canvasHeight + options.canvasHeightExt);
layout.setCanvasBorderOffset(options.canvasBorderOffset);
layout.setFeedbackHeight(options.feedbackHeight, options.feedbackGutter);
return layout;
};
Grid.prototype.update = function()
{
var options = this.model.options;
if (options.updateLayout) {
var layout = this.getLayout();
this.view.updateLayout(layout);
}
if (options.showGridLines) this.view.createGridLines(options.gridSpacing);
else this.view.clearGridLines();
if (options.showPalette) this.view.showPalette();
else this.view.hidePalette();
if (options.showFeedback) this.view.showFeedback();
else this.view.hideFeedback();
if (options.showToolbar && options.showButtons.length > 0)
{
this.view.showToolbar();
var buttonNames = ['move'];
for (var i = 0; i < options.showButtons.length; i++)
{
var buttonName = options.showButtons[i];
buttonNames.push(buttonName);
}
this.toolbar.enableButtons(buttonNames);
}
else
{
this.view.hideToolbar();
this.toolbar.resetButtons();
}
this.view.updateCenterScaleImage(options.paletteCenter, options.paletteScale);
this.setMode('move');
};
Grid.prototype.loadXml = function(itemXml, responseXml)
{
if (this._debug) logger.info('LOAD ITEM XML = ' + itemXml);
if (this.getState() < Grid.State.Ready)
{
throw Error('Grid is not ready to load (make sure to call init first).');
}
this._setState(Grid.State.Loading);
var grid = this;
var callbackFailure = function(message, values)
{
grid._setState(Grid.State.Error, { message: message, values: values });
};
var callbackCreated = function()
{
var svgImages = grid.view.getElementsByTagName('image');
if (YAHOO.env.ua.gecko &&
typeof ResourceLoader == 'function' &&
(svgImages && svgImages.length > 0))
{
var imageLoader = new ResourceLoader.ImageCollection();
for (var i = 0; i < svgImages.length; i++)
{
imageLoader.addImage(svgImages[i]);
}
imageLoader.load(callbackLoaded, function()
{
var imageErrors = imageLoader.getErrors();
callbackFailure('Error loading SVG images', imageErrors);
});
}
else
{
callbackLoaded();
}
};
var callbackLoaded = function()
{
grid.update();
if (responseXml)
{
if (grid._debug) logger.info('LOAD RESPONSE XML = ' + responseXml);
grid.importexport.loadAnswer(responseXml);
}
grid._setState(Grid.State.Loaded);
grid.view.zoom(1);
};
this.importexport.loadItem(itemXml, callbackCreated, callbackFailure);
};
Grid.prototype.getResponseXml = function()
{
if (!this.isLoaded()) return null;
return this.importexport.getAnswerXml();
};
Grid.prototype.isLoaded = function()
{
return (this.getState() == Grid.State.Loaded);
};
Grid.prototype.hasChanged = function(xml)
{
if (!this.isLoaded()) return false;
var cleanXml = function(xml)
{
if (xml == null) return '';
var values = xml.split('DOCTYPE');
if (values.length > 1) return values[1].split(' ').join('').split('\r').join('');
else return xml;
};
var currentAnswerXml = this.getResponseXml();
return (cleanXml(currentAnswerXml) != cleanXml(xml));
};
Grid.prototype.isValid = function()
{
if (this.isLoaded())
{
if (this.importexport && this.importexport.isStudentResponseValid()) return true;
}
return false;
};
Grid.Hints =
{
'SetPoint': 'Select locations of points',
'Connect': 'Select 2 points to connect or press & drag to create & connect points.',
'Arrow': 'Select 2 points to connect with arrow.',
'DoubleArrow': 'Select 2 points to connect with double arrow.',
'Delete': 'Select object to delete.',
'AddValue': 'Select point or edge to add value',
'AddLabel': 'Select location of label',
'AddComponent': '',
'MotionPending': 'Move object to new location and click where you want it.',
'DraggingObject': 'Release the mouse button to drop it where you want it.',
'WaitForDropDragging': 'Release the mouse button to drop it where you want it.',
'WaitForDrop': 'Click to drop the object where you want it.',
'None': ' '
};
Grid.getHint = function(key)
{
if(typeof(window.Messages) == 'object')
{
return window.Messages.get("GridJS.Label.Hint"+key);
}
return Grid.Hints[key] || '';
};
Grid.prototype.setHint = function(key) { this.view.setFeedbackText(Grid.getHint(key)); };
Grid.prototype.setModeHint = function()
{
var mode = this.getMode();
switch(mode)
{
case 'move': this.setHint('None'); break;
case 'delete': this.setHint('Delete'); break;
case 'point': this.setHint('SetPoint'); break;
case 'connect': this.setHint('Connect'); break;
case 'arrow': this.setHint('Arrow'); break;
case 'arrw2': this.setHint('DoubleArrow'); break;
default: this.setHint('');
}
};
Grid.prototype.setModeCursor = function()
{
var mode = this.getMode();
switch(mode)
{
case 'move': this.view.setCanvasCursor('default'); break;
case 'delete': this.view.setCanvasCursor('crosshair'); break;
case 'arrow': this.view.setCanvasCursor('pointer'); break;
case 'arrw2': this.view.setCanvasCursor('pointer'); break;
case 'point': this.view.setCanvasCursor('pointer'); break;
case 'connect': this.view.setCanvasCursor('pointer'); break;
default: this.view.setCanvasCursor('default');
}
};
Grid.prototype.addMouseListener = function(id, handler)
{
var group = this.view.getElementById(id);
if (!group) return false;
var grid = this;
var isClicked = false;
var isDragging = false;
var clickedPosition = null;
var mouseEventHandler = function(name               , evt             )
{
evt.preventDefault();
var clientX = evt.clientX - 0.5;
var clientY = evt.clientY - 0.5;
var currentPosition = grid.view.translateElement(group, clientX, clientY);
if (YAHOO.env.ua.ie)
{
currentPosition.x = Math.round(currentPosition.x);
currentPosition.y = Math.round(currentPosition.y);
}
if (name == 'mousedown') clickedPosition = currentPosition;
var callHandler = function(eventName)
{
var svgEvent =
{
name: eventName,
target: evt.target,
raw: evt,
currentPosition: currentPosition,
clickedPosition: clickedPosition
};
handler(svgEvent);
};
if (name == 'mousedown')
{
if (isDragging)
{
callHandler('dragend');
isClicked = false;
isDragging = false;
}
else
{
isClicked = true;
callHandler('mousedown');
}
}
else if (name == 'mousemove')
{
if (isClicked) {
if (!isDragging) {
var hasMoved = (clickedPosition.x != currentPosition.x ||
clickedPosition.y != currentPosition.y);
if (hasMoved) {
callHandler('dragbegin');
isDragging = true;
}
}
if (isDragging) {
callHandler('drag');
}
} else {
callHandler('mousemove');
}
}
else if (name == 'mouseup')
{
if (isDragging)
{
callHandler('dragend');
isDragging = false;
}
else if (isClicked)
{
callHandler('mouseup');
}
isClicked = false;
clickedPosition = null;
}
if (name == 'mousedown') {
grid.view._svgWin.focus();
}
};
Grid.Utils.addMouseListener(group, 'mousedown', function(evt) {
mouseEventHandler('mousedown', evt);
});
Grid.Utils.addMouseListener(group, 'mousemove', function(evt) {
mouseEventHandler('mousemove', evt);
});
Grid.Utils.addMouseListener(group, 'mouseup', function(evt) {
mouseEventHandler('mouseup', evt);
});
return true;
};
Grid.prototype.dispose = function()
{
if (this.view) this.view.dispose();
Grid.Events.fireLazy('onDispose', this);
};
Grid.prototype.validate = function()
{
if (YAHOO.env.ua.gecko == 0) return true;
var setError = Util.bind(function(msg, modelImage)
{
if (typeof console == 'object') console.error('GRID: ' + msg);
this._setState(GridState.Error, { message: msg, values: [ modelImage ] });
return false;
}, this);
var modelImages = [];
modelImages = modelImages.concat(this.model.getBackgroundImages());
modelImages = modelImages.concat(this.model.getImages());
modelImages = modelImages.concat(this.model.getRegionsImages());
for (var i = 0; i < modelImages.length; i++)
{
var modelImage = modelImages[i];
var modelRect = modelImage.getBoundingRect();
var inBounds = (modelRect.left >= -1 && modelRect.left <= this.view.width &&
modelRect.top >= -1 && modelRect.top <= this.view.height);
if (!inBounds) return setError('Error with position of image out of bounds', modelImage);
var svgImage = this.view.getElementById(modelImage.getID());
if (!svgImage) return setError('Error finding the svg image', modelImage);
if (modelImage.isVisible())
{
if (svgImage.getAttribute('display') == 'none')
{
return setError('Error with image it should be visible but it is hidden', modelImage);
}
}
else
{
if (svgImage.getAttribute('display') != 'none')
{
return setError('Error with image it should be hidden but it is visible', modelImage);
}
}
var imgAttribs = {
x: svgImage.getAttribute('x') * 1,
y: svgImage.getAttribute('y') * 1,
width: svgImage.getAttribute('width') * 1,
height: svgImage.getAttribute('height') * 1
};
if (modelRect.width != imgAttribs.width ||
modelRect.height != imgAttribs.height)
{
return setError('Error with the attributes width/height of image', modelImage);
}
if (modelRect.left != imgAttribs.x ||
modelRect.top != imgAttribs.y)
{
return setError('Error with the attributes position of image', modelImage);
}
var imgRect = null;
if (modelImage.isVisible() && typeof svgImage.getBBox == 'function')
{
try { imgRect = svgImage.getBBox(); }
catch (ex)
{
return setError('Error with image bounding box', modelImage);
}
}
if (imgRect)
{
if (modelRect.width != imgRect.width ||
modelRect.height != imgRect.height)
{
return setError('Error with the bounding box width/height of image', modelImage);
}
if (modelRect.left != imgRect.x ||
modelRect.top != imgRect.y)
{
return setError('Error with the bounding box position of image', modelImage);
}
}
}
return true;
};

// FILE: utils.js (afbe1732) 3/7/2014 11:24:07 AM

Grid.Utils = {};
Grid.Utils.hasSVGNative = function() {
return document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
};
Grid.Utils.hasSVGWeb = function() {
return (typeof(svgweb) == 'object');
};
Grid.Utils.isSVGFlash = function() {
return (Grid.Utils.hasSVGWeb() && svgweb.getHandlerType() == 'flash');
};
(function (Utils) {
var touchScreen = 'ontouchstart' in window;
var touchEvents = {
'mousedown': 'touchstart',
'mouseup': 'touchend',
'mousemove': 'touchmove'
};
var mouseEvents = {
'mousedown': 'mousedown',
'mouseup': 'mouseup',
'mousemove': 'mousemove'
};
var getWindowsNTVersion = function() {
var matches = navigator.userAgent.match(/Windows NT (\d+\.\d+)/);
var value;
if (matches && matches[1]) {
value = parseFloat(matches[1]);
}
return value || 0;
};
var supportsTouchAndMouse = function() {
return (touchScreen && getWindowsNTVersion() >= 6.1);
};
var normalizeTouchEvent = function (evt) {
if (evt.changedTouches) {
var touches = evt.changedTouches;
for (var i = 0, ii = touches.length; i < ii; i++) {
if (touches[i].target == evt.target) {
var oldevt = evt;
evt = touches[i];
evt.preventDefault = function () {
return oldevt.preventDefault();
};
evt.stopPropagation = function () {
return oldevt.stopPropagation();
};
return evt;
}
}
}
return evt;
};
var addMouseListener = function (target, name, fn) {
var touchAndMouse = supportsTouchAndMouse();
var eventName, altEventName;
if (touchScreen) {
eventName = (touchEvents[name] || name);
if (touchAndMouse) {
altEventName = (mouseEvents[name] || name);
}
} else {
eventName = (mouseEvents[name] || name);
}
var processEvent = function(evt) {
if (touchAndMouse) {
evt.preventDefault();
}
if (touchScreen) {
evt = normalizeTouchEvent(evt);
}
fn(evt);
};
if (eventName) {
target.addEventListener(eventName, processEvent, false);
if (altEventName) {
target.addEventListener(altEventName, processEvent, false);
}
}
};
Utils.addMouseListener = addMouseListener;
})(Grid.Utils);
Grid.Utils.importNode = function(doc, importedNode, deep) {
if (!doc) doc = document;
var node = null;
switch (importedNode.nodeType) {
case 1:
var nodeNS = importedNode.namespaceURI;
if (typeof doc.createElementNS == 'function' && nodeNS != null) {
node = doc.createElementNS(nodeNS, importedNode.nodeName);
} else {
node = doc.createElement(importedNode.nodeName);
}
Grid.Utils.importAttributes(importedNode, node);
if (deep && importedNode.childNodes && importedNode.childNodes.length > 0) {
for (var i = 0, il = importedNode.childNodes.length; i < il; i++) {
var childNode = Grid.Utils.importNode(doc, importedNode.childNodes[i], deep);
if (childNode) node.appendChild(childNode);
}
}
break;
case 3:
node = doc.createTextNode(importedNode.nodeValue, true);
break;
case 4:
break;
case 7:
break;
case 8:
break;
}
return node;
};
Grid.Utils.importAttributes = function(importedNode, node) {
if (importedNode.attributes && importedNode.attributes.length > 0) {
for (var i = 0, il = importedNode.attributes.length; i < il; i++) {
var attrNS = importedNode.attributes[i].namespaceURI;
var attrName = importedNode.attributes[i].nodeName;
if (node.getAttribute(attrName) == null) {
var attrValue = importedNode.getAttribute(attrName);
if (typeof node.setAttributeNS == 'function' && attrNS != null) {
node.setAttributeNS(attrNS, attrName, attrValue);
} else {
node.setAttribute(attrName, attrValue);
}
}
}
}
};
Grid.Utils.getOffset = function(element) {
var hasClientRects = false;
try {
hasClientRects = (element && typeof element.getClientRects == 'function');
} catch (ex) {
}
if (hasClientRects) {
return {
top: element.getClientRects()[0].top,
left: element.getClientRects()[0].left
};
} else {
return {
top: 0,
left: 0
};
}
};
Grid.Utils.getOffsetAdv = function(elem)
{
if (!("getBoundingClientRect" in document.documentElement))
{
return { top: 0, left: 0 };
}
var boxModel = true;
var box = elem.getBoundingClientRect();
var doc = elem.ownerDocument;
var body = doc.body;
var docElem = doc.documentElement;
var clientTop = docElem.clientTop || body.clientTop || 0;
var clientLeft = docElem.clientLeft || body.clientLeft || 0;
var top = box.top + (self.pageYOffset || boxModel && docElem.scrollTop || body.scrollTop) - clientTop;
var left = box.left + (self.pageXOffset || boxModel && docElem.scrollLeft || body.scrollLeft) - clientLeft;
return { top: top, left: left };
};
Grid.Utils.fixOffset = function(svgObject)
{
var getElementFrame = function()
{
var doc;
try {
doc = element.ownerDocument;
} catch (ex) {
return null;
}
var win = doc.parentWindow || doc.defaultView;
return win.frameElement;
};
var element = svgObject;
var elements = [];
do
{
elements.push(element);
}
while (element = getElementFrame())
elements.reverse();
var top = 0, left = 0;
for (var i = 0; i < elements.length; i++)
{
var offset = Grid.Utils.getOffset(elements[i]);
if (offset) {
top += (Math.ceil(offset.top) - offset.top);
left += (Math.ceil(offset.left) - offset.left);
}
}
if (top > 0) {
YAHOO.util.Dom.setStyle(svgObject, 'margin-top', top + 'px');
}
if (left > 0) {
YAHOO.util.Dom.setStyle(svgObject, 'margin-left', left + 'px');
}
};
Grid.Utils.parseElementXY = function(el)
{
var getFloat = function(attrib)
{
var value = el.getAttribute(attrib);
return (value == null) ? 0 : parseFloat(value);
};
var data = {};
if (el.nodeName == 'circle')
{
data.x = getFloat('cx');
data.y = getFloat('cy');
data.radius = getFloat('r');
}
else if (el.nodeName == 'line')
{
data.x1 = getFloat('x1');
data.y1 = getFloat('y1');
data.x2 = getFloat('x2');
data.y2 = getFloat('y2');
}
else if (el.nodeName == 'image' || el.nodeName == 'rect')
{
data.x = getFloat('x');
data.y = getFloat('y');
data.width = getFloat('width');
data.height = getFloat('height');
}
else
{
data.x = getFloat('x');
data.y = getFloat('y');
}
data.thickness = getFloat('stroke-width');
return data;
};

// FILE: crtool.js (992a0fd2) 3/7/2014 11:24:07 AM

var crToolMouseDownPoint = {x: -1,y: -1};
var crToolMouseDragPoint = {x: -1,y: -1};
var crToolMouseUpPoint = {x: -1,y: -1};
var CRToolMode =
{
Test: 0,
Question: 1,
Dot: 2,
Rectangle: 3,
Circle: 4,
NoAction: 5,
Hotspots: 6
};
function CRTool(grid, mode)
{
this.grid = grid;
this._selectedBackgroundImage = null;
if (mode) this.mode = mode;
else this.mode = CRToolMode.Test;
this.resetCRToolData();
this.grid.showCoordinates = true;
};
CRTool.prototype.setMode = function(mode)
{
this.mode = mode;
this.resetCRToolData();
this.clearCRToolUI();
this.paletteAndSnapPointUIControl();
}
CRTool.prototype.getMode = function()
{
return this.mode;
}
CRTool.prototype.processBackgroundImage = function(evt)
{
if (evt.name == 'mousedown' && evt.target != null)
{
var entity = this.grid.model.getEntity(evt.target.id);
if (entity && entity.getType() == 'backgroundimage')
{
this.grid.canvas.setFocused(entity);
var id = this.grid.canvas._currentFocus.getID();
this._selectedBackgroundImage = this.grid.canvas._currentFocus;
return true;
}
else
{
this.grid.canvas.clearFocused();
return false;
}
}
else if (evt.name == 'drag')
{
if (this._selectedBackgroundImage)
{
var x = evt.currentPosition.x, y = evt.currentPosition.y;
this._selectedBackgroundImage.moveTo(x, y, true);
var id = this._selectedBackgroundImage.getID();
var entity = this._selectedBackgroundImage;
this.grid.view.moveImage(id, entity.x, entity.y, entity.width, entity.height, true);
return true;
}
}
else if (evt.name == 'dragend')
{
if (this._selectedBackgroundImage)
{
var id = this._selectedBackgroundImage.getID();
this.grid.view.deselectImage(id);
this._selectedBackgroundImage.x = this._selectedBackgroundImage.x - this._selectedBackgroundImage.width / 2;
this._selectedBackgroundImage.y = this._selectedBackgroundImage.y - this._selectedBackgroundImage.height;
this._selectedBackgroundImage = null;
return true;
}
}
return false;
};
CRTool.prototype.resetCRToolData = function()
{
crToolMouseUpPoint.x = -1;
crToolMouseUpPoint.y = -1;
crToolMouseDragPoint.x = -1;
crToolMouseDragPoint.y = -1;
crToolMouseDownPoint.x = -1;
crToolMouseDownPoint.y = -1;
}
CRTool.prototype.clearCRToolUI = function()
{
var crtoolShapes = ['crtool_rectangle', 'crtool_circle'];
for (var i=0; i<crtoolShapes.length; i++) removeChildren(crtoolShapes[i]);
}
function removeChildren(id) {
var crtoolNode = this.grid.view.getElementById(id);
var len = crtoolNode.childNodes.length;
var centerIDs = [];
for (var i=0; i<len; i++)
{
centerIDs.push(crtoolNode.childNodes[i].id);
}
for (var j=0; j<len; j++)
{
this.grid.view.removeElement(centerIDs[j]);
}
}
CRTool.prototype.paletteAndSnapPointUIControl = function()
{
if (this.getMode() == CRToolMode.Question) {
if (this.grid.model.options.paletteWidth > 0 &&
!this.grid.model.options.showPalette) this.grid.view.showPalette();
} else {
this.clearSnapPointsUI();
if (this.grid.model.options.showPalette) this.grid.view.showPalette();
else this.grid.view.hidePalette();
}
if (this.getMode() != CRToolMode.Test) this.showSnapPoints();
}
CRTool.prototype.setMouseDownPoint = function(x,y)
{
crToolMouseUpPoint.x = -1;
crToolMouseUpPoint.y = -1;
crToolMouseDragPoint.x = -1;
crToolMouseDragPoint.y = -1;
crToolMouseDownPoint.x = x;
crToolMouseDownPoint.y = y;
}
CRTool.prototype.setMouseDragPoint = function(x,y)
{
crToolMouseDragPoint.x = x;
crToolMouseDragPoint.y = y;
}
CRTool.prototype.setMouseUpPoint = function(x,y)
{
crToolMouseUpPoint.x = x;
crToolMouseUpPoint.y = y;
}
CRTool.prototype.getCRToolData = function(type)
{
if (type == 'mousedown') return crToolMouseDownPoint.x + ',' + crToolMouseDownPoint.y;
if (type == 'drag')      return crToolMouseDragPoint.x + ',' + crToolMouseDragPoint.y;
if (type == 'dragend')   return crToolMouseUpPoint.x + ',' + crToolMouseUpPoint.y;
return '-1,-1';
}
CRTool.prototype.setCRToolMouseLocation = function(evt)
{
var x = Math.round(evt.currentPosition.x),
y = Math.round(evt.currentPosition.y);
if (evt.name == 'mousedown')
{
this.setMouseDownPoint(x,y);
} else
if (evt.name == 'drag')
{
this.setMouseDragPoint(x,y);
} else
if (evt.name == 'mouseup' || evt.name == 'dragend')
{
this.setMouseUpPoint(x,y);
}
};
CRTool.prototype.updateCRToolUI = function(evt)
{
if (evt.name == 'mousemove') return;
if (this.mode == CRToolMode.Rectangle) {
if (this.dataReady('mousedown') && this.dataReady('mouseup')) {
this.drawCRToolRectangle(crToolMouseDownPoint.x, crToolMouseDownPoint.y, crToolMouseUpPoint.x, crToolMouseUpPoint.y);
} else {
if (this.dataReady('mousedown') && this.dataReady('drag')) {
this.drawCRToolRectangle(crToolMouseDownPoint.x, crToolMouseDownPoint.y,crToolMouseDragPoint.x, crToolMouseDragPoint.y);
}
}
} else
if (this.mode == CRToolMode.Circle) {
if (this.dataReady('mousedown') && this.dataReady('mouseup')) {
var r = Math.sqrt( Math.pow((crToolMouseDownPoint.x-crToolMouseUpPoint.x),2) + Math.pow((crToolMouseDownPoint.y-crToolMouseUpPoint.y),2));
this.drawCRToolCircle(crToolMouseDownPoint.x, crToolMouseDownPoint.y,r);
} else {
if (this.dataReady('mousedown') && this.dataReady('drag')) {
var r = Math.sqrt( Math.pow((crToolMouseDownPoint.x-crToolMouseDragPoint.x),2) + Math.pow((crToolMouseDownPoint.y-crToolMouseDragPoint.y),2));
this.drawCRToolCircle(crToolMouseDownPoint.x, crToolMouseDownPoint.y,r);
}
}
} else
if (this.mode == CRToolMode.Question) {
if (!this.getSnapToPointFlag()) return;
if (this.dataReady('mousedown') && this.dataReady('mouseup')) {
if ( (crToolMouseDownPoint.x == crToolMouseUpPoint.x) && (crToolMouseDownPoint.y == crToolMouseUpPoint.y) ) {
var snapPoint = this.grid.model.addSnapPoint(crToolMouseDownPoint.x, crToolMouseDownPoint.y, this.getSnapToPointRadius());
this.resetCRToolData();
this.showSnapPoints();
}
}
}
}
CRTool.prototype.showSnapPoints = function()
{
var snapPnts = this.grid.model.getSnapPoints();
this.clearSnapPointsUI();
if ((snapPnts) && (snapPnts.length > 0)) {
for (var i=0; i<snapPnts.length; i++) {
var id = snapPnts[i].getID();
this.grid.view.createSnapToPointAndCircle(snapPnts[i].x, snapPnts[i].y, this.getSnapToPointRadius(), id);
}
}
}
CRTool.prototype.clearSnapPointsUI = function()
{
removeChildren('crtool_snapcenter');
removeChildren('crtool_snapcircle');
}
CRTool.prototype.drawCRToolCircle = function(x,y,r)
{
this.clearCRToolUI();
this.grid.view.createCRToolCircle(x,y,r);
}
CRTool.prototype.drawCRToolRectangle = function(x1,y1,x2,y2)
{
this.clearCRToolUI();
this.grid.view.createCRToolRectangle(x1,y1,x2,y2);
}
CRTool.prototype.crToolDrawDot = function(x,y)
{
}
CRTool.prototype.getSnapToPointFlag = function()
{
return (document.getElementById('snapToPoint').checked);
}
CRTool.prototype.getSnapToPointRadius = function()
{
return (document.getElementById('snapPointRadius').value);
}
CRTool.prototype.deleteSnapPoint = function(evt)
{
var snapPoints = this.grid.model.getSnapPoints();
for (var i=0; i<snapPoints.length; i++) {
if (('snapPointCenter_snappoint_' + snapPoints[i]._id) == evt.target.id) {
this.grid.view.removeElement(evt.target.id);
this.grid.view.removeElement('snapPointCircle_snappoint_' + snapPoints[i]._id);
this.grid.model.deleteSnapPoint(snapPoints[i]);
this.showSnapPoints();
return true;
}
}
return false;
}
CRTool.prototype.dataReady = function (type)
{
if ((type == 'mousedown') && (crToolMouseDownPoint.x >=0) && (crToolMouseDownPoint.y >=0)) return true;
if ((type == 'drag') && (crToolMouseDragPoint.x >=0) && (crToolMouseDragPoint.y >=0)) return true;
if ((type == 'mouseup') && (crToolMouseUpPoint.x >=0) && (crToolMouseUpPoint.y >=0)) return true;
return false;
}
CRTool.prototype.listStaticGridImages = function()
{
function removePath(urlFile)
{
if (urlFile.indexOf('localhost') == -1)
{
var index = urlFile.lastIndexOf("/");
var file = '../NET/WebGraphicReview/'+ urlFile.substring(index + 1);
return file;
} else {
var pathname = window.location.pathname;
var index = pathname.lastIndexOf("/");
pathname = pathname.substring(0, index);
pathname = window.location.protocol + "//" + window.location.host + pathname;
index = urlFile.indexOf(pathname);
if (index != -1) return urlFile.substring(pathname.length+1);
else return urlFile;
}
}
var bkgImages = this.grid.model.getBackgroundImages();
var imageList = '';
for (var i=0; i<bkgImages.length; i++) {
imageList += translateImageLinkToDisplayName(removePath(bkgImages[i].url) + '|' +
bkgImages[i].x  + ',' + bkgImages[i].y);
if (i != bkgImages.length-1) imageList += ';';
}
return imageList;
}
CRTool.prototype.crToolGetGridPoint = function()
{
var CanvasHeight = this.grid.model.options.canvasHeight;
if ((crToolMouseDownPoint.x == -1) || (crToolMouseUpPoint.x == -1)) return '0,0';
if ((crToolMouseDownPoint.x == crToolMouseUpPoint.x) && (crToolMouseDownPoint.y == crToolMouseUpPoint.y))
return (crToolMouseDownPoint.x + ',' + (CanvasHeight - crToolMouseDownPoint.y));
return '0,0';
}
CRTool.prototype.crToolGetCenterAndTolerance = function()
{
var CanvasHeight = this.grid.model.options.canvasHeight;
if ((crToolMouseDownPoint.x != -1) && (crToolMouseUpPoint.x != -1))
{
var tol = Math.sqrt(Math.pow((crToolMouseDownPoint.x - crToolMouseUpPoint.x),2) + Math.pow((crToolMouseDownPoint.y - crToolMouseUpPoint.y),2));
tol = Math.round(tol);
return  (Math.round(crToolMouseDownPoint.x) + ',' + (CanvasHeight - Math.round(crToolMouseDownPoint.y)) + ',' + tol);
}
return '0,0,0';
}
CRTool.prototype.crToolGetArea = function()
{
var CanvasHeight = this.grid.model.options.canvasHeight;
if ((crToolMouseDownPoint.x != -1) && (crToolMouseUpPoint.x != -1))
{
var area = crToolMouseDownPoint.x + ',' + (CanvasHeight-crToolMouseDownPoint.y) + ',' + crToolMouseUpPoint.x + ',' + (CanvasHeight - crToolMouseUpPoint.y);
return area;
}
return '0,0,0,0';
}
CRTool.prototype.SetSnapToPointRadius = function(radius)
{
var snapPoints = this.grid.model.getSnapPoints();
for (var i = 0; i < snapPoints.length; i++)
{
snapPoints[i].snapRadius = radius;
}
}
CRTool.prototype.setCenterImage = function(onoff)
{
this.grid.view.paletteCenter = onoff;
this.grid.model.options.paletteCenter = onoff;
this.grid.view._updatePaletteLayout();
}
CRTool.prototype.setScaleImage = function(onoff)
{
this.grid.view.paletteScale = onoff;
this.grid.model.options.paletteScale = onoff;
this.grid.view._updatePaletteLayout();
}
var crToolCanvsComponent =
{
processMouseEvent: function(evt)
{
var crtool = getGridCRtoolObject();
if (crtool == null) return;
if (crtool.getMode() == CRToolMode.Question)
{
var btnMode = getGridObject().getMode();
if (btnMode == 'move')
{
if (crtool.getSnapToPointFlag())
{
crtool.setCRToolMouseLocation(evt);
crtool.updateCRToolUI(evt);
}
else
{
}
}
else if (btnMode == 'delete')
{
if (evt.name == 'mousedown') crtool.deleteSnapPoint(evt);
}
}
else
{
crtool.setCRToolMouseLocation(evt);
crtool.updateCRToolUI(evt);
}
}
}

// FILE: math.js (226d2130) 3/7/2014 11:24:07 AM

function Point2D(x,y){if(arguments.length>0){this.x=x;this.y=y;}}
Point2D.prototype.clone=function(){return new Point2D(this.x,this.y);};
Point2D.prototype.add=function(that){return new Point2D(this.x+that.x,this.y+that.y);};
Point2D.prototype.addEquals=function(that){this.x+=that.x;this.y+=that.y;return this;};
Point2D.prototype.offset=function(a,b){var result=0;if(!(b.x<=this.x||this.x+a.x<=0)){var t=b.x*a.y-a.x*b.y;var s;var d;if(t>0){if(this.x<0){s=this.x*a.y;d=s/a.x-this.y;}else if(this.x>0){s=this.x*b.y;d=s/b.x-this.y}else{d=-this.y;}}else{if(b.x<this.x+a.x){s=(b.x-this.x)*a.y;d=b.y-(this.y+s/a.x);}else if(b.x>this.x+a.x){s=(a.x+this.x)*b.y;d=s/b.x-(this.y+a.y);}else{d=b.y-(this.y+a.y);}}if(d>0){result=d;}}return result;};
Point2D.prototype.rmoveto=function(dx,dy){this.x+=dx;this.y+=dy;};
Point2D.prototype.scalarAdd=function(scalar){return new Point2D(this.x+scalar,this.y+scalar);};
Point2D.prototype.scalarAddEquals=function(scalar){this.x+=scalar;this.y+=scalar;return this;};
Point2D.prototype.subtract=function(that){return new Point2D(this.x-that.x,this.y-that.y);};
Point2D.prototype.subtractEquals=function(that){this.x-=that.x;this.y-=that.y;return this;};
Point2D.prototype.scalarSubtract=function(scalar){return new Point2D(this.x-scalar,this.y-scalar);};
Point2D.prototype.scalarSubtractEquals=function(scalar){this.x-=scalar;this.y-=scalar;return this;};
Point2D.prototype.multiply=function(scalar){return new Point2D(this.x*scalar,this.y*scalar);};
Point2D.prototype.multiplyEquals=function(scalar){this.x*=scalar;this.y*=scalar;return this;};
Point2D.prototype.divide=function(scalar){return new Point2D(this.x/scalar, this.y/scalar);};
Point2D.prototype.divideEquals=function(scalar){this.x/=scalar;this.y/=scalar;return this;};
Point2D.prototype.compare=function(that){return(this.x-that.x||this.y-that.y);};
Point2D.prototype.eq=function(that){return(this.x==that.x&&this.y==that.y);};
Point2D.prototype.lt=function(that){return(this.x<that.x&&this.y<that.y);};
Point2D.prototype.lte=function(that){return(this.x<=that.x&&this.y<=that.y);};
Point2D.prototype.gt=function(that){return(this.x>that.x&&this.y>that.y);};
Point2D.prototype.gte=function(that){return(this.x>=that.x&&this.y>=that.y);};
Point2D.prototype.distanceFrom=function(that){var dx=this.x-that.x;var dy=this.y-that.y;return Math.sqrt(dx*dx+dy*dy);};
Point2D.prototype.min=function(that){return new Point2D(Math.min(this.x,that.x),Math.min(this.y,that.y));};
Point2D.prototype.max=function(that){return new Point2D(Math.max(this.x,that.x),Math.max(this.y,that.y));};
Point2D.prototype.toString=function(){return this.x+","+this.y;};
Point2D.prototype.setXY=function(x,y){this.x=x;this.y=y;};
Point2D.prototype.setFromPoint=function(that){this.x=that.x;this.y=that.y;};
Point2D.prototype.swap=function(that){var x=this.x;var y=this.y;this.x=that.x;this.y=that.y;that.x=x;that.y=y;};
Point2D.prototype.lerp=function(that,t){return new Point2D(this.x+(that.x-this.x)*t,this.y+(that.y-this.y)*t);};
function Intersection(status){if(arguments.length>0){this.init(status);}}
Intersection.prototype.init=function(status){this.status=status;this.points=new Array();};
Intersection.prototype.appendPoint=function(point){this.points.push(point);};
Intersection.prototype.appendPoints=function(points){this.points=this.points.concat(points);};
Intersection.intersectCircleCircle=function(c1,r1,c2,r2){var result;var r_max=r1+r2;var r_min=Math.abs(r1-r2);var c_dist=c1.distanceFrom(c2);if(c_dist>r_max){result=new Intersection("Outside");}else if(c_dist<r_min){result=new Intersection("Inside");}else{result=new Intersection("Intersection");var a=(r1*r1-r2*r2+c_dist*c_dist)/(2*c_dist);var h=Math.sqrt(r1*r1-a*a);var p=c1.lerp(c2,a/c_dist);var b=h/c_dist;result.points.push(new Point2D(p.x-b*(c2.y-c1.y),p.y+b*(c2.x-c1.x)));result.points.push(new Point2D(p.x+b*(c2.y-c1.y),p.y-b*(c2.x-c1.x)));}return result;};
Intersection.intersectCircleLine=function(c,r,a1,a2){var result;var a=(a2.x-a1.x)*(a2.x-a1.x)+(a2.y-a1.y)*(a2.y-a1.y);var b=2*((a2.x-a1.x)*(a1.x-c.x)+(a2.y-a1.y)*(a1.y-c.y));var cc=c.x*c.x+c.y*c.y+a1.x*a1.x+a1.y*a1.y-2*(c.x*a1.x+c.y*a1.y)-r*r;var deter=b*b-4*a*cc;if(deter<0){result=new Intersection("Outside");}else if(deter==0){result=new Intersection("Tangent");}else{var e=Math.sqrt(deter);var u1=(-b+e)/(2*a);var u2=(-b-e)/(2*a);if((u1<0||u1>1)&&(u2<0||u2>1)){if((u1<0&&u2<0)||(u1>1&&u2>1)){result=new Intersection("Outside");}else{result=new Intersection("Inside");}}else{result=new Intersection("Intersection");if(0<=u1&&u1<=1)result.points.push(a1.lerp(a2,u1));if(0<=u2&&u2<=1)result.points.push(a1.lerp(a2,u2));}}return result;};
Intersection.intersectLineLine=function(a1,a2,b1,b2){var result;var ua_t=(b2.x-b1.x)*(a1.y-b1.y)-(b2.y-b1.y)*(a1.x-b1.x);var ub_t=(a2.x-a1.x)*(a1.y-b1.y)-(a2.y-a1.y)*(a1.x-b1.x);var u_b=(b2.y-b1.y)*(a2.x-a1.x)-(b2.x-b1.x)*(a2.y-a1.y);if(u_b!=0){var ua=ua_t/u_b;var ub=ub_t/u_b;if(0<=ua&&ua<=1&&0<=ub&&ub<=1){result=new Intersection("Intersection");result.points.push(new Point2D(a1.x+ua*(a2.x-a1.x),a1.y+ua*(a2.y-a1.y)));}else{result=new Intersection("No Intersection");}}else{if(ua_t==0||ub_t==0){result=new Intersection("Coincident");}else{result=new Intersection("Parallel");}}return result;};
Intersection.intersectRectangleRectangle=function(a1,a2,b1,b2){var min=a1.min(a2);var max=a1.max(a2);var topRight=new Point2D(max.x,min.y);var bottomLeft=new Point2D(min.x,max.y);var inter1=Intersection.intersectLineRectangle(min,topRight,b1,b2);var inter2=Intersection.intersectLineRectangle(topRight,max,b1,b2);var inter3=Intersection.intersectLineRectangle(max,bottomLeft,b1,b2);var inter4=Intersection.intersectLineRectangle(bottomLeft,min,b1,b2);var result=new Intersection("No Intersection");result.appendPoints(inter1.points);result.appendPoints(inter2.points);result.appendPoints(inter3.points);result.appendPoints(inter4.points);if(result.points.length>0)result.status="Intersection";return result;};
Intersection.intersectCircleRectangle = function(c, r, r1, r2) { var min = r1.min(r2); var max = r1.max(r2); var topRight = new Point2D(max.x, min.y); var bottomLeft = new Point2D(min.x, max.y); var inter1 = Intersection.intersectCircleLine(c, r, min, topRight); var inter2 = Intersection.intersectCircleLine(c, r, topRight, max); var inter3 = Intersection.intersectCircleLine(c, r, max, bottomLeft); var inter4 = Intersection.intersectCircleLine(c, r, bottomLeft, min); var result = new Intersection("No Intersection"); result.appendPoints(inter1.points); result.appendPoints(inter2.points); result.appendPoints(inter3.points); result.appendPoints(inter4.points); if (result.points.length > 0) result.status = "Intersection"; else result.status = inter1.status; return result; };
Intersection.intersectLineRectangle = function(a1, a2, r1, r2) { var min = r1.min(r2); var max = r1.max(r2); var topRight = new Point2D(max.x, min.y); var bottomLeft = new Point2D(min.x, max.y); var inter1 = Intersection.intersectLineLine(min, topRight, a1, a2); var inter2 = Intersection.intersectLineLine(topRight, max, a1, a2); var inter3 = Intersection.intersectLineLine(max, bottomLeft, a1, a2); var inter4 = Intersection.intersectLineLine(bottomLeft, min, a1, a2); var result = new Intersection("No Intersection"); result.appendPoints(inter1.points); result.appendPoints(inter2.points); result.appendPoints(inter3.points); result.appendPoints(inter4.points); if (result.points.length > 0) result.status = "Intersection"; return result; };

// FILE: model.js (546da46e) 3/7/2014 11:24:06 AM

Grid.Model = function(id, options)
{
this.id = id || '';
this.options = options || new Grid.Model.Options();
this._uuid = 0;
this.questionPartID = 1;
this.description = '';
this.defaultRadius = 5;
this._collection = [];
this._cache = {};
this._addCache = function(id, obj) { this._cache[id] = obj; };
this._removeCache = function(id) { this._cache[id] = null; };
this._points = [];
this._snappoints = [];
this._lines = [];
this._paletteimages = [];
this._canvasimages = [];
this._staticimages = [];
this._backgroundimages = [];
this._labels = [];
this._rectangles = [];
this._circles = [];
this._regions = [];
this._regionGroups = [];
this.importing = false;
this._listenForCacheEvents();
this._instance = ++Grid.Model._instances;
};
YAHOO.lang.augmentProto(Grid.Model, EventLazyProvider);
Grid.Model.arrayRemoveAt = function(arr, i)
{
return (Array.prototype.splice.call(arr, i, 1).length == 1);
};
Grid.Model.arrayRemove = function(arr, obj)
{
var i = arr.indexOf(obj);
var rv;
if ((rv = i >= 0))
{
Grid.Model.arrayRemoveAt(arr, i);
}
return rv;
};
Grid.Model._instances = 0;
Grid.Model.getEmptyStyles = function()
{
return {
'fill': 'white',
'fill-opacity': '0',
'stroke': 'white',
'stroke-width': '0',
'stroke-opacity': '',
'stroke-dasharray': ''
};
};
Grid.Model.getDefaultStyles = function()
{
return {
'fill': 'white',
'fill-opacity': '0',
'stroke': 'red',
'stroke-width': '1',
'stroke-opacity': '',
'stroke-dasharray': ''
};
};
Grid.Model.prototype._createUUID = function()
{
var t = new Date().getTime();
var r = Math.random().toString().split('.')[1] * 1;
++this._uuid;
return this._uuid;
};
Grid.Model.prototype._listenForCacheEvents = function()
{
var model = this;
this.subscribe('onAdd', function(entity)
{
var id = entity.getID();
model._cache[id] = entity;
model._collection.push(entity);
});
this.subscribe('onDelete', function(entity)
{
var id = entity.getID();
delete model._cache[id];
Grid.Model.arrayRemove(model._collection, entity);
});
};
Grid.Model.prototype._hasString = function(id) { return (Lang.isString(id) && id.length > 0); };
Grid.Model.prototype.deleteEntity = function(entityToDelete)
{
var type = entityToDelete.getType();
var collectionName = '_' + type + 's';
var collection = this[collectionName];
if (collection != null)
{
Grid.Model.arrayRemove(this[collectionName], entityToDelete);
}
this.fireLazy('onDelete', entityToDelete);
};
Grid.Model.prototype.clearResponse = function()
{
while (this._snappoints.length > 0) this.deleteSnapPoint(this._snappoints[0]);
while (this._points.length > 0) this.deletePoint(this._points[0]);
while (this._canvasimages.length > 0) this.deleteImage(this._canvasimages[0]);
while (this._circles.length > 0) this.deleteCircle(this._circles[0]);
for (var i = 0; i < this._regions.length; i++)
{
var region = this._regions[i];
if (region.isSelected()) region.deselect();
}
};
Grid.Model.prototype.clearQuestion = function()
{
this.clearResponse();
while (this._snappoints.length > 0) this.deleteSnapPoint(this._snappoints[0]);
while (this._paletteimages.length > 0) this.deletePaletteImage(this._paletteimages[0]);
while (this._backgroundimages.length > 0) this.deleteBackgroundImage(this._backgroundimages[0]);
while (this._staticimages.length > 0) this.deleteStaticImage(this._staticimages[0]);
while (this._regionGroups.length > 0) this.deleteRegionGroup(this._regionGroups[0], true);
this.options = new Grid.Model.Options();
};
Grid.Model.prototype.getEntity = function(id)
{
if (id == null || id == '') return null;
return this._cache[id] || null;
};
Grid.Model.prototype.getEntities = function() { return this._collection; };
Grid.Model.prototype.addEntity = function(entity)
{
this.fireLazy('onAdd', entity);
};
Grid.Model.prototype.addPoint = function(x, y)
{
var radius = (arguments[2] > 0) ? arguments[2] : this.defaultRadius;
var point = new Grid.Model.Point(this, x, y, radius);
this._points.push(point);
this.fireLazy('onAdd', point);
return point;
};
Grid.Model.prototype.getPoints = function() { return this._points; };
Grid.Model.prototype.deletePoint = function(point)
{
for (var i = 0; i < this._points.length; i++)
{
if (point != this._points[i]) continue;
var pointLines = point.getLines();
for (var j = 0; j < pointLines.length; j++)
{
var line = pointLines[j];
this.deleteLine(line);
}
Grid.Model.arrayRemoveAt(this._points, i);
this.fireLazy('onDelete', point);
return true;
}
return false;
};
Grid.Model.prototype.getLines = function() { return this._lines; };
Grid.Model.prototype.addLine = function(source, target, dirType, style)
{
if (!source || !target) throw new Error('Invalid source or target point');
if (source == target) return null;
for(var i = 0; i < this._lines.length; i++)
{
var existingLine = this._lines[i];
if (source == existingLine.source && target == existingLine.target) return existingLine;
if (target == existingLine.source && source == existingLine.target) return existingLine;
}
var line = new Grid.Model.Line(this, source, target, dirType, style, this.options.properLineGeometry);
this._lines.push(line);
this.fireLazy('onAdd', line);
return line;
};
Grid.Model.prototype.getLinesByDir = function(dirType)
{
var lineDirections = [];
for (var i = 0; i < this._lines.length; i++)
{
var line = this._lines[i];
if (line.dirType == dirType) lineDirections.push(line);
}
return lineDirections;
};
Grid.Model.prototype.deleteLine = function(line)
{
return this.deleteEntity(line);
};
Grid.Model.prototype.getSnapPoints = function() { return this._snappoints; };
Grid.Model.prototype.addSnapPoint = function(x, y, snapRadius)
{
var snapPoint = new Grid.Model.SnapPoint(this, x, y, this.defaultRadius, snapRadius);
this._snappoints.push(snapPoint);
this.fireLazy('onAdd', snapPoint);
return snapPoint;
};
Grid.Model.prototype.deleteSnapPoint = function(snapPoint)
{
return this.deleteEntity(snapPoint);
};
Grid.Model.prototype.getPaletteImages = function() { return this._paletteimages; };
Grid.Model.prototype.addPaletteImage = function(name              , url                 , width, height)
{
var paletteImage = new Grid.Model.PaletteImage(this, name, url, width, height);
this._paletteimages.push(paletteImage);
this.fireLazy('onAdd', paletteImage);
return paletteImage;
};
Grid.Model.prototype.deletePaletteImage = function(paletteImage)
{
var canvasImages = paletteImage.getImages();
this.deleteEntity(paletteImage);
for (var i = 0; i < canvasImages.length; i++)
{
this.deleteEntity(canvasImages[0]);
}
};
Grid.Model.prototype.getImages = function() { return this._canvasimages; };
Grid.Model.prototype.addImage = function(name, x, y)
{
if (!Lang.isString(name) || name.length == 0) return null;
var paletteImage = null;
for (var i = 0; i < this._paletteimages.length; i++)
{
if (name == this._paletteimages[i].name)
{
paletteImage = this._paletteimages[i];
break;
}
}
if (paletteImage == null) throw new Error('Cannot add the image ' + name + ' because the palette image does not exist.');
var image = new Grid.Model.Image(this, name, x, y, paletteImage.width, paletteImage.height);
this._canvasimages.push(image);
this.fireLazy('onAdd', image);
return image;
};
Grid.Model.prototype.deleteImage = function(image)
{
return this.deleteEntity(image);
};
Grid.Model.prototype.getStaticImages = function() { return this._staticimages; };
Grid.Model.prototype.addStaticImage = function(url                 , x, y, width, height)
{
var staticImage = new Grid.Model.StaticImage(this, url, x, y, width, height);
this._staticimages.push(staticImage);
this.fireLazy('onAdd', staticImage);
return staticImage;
};
Grid.Model.prototype.deleteStaticImage = function(staticImage)
{
return this.deleteEntity(staticImage);
};
Grid.Model.prototype.getBackgroundImages = function() { return this._backgroundimages; };
Grid.Model.prototype.addBackgroundImage = function(url                 , x, y, width, height)
{
var backgroundImage = new Grid.Model.BackgroundImage(this, url, x, y, width, height);
this._backgroundimages.push(backgroundImage);
this.fireLazy('onAdd', backgroundImage);
return backgroundImage;
};
Grid.Model.prototype.deleteBackgroundImage = function(backgroundImage)
{
return this.deleteEntity(backgroundImage);
};
Grid.Model.prototype.getRectangles = function() { return this._rectangles; };
Grid.Model.prototype.createRectangle = function(x1, y1, x2, y2)
{
var width = (x2 - x1);
var height = (y2 - y1);
return new Grid.Model.Rectangle(this, x1, y1, width, height);
};
Grid.Model.prototype.addRectangle = function(rect)
{
if (!(rect instanceof Grid.Model.Rectangle)) throw new Error('Can only add valid rectangle objects.');
this._rectangles.push(rect);
this.fireLazy('onAdd', rect);
return rect;
};
Grid.Model.prototype.getCircles = function() { return this._circles; };
Grid.Model.prototype.createCircle = function(x, y, radius)
{
return new Grid.Model.Circle(this, x, y, radius);
};
Grid.Model.prototype.addCircle = function(circle)
{
if (!(circle instanceof Grid.Model.Circle)) throw new Error('Can only add valid circle objects.');
this._circles.push(circle);
this.fireLazy('onAdd', circle);
return circle;
};
Grid.Model.prototype.deleteCircle = function (circle)
{
return this.deleteEntity(circle);
};
Grid.Model.prototype.getLabels = function() { return this._labels; };
Grid.Model.prototype.addLabel = function(x, y, text, fontSize, fontFamily)
{
var label = new Grid.Model.Label(this, x, y, text, fontSize, fontFamily);
this._labels.push(label);
this.fireLazy('onAdd', label);
return label;
};
Grid.Model.prototype.getRegionGroups = function() { return this._regionGroups; };
Grid.Model.prototype.getRegionGroup = function(name)
{
var regionGroups = grid.model.getRegionGroups();
for (var i = 0; i < regionGroups.length; i++)
{
var group = regionGroups[i];
if (group.name == name) return group;
}
return null;
};
Grid.Model.prototype.createRegionGroup = function(name, min, max)
{
var regionGroup = new Grid.Model.RegionGroup(this, name, min, max);
this._regionGroups.push(regionGroup);
return regionGroup;
};
Grid.Model.prototype.deleteRegionGroup = function(group, deleteOrphans)
{
var regions = group.getRegions();
while (regions.length > 0)
{
group.removeRegion(regions[0], deleteOrphans);
}
Grid.Model.arrayRemove(this._regionGroups, group);
};
Grid.Model.prototype.createRegion = function(name           , shape           , coords           )
{
var region = null;
switch (shape)
{
case 'rect': region = this._buildRegionRect(name); break;
case 'circle': region = this._buildRegionCircle(name); break;
case 'poly': region = this._buildRegionPolygon(name); break;
}
if (region != null)
{
region.setHoverable(true);
region.setFocusable(Grid.Model.Focusable.Auto);
region.setSelectable(true);
region.setMoveable(false);
this.addEntity(region);
this._regions.push(region);
if (YAHOO.lang.isString(coords))
{
region.setCoords(coords);
}
}
return region;
};
Grid.Model.prototype._buildRegionRect = function(name)
{
var regionClass = Grid.Model.buildRegion(Grid.Model.Rectangle, name);
return new regionClass(this, 0, 0, 0, 0);
};
Grid.Model.prototype._buildRegionCircle = function(name)
{
var regionClass = Grid.Model.buildRegion(Grid.Model.Circle, name);
return new regionClass(this, 0, 0, 0);
};
Grid.Model.prototype._buildRegionPolygon = function(name)
{
var regionClass = Grid.Model.buildRegion(Grid.Model.Polygon, name);
return new regionClass(this);
};
Grid.Model.prototype.deleteRegion = function(region)
{
var events = region.getEvents();
for (var i = 0; i < events.length; i++)
{
var event = events[i];
region.deleteEvent(event);
}
Grid.Model.arrayRemove(this._regions, region);
this.deleteEntity(region);
};
Grid.Model.prototype.getRegions = function() { return this._regions; };
Grid.Model.prototype.getRegion = function(name)
{
for (var i = 0; i < this._regions.length; i++)
{
var region = this._regions[i];
if (region.name == name) return region;
}
return null;
};
Grid.Model.prototype.getRegionsImages = function()
{
var regionImages = [];
var regions = this.getRegions();
for (var i = 0; i < regions.length; i++)
{
var regionEvents = regions[i].getEvents();
for (var j = 0; j < regionEvents.length; j++)
{
var eventImage = regionEvents[j].getImage();
if (eventImage != null) regionImages.push(eventImage);
}
}
return regionImages;
};

// FILE: model.options.js (103f2380) 3/7/2014 11:24:06 AM

Grid.Model.Options = function()
{
this.updateLayout = true;
this.containerPaddingTop = 0;
this.containerPaddingRight = 1;
this.containerPaddingBottom = 1;
this.containerPaddingLeft = 0;
this.showPalette = false;
this.paletteWidth = 75;
this.paletteGutter = 5;
this.paletteCenter = false;
this.paletteScale = false;
this.showToolbar = true;
this.toolbarHeight = 21;
this.toolbarGutter = 4;
this.showButtons = [];
this.canvasWidth = 500;
this.canvasWidthExt = 2;
this.canvasHeight = 410;
this.canvasHeightExt = 1;
this.canvasBorderOffset = -1;
this.properLineGeometry = false;
this.showGridLines = false;
this.gridColor = 'None';
this.gridSpacing = 0;
this.snapToGrid = false;
this.snapRadius = 0;
this.selectionTolerance = 0;
this.showFeedback = true;
this.feedbackHeight = 30;
this.feedbackGutter = 4;
};
Grid.Model.Options.prototype.addButton = function(button)
{
if (button == 'delete' ||
button == 'point' ||
button == 'connect' ||
button == 'arrow' ||
button == 'arrw2' ||
button == 'dash' ||
button == 'circle') {
this.showButtons.push(button);
}
};
Grid.Model.Options.prototype.clearButtons = function() {
this.showButtons = [];
};

// FILE: model.base.js (b3d6fadd) 3/7/2014 11:24:06 AM

Grid.Model.Base = function(model)
{
if (!(model instanceof Grid.Model))
{
throw new Error('The base class does not have a valid model.');
}
this.model = model;
this._id = model._instance + '_' + model._createUUID();
this._visible = true;
this._hoverable = false;
this._hovering = false;
this._focusable = Grid.Model.Focusable.Never;
this._focused = false;
this._moveable = false;
this._deletable = false;
this._selectable = false;
this._selected = false;
};
Grid.Model.Focusable =
{
Never: 0,
Manual: 1,
Auto: 2
};
Grid.Model.Base.prototype.getType = function()
{
if (this instanceof Grid.Model.BackgroundImage) return 'backgroundimage';
if (this instanceof Grid.Model.StaticImage) return 'staticimage';
if (this instanceof Grid.Model.PaletteImage) return 'paletteimage';
if (this instanceof Grid.Model.Image) return 'canvasimage';
if (this instanceof Grid.Model.Line) return 'line';
if (this instanceof Grid.Model.SnapPoint) return 'snappoint';
if (this instanceof Grid.Model.Point) return 'point';
if (this instanceof Grid.Model.Circle) return 'circle';
if (this instanceof Grid.Model.Rectangle) return 'rect';
if (this instanceof Grid.Model.Polygon) return 'poly';
if (this instanceof Grid.Model.Path) return 'path';
if (this instanceof Grid.Model.Base) return 'base';
return 'unknown';
};
Grid.Model.Base.prototype.getID = function()
{
return this.getType() + '_' + this._id;
};
Grid.Model.Base.prototype.setVisible = function(visible) { this._visible = visible; };
Grid.Model.Base.prototype.isVisible = function() { return this._visible; };
Grid.Model.Base.prototype.show = function()
{
this.setVisible(true);
this.update();
};
Grid.Model.Base.prototype.hide = function()
{
this.setVisible(false);
this.update();
};
Grid.Model.Base.prototype.setHoverable = function(hoverable) { this._hoverable = hoverable; };
Grid.Model.Base.prototype.isHoverable = function()
{
return this.isVisible() ? this._hoverable : false;
};
Grid.Model.Base.prototype.setHovering = function(hovering) { this._hovering = hovering; };
Grid.Model.Base.prototype.isHovering = function() { return this._hovering; };
Grid.Model.Base.prototype.setFocusable = function(focusable) { this._focusable = focusable; };
Grid.Model.Base.prototype.isFocusable = function()
{
return this.isVisible() ? this._focusable : false;
};
Grid.Model.Base.prototype.setFocused = function(focused) { this._focused = focused; };
Grid.Model.Base.prototype.isFocused = function() { return this._focused; };
Grid.Model.Base.prototype.setSelectable = function(selectable) { this._selectable = selectable; };
Grid.Model.Base.prototype.isSelectable = function() { return this._selectable; };
Grid.Model.Base.prototype.isSelected = function() { return this._selected; };
Grid.Model.Base.prototype.select = function()
{
if (this.isSelected()) return false;
if (!this.isSelectable()) return false;
this._selected = true;
this.update();
return true;
};
Grid.Model.Base.prototype.deselect = function()
{
if (!this.isSelected()) return false;
this._selected = false;
this.update();
return true;
};
Grid.Model.Base.prototype.setMoveable = function(moveable) { this._moveable = moveable; };
Grid.Model.Base.prototype.isMoveable = function() { return this._moveable; };
Grid.Model.Base.prototype.setDeletable = function(deletable) { this._deletable = deletable; };
Grid.Model.Base.prototype.isDeletable = function() { return this._deletable; };
Grid.Model.Base.prototype.update = function()
{
this.model.fireLazy('onUpdate', this);
};
Grid.Model.Base.prototype.setCoords = function() {};
Grid.Model.Base.prototype.getStyles = function()
{
return Grid.Model.getDefaultStyles();
};
Grid.Model.Base.prototype.getElement = function(view)
{
var id = this.getID();
return view.getElementById(id);
};
Grid.Model.Base.prototype.createElement = function(view) { return null; };
Grid.Model.Base.prototype.getElementGroup = function() { return 'shapes'; };
Grid.Model.Base.prototype.appendElement = function(view, element)
{
var groupId = this.getElementGroup();
view.appendChild(groupId, element);
};
Grid.Model.Base.prototype.moveElement = function(view) {};
Grid.Model.Base.prototype.removeElement = function(view)
{
var id = this.getID();
view.removeElement(id);
};
Grid.Model.Base.prototype.updateElement = function(view)
{
var element = this.getElement(view);
if (element == null) return;
var styles = this.getStyles();
view.setAttributes(element, styles);
var visible = this.isVisible();
view.setAttributes(element,
{
'display': visible ? 'inline' : 'none'
});
};

// FILE: model.position.js (73916789) 3/7/2014 11:24:06 AM

Grid.Model.Position = function(model, x, y)
{
Grid.Model.Position.superclass.constructor.call(this, model);
this.x = x;
this.y = y;
this._boundsEnabled = true;
this._snapEnabled = true;
};
Lang.extend(Grid.Model.Position, Grid.Model.Base);
Grid.Model.Position.prototype.get2D = function() { return new Point2D(this.x, this.y); };
Grid.Model.Position.prototype.isBoundsEnabled = function() { return this._boundsEnabled; };
Grid.Model.Position.prototype.setBoundsEnabled = function(boundsEnabled) { this._boundsEnabled = boundsEnabled; };
Grid.Model.Position.prototype.isSnapEnabled = function() { return this._snapEnabled; };
Grid.Model.Position.prototype.setSnapEnabled = function(snapEnabled) { this._snapEnabled = snapEnabled; };
Grid.Model.Position.prototype.getFixedCoords = function(x, y)
{
return { x: x, y: y };
};
Grid.Model.Position.prototype.moveTo = function(moveX, moveY, preventSnap             )
{
if (this.isBoundsEnabled())
{
var fixedCoords = this.getFixedCoords(moveX, moveY);
moveX = fixedCoords.x;
moveY = fixedCoords.y;
}
if (moveX == this.x && moveY == this.y) return false;
this.x = moveX;
this.y = moveY;
if (this.isSnapEnabled() && !preventSnap) this.snapToGrid();
this.model.fireLazy('onMove', this);
return true;
};
Grid.Model.Position.prototype._moveBy = function(moveSize)
{
var options = this.model.options;
if (options.snapToGrid && options.gridSpacing > 0)
{
return options.gridSpacing;
}
return moveSize;
};
Grid.Model.Position.prototype.moveLeft = function(moveSize)
{
return this.moveTo(this.x - this._moveBy(moveSize), this.y);
};
Grid.Model.Position.prototype.moveUp = function(moveSize)
{
return this.moveTo(this.x, this.y - this._moveBy(moveSize));
};
Grid.Model.Position.prototype.moveRight = function(moveSize)
{
return this.moveTo(this.x + this._moveBy(moveSize), this.y);
};
Grid.Model.Position.prototype.moveDown = function(moveSize)
{
return this.moveTo(this.x, this.y + this._moveBy(moveSize));
};
Grid.Model.Position.prototype.distanceFrom = function(that)
{
var p1 = this.get2D(),
p2 = that.get2D();
return p1.distanceFrom(p2);
};
Grid.Model.Position.prototype._getNearestSnapPoint = function()
{
var snapPoints = this.model.getSnapPoints();
var closestSnapPoint = null;
var closestDistance = +Infinity;
for(var i = 0; i < snapPoints.length; i++)
{
var snapPoint = snapPoints[i];
var distance = this.distanceFrom(snapPoint);
if (distance <= snapPoint.snapRadius && distance < closestDistance)
{
closestDistance = distance;
closestSnapPoint = snapPoint;
}
}
return closestSnapPoint;
};
Grid.Model.Position.prototype.snapToPoint = function()
{
var snapPoint = this._getNearestSnapPoint();
if (snapPoint != null)
{
return this.moveTo(snapPoint.x, snapPoint.y, true);
}
return false;
};
Grid.Model.Position.prototype.snapToGrid = function()
{
var spacing = 1;
var options = this.model.options;
if (options.snapToGrid && options.gridSpacing > 0)
{
spacing = options.gridSpacing;
}
var fixedX = this.x;
var fixedY = this.y;
if (this instanceof Grid.Model.Image)
{
fixedX = (fixedX - Math.round(this.width / 2)); // NOTE: JAVA floored this value
fixedY = (fixedY - this.height);
}
var snappedX = Math.round(fixedX / spacing) * spacing;
var snappedY = Math.round(fixedY / spacing) * spacing;
if (this instanceof Grid.Model.Image)
{
snappedX = (snappedX + Math.round(this.width / 2)); // NOTE: JAVA floored this value
snappedY = (snappedY + this.height);
}
return this.moveTo(snappedX, snappedY, true);
};
Grid.Model.Position.prototype.snap = function () {
if (!this.snapToPoint()) {
this.snapToGrid();
}
};
Grid.Model.Position.prototype.moveElement = function(view)
{
var element = this.getElement(view);
view.setAttributes(element,
{
'x': this.x,
'y': this.y
});
};

// FILE: model.circle.js (5a88952c) 3/7/2014 11:24:06 AM

Grid.Model.Circle = function(model, x, y, radius)
{
Grid.Model.Circle.superclass.constructor.call(this, model, x, y);
this.radius = radius;
this.setHoverable(false);
this.setFocusable(Grid.Model.Focusable.Manual);
this.setMoveable(true);
this.setSelectable(false);
};
Lang.extend(Grid.Model.Circle, Grid.Model.Position);
Grid.Model.Circle.prototype.getList = function()
{
return this.model.getPoints();
};
Grid.Model.Circle.prototype.getBoundingRect = function(x, y)
{
if (!YAHOO.lang.isNumber(x)) x = this.x;
if (!YAHOO.lang.isNumber(y)) y = this.y;
var width = (this.radius * 2);
var height = (this.radius * 2);
var topLeftX = (x - this.radius);
var topLeftY = (y - this.radius);
var bottomRightX = (topLeftX + width);
var bottomRightY = (topLeftY + height);
return {
width: width,
height: height,
left: topLeftX,
top: topLeftY,
right: bottomRightX,
bottom: bottomRightY
};
};
Grid.Model.Circle.prototype.getFixedCoords = function(moveX, moveY)
{
var rect = this.getBoundingRect(moveX, moveY);
var canvasWidth = this.model.options.canvasWidth;
var canvasHeight = this.model.options.canvasHeight;
if (rect.left < 0) moveX = this.radius;
if (rect.top < 0) moveY = this.radius;
if (rect.right > canvasWidth) moveX = (canvasWidth - this.radius);
if (rect.bottom > canvasHeight) moveY = (canvasHeight - this.radius);
return { x: moveX, y: moveY };
};
Grid.Model.Circle.prototype.intersect = function(that)
{
var c1 = this.get2D(),
r1 = this.radius,
c2 = that.get2D(),
r2 = that.radius;
return (Intersection.intersectCircleCircle(c1, r1, c2, r2).status != 'Outside');
};
Grid.Model.Circle.prototype.getIntersections = function()
{
var intersectingPoints = [];
var points = this.getList();
for(var i = 0; i < points.length; i++)
{
var point = points[i];
if (this != point && this.intersect(point))
{
intersectingPoints.push(point);
}
}
return intersectingPoints;
};
Grid.Model.Circle.prototype.setCoords = function(coords)
{
coords = coords.split(',');
for (var i = 0; i < coords.length; i++) { coords[i] = (coords[i] * 1); }
this.x = coords[0];
this.y = coords[1];
this.radius = coords[2];
this.update();
};
Grid.Model.Circle.prototype.getCoords = function()
{
return YAHOO.lang.substitute('{x}, {y}, {radius}', this);
};
Grid.Model.Circle.prototype.createElement = function(view)
{
var id = this.getID();
var circleElement = view.createElement('circle', { 'id': id });
this.appendElement(view, circleElement);
return circleElement;
};
Grid.Model.Circle.prototype.updateElement = function(view)
{
var circleElement = this.getElement(view);
view.setAttributes(circleElement, {
'cx': this.x,
'cy': this.y,
'r':  (this.radius - 0.4)
});
Grid.Model.Circle.superclass.updateElement.call(this, view);
};
Grid.Model.Circle.prototype.moveElement = function(view)
{
var circleElement = this.getElement(view);
view.setAttributes(circleElement, {
'cx': this.x,
'cy': this.y
});
};

// FILE: model.polygon.js (9a90a7ae) 3/7/2014 11:24:06 AM

Grid.Model.PolygonPoint = function(model, x, y)
{
Grid.Model.PolygonPoint.superclass.constructor.call(this, model, x, y);
};
Lang.extend(Grid.Model.PolygonPoint, Grid.Model.Position);
Grid.Model.PolygonPoint.prototype.toString = function()
{
return this.x + ',' + this.y;
};
Grid.Model.Polygon = function(model)
{
Grid.Model.Polygon.superclass.constructor.call(this, model, 0, 0);
this._points = [];
this._focusable = Grid.Model.Focusable.Manual;
this._moveable = true;
};
Lang.extend(Grid.Model.Polygon, Grid.Model.Position);
Grid.Model.Polygon.prototype.getPoints = function() { return this._points; };
Grid.Model.Polygon.prototype.addPoint = function(x, y)
{
var point = new Grid.Model.PolygonPoint(this.model, x, y);
this._points.push(point);
};
Grid.Model.Polygon.prototype.getCoords = function()
{
return this._points.join(' ');
};
Grid.Model.Polygon._path_regexp = (function()
{
var number = '-?[0-9.]+';
var comma = '\s*[, \t]\s*';
var xy = number + comma + number;
return new RegExp(xy, 'ig');
})();
Grid.Model.Polygon._parsePath = function(path)
{
var points = [];
var tokens = path.match(Grid.Model.Polygon._path_regexp);
if (YAHOO.lang.isArray(tokens))
{
for (var i = 0; i < tokens.length; i++)
{
var token = tokens[i].replace(/^\s+|\s+$/g, '');
var xy = token.split(/[, \t]+/);
var x = parseFloat(xy[0]);
var y = parseFloat(xy[1]);
points.push([x, y]);
}
}
return points;
};
Grid.Model.Polygon.prototype.setCoords = function(coords)
{
this._points = [];
var parsedPoints = Grid.Model.Polygon._parsePath(coords);
for (var i = 0; i < parsedPoints.length; i++)
{
var parsedPoint = parsedPoints[i];
this.addPoint(parsedPoint[0], parsedPoint[1]);
}
if (this._points.length > 0)
{
this.x = parsedPoints[0][0];
this.y = parsedPoints[0][1];
}
this.update();
};
Grid.Model.Polygon.prototype.createElement = function(view)
{
var id = this.getID();
var polyElement = view.createElement('polygon', {
'id': id,
'points': this._points.join(' ')
});
this.appendElement(view, polyElement);
return polyElement;
};
Grid.Model.Polygon.prototype.moveElement = function(view)
{
var polyElement = this.getElement(view);
var xDiff = 0;
var yDiff = 0;
for (var i = 0; i < this._points.length; i++)
{
var point = this._points[i];
if (i == 0)
{
xDiff = this.x - point.x;
yDiff = this.y - point.y;
point.x = this.x;
point.y = this.y;
}
else
{
point.x += xDiff;
point.y += yDiff ;
}
}
view.setAttributes(polyElement, {
'points': this._points.join(' ')
});
};
Grid.Model.Polygon.prototype.updateElement = function(view)
{
this.moveElement(view);
Grid.Model.Polygon.superclass.updateElement.call(this, view);
};

// FILE: model.path.js (f9610d5b) 3/7/2014 11:24:06 AM

Grid.Model.Path = function(model, pathData)
{
Grid.Model.Path.superclass.constructor.call(this, model);
this.pathData = pathData;
this._focusable = Grid.Model.Focusable.Manual;
};
Lang.extend(Grid.Model.Path, Grid.Model.Base);
Grid.Model.Path.prototype.createElement = function(view)
{
var id = this.getID();
var polyElement = view.createElement('path', { 'id': id });
this.appendElement(view, polyElement);
this.updateElement(view);
return polyElement;
};
Grid.Model.Path.prototype.updateElement = function(view)
{
var polyElement = this.getElement(view);
view.setAttributes(polyElement, { 'd': this.pathData });
Grid.Model.Path.superclass.updateElement.call(this, view);
};

// FILE: model.point.js (5ca8217a) 3/7/2014 11:24:06 AM

Grid.Model.Point = function(model, x, y, radius)
{
Grid.Model.Point.superclass.constructor.call(this, model, x, y, radius);
this.radius = radius;
this._transparent = false;
};
Lang.extend(Grid.Model.Point, Grid.Model.Circle);
Grid.Model.Point.prototype.makeTransparent = function(transparent) {
this._transparent = transparent;
this.update();
};
Grid.Model.Point.prototype.isTransparent = function () {
return this._transparent;
};
Grid.Model.Point.prototype.getBoundingRect = function(x, y)
{
var rect = Grid.Model.Point.superclass.getBoundingRect.call(this, x, y);
rect.top -= this.radius;
rect.bottom -= this.radius;
return rect;
};
Grid.Model.Point.prototype.getFixedCoords = function(moveX, moveY)
{
var rect = this.getBoundingRect(moveX, moveY);
var canvasWidth = this.model.options.canvasWidth;
var canvasHeight = this.model.options.canvasHeight;
if (rect.left < 0) moveX = 0;
if (rect.top < 0) moveY = 0;
if (rect.right > canvasWidth) moveX = canvasWidth;
if (rect.bottom > canvasHeight) moveY = canvasHeight;
return { x: moveX, y: moveY };
};
Grid.Model.Point.prototype.moveTo = function(moveX, moveY, preventSnap)
{
var moved = Grid.Model.Point.superclass.moveTo.call(this, moveX, moveY, preventSnap);
if (moved)
{
var lines = this.getLines();
for (var i = 0; i < lines.length; i++) this.model.fireLazy('onMove', lines[i]);
}
return moved;
};
Grid.Model.Point.prototype.getLines = function()
{
var pointLines = [];
var lines = this.model.getLines();
for(var i = 0; i < lines.length; i++)
{
var line = lines[i];
if (this == line.source || this == line.target)
{
pointLines.push(line);
}
}
return pointLines;
};
Grid.Model.Point.prototype.moveLines = function(toPoint)
{
if (!toPoint) return false;
var fromLines = this.getLines();
for(var i = 0; i < fromLines.length; i++)
{
var fromLine = fromLines[i];
var isSource = (fromLine.source == this);
this.model.deleteLine(fromLine);
if (isSource) this.model.addLine(toPoint, fromLine.target, fromLine.dirType);
else this.model.addLine(fromLine.source, toPoint, fromLine.dirType);
}
return true;
};
Grid.Model.Point.prototype._intersectLine = function(line)
{
var c = this.get2D(),
r = this.radius,
a1 = line.source.get2D(),
a2 = line.target.get2D();
return (Intersection.intersectCircleLine(c, r, a1, a2).source != 'Outside');
};
Grid.Model.Point.prototype._nearestPointAlongLine = function(line)
{
var px = this.x,
py = this.y,
x1 = line.source.x,
y1 = line.source.y,
x2 = line.target.x,
y2 = line.target.y;
var dx = x2 - x1;
var dy = y2 - y1;
if (dx == 0 && dy == 0) return { x: x1, y: y1 };
var t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);
if (t < 0)
{
dx = x1;
dy = y1;
}
else if (t > 1)
{
dx = x2;
dy = y2;
}
else
{
dx = x1 + t * dx;
dy = y1 + t * dy;
}
return new Point2D(dx, dy);
};
Grid.Model.Point.prototype.distanceFromLine = function(line)
{
var nearestPoint = this._nearestPointAlongLine(line);
return this.get2D().distanceFrom(nearestPoint);
};
Grid.Model.Point.prototype.getStyles = function()
{
var styles =
{
'fill': 'red',
'stroke': 'blue',
'stroke-width': '0',
'stroke-dasharray': ''
};
if (this.isFocused())
{
styles['stroke-width'] = '1';
}
else
{
styles['stroke-width'] = '0';
}
if (this._transparent) {
styles['opacity'] = '0';
}
return styles;
};
Grid.Model.Point.prototype.getElementGroup = function() { return 'points'; };
Grid.Model.Point.prototype.updateElement = function(view)
{
var pointElement = this.getElement(view);
if (this.isFocused())
{
view.bringToFront(pointElement);
}
Grid.Model.Point.superclass.updateElement.call(this, view);
};

// FILE: model.snappoint.js (f948b9f4) 3/7/2014 11:24:06 AM

Grid.Model.SnapPoint = function(model, x, y, radius, snapRadius)
{
Grid.Model.SnapPoint.superclass.constructor.call(this, model, x, y, radius);
this.snapRadius = snapRadius;
this.setHoverable(false);
this.setFocusable(Grid.Model.Focusable.Never);
this.setMoveable(false);
this.setSelectable(false);
this.setVisible(false);
};
Lang.extend(Grid.Model.SnapPoint, Grid.Model.Circle);
Grid.Model.SnapPoint.prototype.getList = function()
{
return this.model.getSnapPoints();
};
Grid.Model.SnapPoint.prototype.getStyles = function()
{
return Grid.Model.getEmptyStyles();
}

// FILE: model.line.js (18c255fe) 3/7/2014 11:24:06 AM

Grid.Model.Line = function(model, source, target, dirType, style, transparent)
{
Grid.Model.Line.superclass.constructor.call(this, model);
this.source = source;
this.target = target;
this.style = style || 'solid';
if (Lang.isBoolean(dirType)) {
dirType = dirType ? 'forward' : 'none';
}
else if (Lang.isString(dirType)) {
dirType = dirType.toLowerCase();
if (dirType != 'none' && dirType != 'forward' && dirType != 'back' && dirType != 'both') {
throw new Error('Invalid line direction');
}
} else {
dirType = 'none';
}
if (transparent) {
source.makeTransparent(dirType == 'both' || dirType == 'back');
target.makeTransparent(dirType == 'both' || dirType == 'forward');
}
this.dirType = dirType;
};
Lang.extend(Grid.Model.Line, Grid.Model.Base);
Grid.Model.Line.prototype.getLength = function()
{
var p1 = this.source.get2D();
var p2 = this.target.get2D();
return p1.distanceFrom(p2);
};
Grid.Model.Line.prototype.intersect = function(line)
{
var a1 = this.source.get2D(),
a2 = this.target.get2D(),
b1 = line.source.get2D(),
b2 = line.target.get2D();
return (Intersection.intersectLineLine(a1, a2, b1, b2).status == 'Intersection');
};
Grid.Model.Line.prototype.distanceFrom = function(line)
{
if (this.intersect(line)) return 0;
var distances = [];
distances.push(this.source.distanceFromLine(line));
distances.push(this.target.distanceFromLine(line));
distances.push(line.source.distanceFromLine(this));
distances.push(line.target.distanceFromLine(this));
return Math.min.apply(Math, distances);
};
Grid.Model.Line.prototype.getSlope = function()
{
var denom = this.target.x - this.source.x;
var num = this.target.y - this.source.y;
if (denom == 0) return Infinity;
else if (num == 0) return 0.0;
else return num / denom;
};
Grid.Model.Line.prototype.getAngle = function()
{
var x1 = this.source.x,
y1 = this.source.y,
x2 = this.target.x,
y2 = this.target.y;
return Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
};
Grid.Model.Line.prototype.getAngle2 = function()
{
var x1 = this.source.x,
y1 = this.source.y,
x2 = this.target.x,
y2 = this.target.y;
var radians = (x1 <= x2) ? Math.atan2(y2 - y1, x2 - x1) : Math.atan2(y1 - y2, x1 - x2);
var degrees = (radians * 180 / Math.PI);
return degrees;
};
Grid.Model.Line.prototype.isParallelTo = function(line, tolerance) {
var angleTolerance = 0.05;
var line1Vertical = false;
var line1Horizontal = false;
var line2Vertical = false;
var line2Horizontal = false;
var line1 = this;
var line2 = line;
if (line1.source.x >= line1.target.x) {
if (Math.abs(line1.source.x - line1.target.x) < .25) {
line1Vertical = true;
}
} else if (Math.abs(line1.target.x - line1.source.x) < .25) {
line1Vertical = true;
}
if (line2.source.x >= line2.target.x) {
if (Math.abs(line2.source.x - line2.target.x) < .25) {
line2Vertical = true;
}
} else if (Math.abs(line2.target.x - line2.source.x) < .25) {
line2Vertical = true;
}
if (line1.source.y >= line1.target.y) {
if (Math.abs(line1.source.y - line1.target.y) < .25) {
line1Horizontal = true;
}
} else if (Math.abs(line1.target.y - line1.source.y) < .25) {
line1Horizontal = true;
}
if (line2.source.y >= line2.target.y) {
if (Math.abs(line2.source.y - line2.target.y) < .25) {
line2Horizontal = true;
}
} else if (Math.abs(line2.target.y - line2.source.y) < .25) {
line2Horizontal = true;
}
if ((line1Vertical && line2Vertical) || (line1Horizontal && line2Horizontal)) {
return true;
}
if (!line1Vertical && !line2Vertical) {
var slope1 = (line1.target.y - line1.source.y) / (line1.target.x - line1.source.x);
var slope2 = (line2.target.y - line2.source.y) / (line2.target.x - line2.source.x);
if (slope1 == slope2) return true;
}
var distance = function(x, y) {
return (Math.sqrt(Math.pow((x), 2) + Math.pow((y), 2)));
};
var newX1 = line1.target.x - line1.source.x;
var newY1 = line1.target.y - line1.source.y;
var newX2 = line2.target.x - line2.source.x;
var newY2 = line2.target.y - line2.source.y;
var dotProd = newX1 * newX2 + newY1 * newY2;
var distance1 = distance(newX1, newY1);
var distance2 = distance(newX2, newY2);
var lengthProd = distance1 * distance2;
if (Math.abs(dotProd) == Math.abs(lengthProd)) return true;
var theta = angleTolerance + 1;
if (lengthProd != 0) theta = Math.acos(Math.abs(dotProd / lengthProd));
if (theta <= angleTolerance) return true;
return false;
};
Grid.Model.Line.prototype.getLongestLine = function(line)
{
var lines = [];
var d1 = this.source.distanceFrom(line.source);
var d2 = this.source.distanceFrom(line.target);
var start, end;
if (d1 < d2)
{
start = line.source;
end = line.target;
}
else
{
start = line.target;
end = line.source;
}
lines[0] = new Grid.Model.Line(this.model, start, end);
lines[1] = new Grid.Model.Line(this.model, this.source, end);
lines[2] = new Grid.Model.Line(this.model, start, this.target);
lines[3] = new Grid.Model.Line(this.model, end, this.target);
var length = this.getLength();
var longest = this;
for (var i = 0; i < 4; i++)
{
var l = lines[i].getLength();
if (lines[i].getLength() > length)
{
longest = lines[i];
length = l;
}
}
return longest;
};
Grid.Model.Line.prototype.getInfo = function()
{
var x1 = this.source.x,
y1 = this.source.y,
r1 = this.source.radius,
t1 = 1;
var x2 = this.target.x,
y2 = this.target.y,
r2 = this.target.radius,
t2 = 1;
var radians = Math.atan2(y2 - y1, x2 - x1);
var sourceOffset = -2;
var targetOffset = (this.dirType == 'none') ? -2 : -1;
if (!this.source.isTransparent()) {
x1 = x1 + (Math.cos(radians) * ((r1 + t1) + sourceOffset));
y1 = y1 + (Math.sin(radians) * ((r1 + t1) + sourceOffset));
}
if (!this.target.isTransparent()) {
x2 = x2 - (Math.cos(radians) * ((r2 + t2) + targetOffset));
y2 = y2 - (Math.sin(radians) * ((r2 + t2) + targetOffset));
}
var angle = (radians / (2 * Math.PI)) * 360; // radians to degrees
return {x1: x1, y1: y1, x2: x2, y2: y2, angle: angle };
};
Grid.Model.Line.prototype.getStyles = function()
{
return {
'fill': 'none',
'stroke': 'red',
'stroke-width': '1',
'stroke-dasharray': (this.style == 'dashed') ? '5, 5' : ''
};
};
Grid.Model.Line.prototype.getArrowStyles = function()
{
return {
'stroke-width': '1.3'
};
};
Grid.Model.Line.prototype.getElementGroup = function() { return 'lines'; };
Grid.Model.Line.prototype.createElement = function(view)
{
var id = this.getID();
var lineInfo = this.getInfo();
var lineElement = view.createElement('line', {
'id': id,
'x1': lineInfo.x1,
'y1': lineInfo.y1,
'x2': lineInfo.x2,
'y2': lineInfo.y2
});
this.appendElement(view, lineElement);
if (this.dirType == 'forward' || this.dirType == 'both')
{
this._createArrowElement(view, id + '_arrow1', lineInfo.x2, lineInfo.y2, lineInfo.angle);
}
if (this.dirType == 'both')
{
this._createArrowElement(view, id + '_arrow2', lineInfo.x1, lineInfo.y1, (lineInfo.angle - 180));
}
return lineElement;
};
Grid.Model.Line.prototype._getArrowPath = function(x, y)
{
var size = 6;
return 'M' + x + ' ' + y + ' L' + (x - size) + ' ' + (y - size) + ' M' + (x - size) + ' ' + (y + size) + ' L' + x + ' ' + y;
};
Grid.Model.Line.prototype._createArrowElement = function(view, id, x, y, angle)
{
var path = this._getArrowPath(x, y);
var arrowElement = view.createElement('path', {
'id': id,
'd': path,
'transform': 'rotate(' + angle + ', ' + x + ', ' + y + ')'
});
var lineStyles = this.getStyles();
var arrowStyles = this.getArrowStyles();
YAHOO.lang.augmentObject(arrowStyles, lineStyles, false);
view.setAttributes(arrowElement, arrowStyles);
view.appendChild('arrows', arrowElement);
return arrowElement;
};
Grid.Model.Line.prototype.moveElement = function(view)
{
var id = this.getID();
var lineInfo = this.getInfo();
var lineElement = view.getElementById(id);
if (!lineElement) throw new Error('Cannot move the line ' + id + ' because it does not exist');
view.setAttributes(lineElement, {
'x1': lineInfo.x1,
'y1': lineInfo.y1,
'x2': lineInfo.x2,
'y2': lineInfo.y2
});
if (this.dirType == 'forward' || this.dirType == 'both')
{
this._updateArrowElement(view, id + '_arrow1', lineInfo.x2, lineInfo.y2, lineInfo.angle);
}
if (this.dirType == 'both')
{
this._updateArrowElement(view, id + '_arrow2', lineInfo.x1, lineInfo.y1, (lineInfo.angle - 180));
}
};
Grid.Model.Line.prototype._updateArrowElement = function(view, id, x, y, angle)
{
var arrowElement = view.getElementById(id);
if (!arrowElement) throw new Error('Cannot move the arrow ' + id + ' because it does not exist');
var path = this._getArrowPath(x, y);
view.setAttributes(arrowElement, {
'd': path,
'transform': 'rotate(' + angle + ', ' + x + ', ' + y + ')'
});
};
Grid.Model.Line.prototype.removeElement = function(view)
{
var id = this.getID();
Grid.Model.Line.superclass.removeElement.call(this, view);
if (this.dirType == 'forward' || this.dirType == 'both') view.removeElement(id + '_arrow1');
if (this.dirType == 'both') view.removeElement(id + '_arrow2');
};
Grid.Model.Line.prototype.getElementGroup = function() { return 'lines'; };
Grid.Model.Line.prototype.createElement = function(view)
{
var id = this.getID();
var lineInfo = this.getInfo();
var lineElement = view.createElement('line', {
'id': id,
'x1': lineInfo.x1,
'y1': lineInfo.y1,
'x2': lineInfo.x2,
'y2': lineInfo.y2
});
this.appendElement(view, lineElement);
if (this.dirType == 'forward' || this.dirType == 'both')
{
this._createArrowElement(view, id + '_arrow1', lineInfo.x2, lineInfo.y2, lineInfo.angle);
}
if (this.dirType == 'both')
{
this._createArrowElement(view, id + '_arrow2', lineInfo.x1, lineInfo.y1, (lineInfo.angle - 180));
}
return lineElement;
};
Grid.Model.Line.prototype._getArrowPath = function(x, y)
{
var size = 6;
return 'M' + x + ' ' + y + ' L' + (x - size) + ' ' + (y - size) + ' M' + (x - size) + ' ' + (y + size) + ' L' + x + ' ' + y;
};
Grid.Model.Line.prototype._createArrowElement = function(view, id, x, y, angle)
{
var path = this._getArrowPath(x, y);
var arrowElement = view.createElement('path', {
'id': id,
'd': path,
'transform': 'rotate(' + angle + ', ' + x + ', ' + y + ')'
});
var lineStyles = this.getStyles();
var arrowStyles = this.getArrowStyles();
YAHOO.lang.augmentObject(arrowStyles, lineStyles, false);
view.setAttributes(arrowElement, arrowStyles);
view.appendChild('arrows', arrowElement);
return arrowElement;
};
Grid.Model.Line.prototype.moveElement = function(view)
{
var id = this.getID();
var lineInfo = this.getInfo();
var lineElement = view.getElementById(id);
if (!lineElement) throw new Error('Cannot move the line ' + id + ' because it does not exist');
view.setAttributes(lineElement, {
'x1': lineInfo.x1,
'y1': lineInfo.y1,
'x2': lineInfo.x2,
'y2': lineInfo.y2
});
if (this.dirType == 'forward' || this.dirType == 'both')
{
this._updateArrowElement(view, id + '_arrow1', lineInfo.x2, lineInfo.y2, lineInfo.angle);
}
if (this.dirType == 'both')
{
this._updateArrowElement(view, id + '_arrow2', lineInfo.x1, lineInfo.y1, (lineInfo.angle - 180));
}
};
Grid.Model.Line.prototype._updateArrowElement = function(view, id, x, y, angle)
{
var arrowElement = view.getElementById(id);
if (!arrowElement) throw new Error('Cannot move the arrow ' + id + ' because it does not exist');
var path = this._getArrowPath(x, y);
view.setAttributes(arrowElement, {
'd': path,
'transform': 'rotate(' + angle + ', ' + x + ', ' + y + ')'
});
};
Grid.Model.Line.prototype.removeElement = function(view)
{
var id = this.getID();
Grid.Model.Line.superclass.removeElement.call(this, view);
if (this.dirType == 'forward' || this.dirType == 'both') view.removeElement(id + '_arrow1');
if (this.dirType == 'both') view.removeElement(id + '_arrow2');
};

// FILE: model.rectangle.js (fee59fba) 3/7/2014 11:24:06 AM

Grid.Model.Rectangle = function(model, x, y, width, height)
{
Grid.Model.Rectangle.superclass.constructor.call(this, model, x, y);
this.width = width || 0;
this.height = height || 0;
this.setHoverable(false);
this.setFocusable(Grid.Model.Focusable.Manual);
this.setMoveable(true);
this.setSelectable(false);
};
Lang.extend(Grid.Model.Rectangle, Grid.Model.Position);
Grid.Model.Rectangle.prototype.getSize = function() { return this.width * this.height; };
Grid.Model.Rectangle.prototype.getBoundingRect = function(x, y)
{
if (!YAHOO.lang.isNumber(x)) x = this.x;
if (!YAHOO.lang.isNumber(y)) y = this.y;
var topLeftX = x;
var topLeftY = y;
var bottomRightX = (topLeftX + this.width);
var bottomRightY = (topLeftY + this.height);
return {
width: this.width,
height: this.height,
left: topLeftX,
top: topLeftY,
right: bottomRightX,
bottom: bottomRightY
};
};
Grid.Model.Rectangle.prototype.getFixedCoords = function(moveX, moveY)
{
var rect = this.getBoundingRect(moveX, moveY);
var canvasWidth = this.model.options.canvasWidth;
var canvasHeight = this.model.options.canvasHeight;
if (rect.left < 0) moveX = 0;
if (rect.top < 0) moveY = 0;
if (rect.right > canvasWidth) moveX = (canvasWidth - this.width);
if (rect.bottom > canvasHeight) moveY = (canvasHeight - this.height);
return { x: moveX, y: moveY };
};
Grid.Model.Rectangle.prototype.setCoords = function(coords)
{
coords = coords.split(',');
for (var i = 0; i < coords.length; i++) { coords[i] = (coords[i] * 1); }
var x1 = coords[0];
var y1 = coords[1];
var x2 = coords[2];
var y2 = coords[3];
this.x = x1;
this.y = y1;
this.width = (x2 - x1);
this.height = (y2 - y1);
this.update();
};
Grid.Model.Rectangle.prototype.getCoords = function()
{
var boundingRect = this.getBoundingRect();
return YAHOO.lang.substitute('{left}, {top}, {right}, {bottom}', boundingRect);
};
Grid.Model.Rectangle.prototype.createElement = function(view)
{
var id = this.getID();
var element = view.createElement('rect', { 'id': id });
this.appendElement(view, element);
return element;
};
Grid.Model.Rectangle.prototype.updateElement = function(view)
{
var element = this.getElement(view);
var boundingRect = this.getBoundingRect();
view.setAttributes(element, {
'x': boundingRect.left,
'y': boundingRect.top,
'width': boundingRect.width,
'height': boundingRect.height
});
Grid.Model.Rectangle.superclass.updateElement.call(this, view);
};
Grid.Model.Rectangle.prototype.moveElement = function(view)
{
var element = this.getElement(view);
var boundingRect = this.getBoundingRect();
view.setAttributes(element,
{
'x': boundingRect.left,
'y': boundingRect.top
});
};

// FILE: model.image.js (1c1be2af) 3/7/2014 11:24:06 AM

Grid.Model.Image = function(model, name, x, y, width, height)
{
Grid.Model.Image.superclass.constructor.call(this, model, x, y, width, height);
this.name = name;
this.setHoverable(false);
this.setFocusable(Grid.Model.Focusable.Manual);
this.setMoveable(true);
this.setSelectable(false);
};
Lang.extend(Grid.Model.Image, Grid.Model.Rectangle);
Grid.Model.Image.prototype.getBoundingRect = function(x, y)
{
if (!YAHOO.lang.isNumber(x)) x = this.x;
if (!YAHOO.lang.isNumber(y)) y = this.y;
var topLeftX = (x - Math.round(this.width / 2));
var topLeftY = (y - this.height);
var bottomRightX = (topLeftX + this.width);
var bottomRightY = (topLeftY + this.height);
return {
width: this.width,
height: this.height,
left: topLeftX,
top: topLeftY,
right: bottomRightX,
bottom: bottomRightY
};
};
Grid.Model.Image.prototype.getFixedCoords = function(moveX, moveY)
{
var rect = this.getBoundingRect(moveX, moveY);
var canvasWidth = this.model.options.canvasWidth;
var canvasHeight = this.model.options.canvasHeight;
if (rect.left < 0) moveX = Math.round(this.width / 2);
if (rect.top < 0) moveY = this.height;
if (rect.right > canvasWidth) moveX = (canvasWidth - Math.round(this.width / 2));
if (rect.bottom > canvasHeight) moveY = canvasHeight;
var tolerance = 4;
var rec = this.otherImageInSamePlace(moveX, moveY, tolerance);
while (rec != null)
{
moveX = rec.x + tolerance;
moveY = rec.y + tolerance;
rec = this.otherImageInSamePlace(moveX, moveY, tolerance);
}
return { x: moveX, y: moveY };
};
Grid.Model.Image.prototype.getPaletteImage = function()
{
var paletteImages = this.model.getPaletteImages();
for (var i = 0; i < paletteImages.length; i++)
{
var paletteImage = paletteImages[i];
if (paletteImage.name == this.name) return paletteImage;
}
return null;
};
Grid.Model.Image.prototype.otherImageInSamePlace = function(realX, realY, tolerance)
{
var p = new Point2D(realX, realY);
var size = this.getSize();
var images = this.model.getImages();
for(var i = 0; i < images.length; i++)
{
var rec = images[i];
if (rec == this) continue;
var distance = rec.get2D().distanceFrom(p);
if (distance < tolerance)
{
var sizeDif = Math.abs(rec.getSize() - size);
if (sizeDif < (.15 * size)) return rec;
}
}
return null;
};
Grid.Model.Image.prototype.getStyles = function()
{
return null;
};
Grid.Model.Image.prototype.getBorderStyles = function()
{
return {
'stroke': 'blue',
'stroke-width': '2',
'fill': 'none'
};
};
Grid.Model.Image.prototype.toString = function() { return this.name; };
Grid.Model.Image.prototype.getElementGroup = function() { return 'images'; };
Grid.Model.Image.prototype.createElement = function(view)
{
var id = this.getID();
var imageElement = view.createElement('image', {
'id': id,
'transform': 'translate(-0.5, -0.5)'
});
var paletteImage = this.getPaletteImage();
imageElement.setAttributeNS(XLINK_NS, 'xlink:href', paletteImage.url);
this.appendElement(view, imageElement);
return imageElement;
};
Grid.Model.Image.prototype.moveElement = function(view)
{
Grid.Model.Image.superclass.moveElement.call(this, view);
if (this.isFocused()) this._updateBorderElement(view);
};
Grid.Model.Image.prototype.updateElement = function(view)
{
Grid.Model.Image.superclass.updateElement.call(this, view);
if (this.isFocused()) this._updateBorderElement(view);
else this._removeBorderElement(view);
};
Grid.Model.Image.prototype.removeElement = function(view)
{
if (this.isFocused()) this._removeBorderElement(view);
Grid.Model.Image.superclass.removeElement.call(this, view);
};
Grid.Model.Image.prototype._updateBorderElement = function(view)
{
var id = this.getID();
var imageElement = view.getElementById(id);
var rect = this.getBoundingRect();
var borderID = imageElement.id + '_border';
var borderElement = view.getElementById(borderID);
if (borderElement == null)
{
borderElement = view.createElement('rect', { 'id': borderID });
var borderStyles = this.getBorderStyles();
view.setAttributes(borderElement, borderStyles);
view.appendChild('imageborders', borderElement);
}
view.setAttributes(borderElement,
{
'x': rect.left - 2,
'y': rect.top - 2,
'width': rect.width + 4,
'height': rect.height + 4
});
};
Grid.Model.Image.prototype._removeBorderElement = function(view)
{
var id = this.getID();
view.removeElement(id + '_border');
};

// FILE: model.staticimage.js (1dc2d357) 3/7/2014 11:24:06 AM

Grid.Model.StaticImage = function(model, url, x, y, width, height)
{
Grid.Model.StaticImage.superclass.constructor.call(this, model, x, y, width, height);
this.url = url;
this.setHoverable(false);
this.setFocusable(Grid.Model.Focusable.None);
this.setMoveable(false);
this.setSelectable(false);
};
Lang.extend(Grid.Model.StaticImage, Grid.Model.Rectangle);
Grid.Model.StaticImage.prototype.getStyles = function()
{
return null;
};
Grid.Model.BackgroundImage = function(model, url, x, y, width, height)
{
Grid.Model.BackgroundImage.superclass.constructor.call(this, model, url, x, y, width, height);
};
Lang.extend(Grid.Model.BackgroundImage, Grid.Model.StaticImage);
Grid.Model.StaticImage.prototype.getElementGroup = function() { return 'staticimages'; };
Grid.Model.StaticImage.prototype.createElement = function(view)
{
var id = this.getID();
var element = view.createElement('image', {
'id': id,
'transform': 'translate(-0.5, -0.5)'
});
element.setAttributeNS(XLINK_NS, 'xlink:href', this.url);
this.appendElement(view, element);
return element;
};

// FILE: model.label.js (859ad8a1) 3/7/2014 11:24:06 AM

Grid.Model.Label = function(model, x, y, text, fontSize, fontFamily)
{
Grid.Model.Label.superclass.constructor.call(this, model, x, y);
this.text = text;
this.fontSize = fontSize || '12';
this.fontFamily = fontFamily || 'Arial';
};
Lang.extend(Grid.Model.Label, Grid.Model.Position);
Grid.Model.Label.prototype.getStyles = function()
{
return {
"font-size": this.fontSize,
"font-family": this.fontFamily,
"fill": "black"
};
};
Grid.Model.Label.prototype.getElementGroup = function() { return 'labels'; };
Grid.Model.Label.prototype.createElement = function(view)
{
var id = this.getID();
var label = view.createElement('text', {
'id': id,
'x': this.x,
'y': this.y
});
this.appendElement(view, label);
};
Grid.Model.Label.prototype.updateElement = function(view)
{
var labelElement = this.getElement(view);
view.setText(labelElement.id, this.text);
Grid.Model.Label.superclass.updateElement.call(this, view);
};

// FILE: model.region.js (63277355) 3/7/2014 11:24:06 AM

Grid.Model.buildRegion = function(entityClass, regionName)
{
var regionClass = function()
{
var args = Array.prototype.slice.call(arguments, 0);
regionClass.superclass.constructor.apply(this, args);
this.name = regionName;
this._currentEvent = null;
this._events = {};
};
Lang.extend(regionClass, entityClass, Grid.Model.Region);
regionClass.prototype.isSelectable = function()
{
if (this.isSelected()) return true;
var regionGroups = this.getGroups();
for (var i = 0; i < regionGroups.length; i++)
{
var regionGroup = regionGroups[i];
if (regionGroup.isMaxMet()) return false;
}
return regionClass.superclass.isSelectable.call(this);
};
regionClass.prototype.select = function()
{
if (!this.isSelected()) this.deselectConflicts();
return regionClass.superclass.select.call(this);
};
return regionClass;
};
Grid.Model.Region = {};
Grid.Model.Region.getGroups = function()
{
var refGroups = [];
var regionGroups = this.model.getRegionGroups();
for (var i = 0; i < regionGroups.length; i++)
{
var regionGroup = regionGroups[i];
if (regionGroup.containsRegion(this))
{
refGroups.push(regionGroup);
}
}
return refGroups;
};
Grid.Model.Region.isOrphan = function()
{
return (this.getGroups().length == 0);
};
Grid.Model.Region.deselectConflicts = function()
{
var refGroups = this.getGroups();
var deselectRegions = [];
for (var i = 0; i < refGroups.length; i++)
{
var refGroup = refGroups[i];
var selectedRegions = refGroup.getSelectedRegions();
if (selectedRegions.length > 0)
{
if (refGroup.max == 1) deselectRegions.push(selectedRegions[0]);
else if (refGroup.isMaxMet()) return false;
}
}
for (var i = 0; i < deselectRegions.length; i++)
{
deselectRegions[i].deselect();
}
return true;
};
Grid.Model.Region.getEvent = function(name) { return this._events[name]; };
Grid.Model.Region.hasEvent = function(name) { return (this.getEvent(name) != null); };
Grid.Model.Region.createEvent = function(name)
{
this._events[name] = new Grid.Model.RegionEvent(this, name);
return this.getEvent(name);
};
Grid.Model.Region.deleteEvent = function(event)
{
event.deleteImage();
event.deleteLabel();
if (this._currentEvent == event) this._currentEvent = null;
delete(this._events[event.name]);
};
Grid.Model.Region.getCurrentEvent = function() { return this._currentEvent; };
Grid.Model.Region.setCurrentEvent = function(name)
{
if (this._currentEvent != null)
{
var entities = this._currentEvent.getEntities();
for (var i = 0; i < entities.length; i++)
{
entities[i].hide();
}
this._currentEvent = null;
}
this._currentEvent = this.getEvent(name);
if (this._currentEvent != null)
{
var entities = this._currentEvent.getEntities();
for (var i = 0; i < entities.length; i++)
{
entities[i].show();
}
return true;
}
return false;
};
Grid.Model.Region.getEvents = function()
{
var eventList = [];
for (var evt in this._events)
{
eventList.push(this._events[evt]);
}
return eventList;
};
Grid.Model.Region.getStyles = function()
{
var regionEvent = this.getCurrentEvent();
if (regionEvent != null)
{
return regionEvent.getStyles();
}
else
{
return Grid.Model.getEmptyStyles();
}
};
Grid.Model.Region.updateElement = function(view)
{
if (this.isSelected() && this.isFocused() && this.hasEvent('hoverselect'))
{
this.setCurrentEvent('hoverselect');
}
else if (this.isSelected() && this.hasEvent('select'))
{
this.setCurrentEvent('select');
}
else if (this.isFocused() && this.hasEvent('hover'))
{
this.setCurrentEvent('hover');
}
else if (this.hasEvent('unselect'))
{
this.setCurrentEvent('unselect');
}
else
{
this.setCurrentEvent(null);
}
this.constructor.superclass.updateElement.call(this, view);
};

// FILE: model.region.group.js (16ed26c2) 3/7/2014 11:24:06 AM

Grid.Model.RegionGroup = function(model, name, min, max)
{
this.model = model;
this.name = name || '';
this.min = min || 0;
this.max = max || 0;
this._regions = [];
};
Grid.Model.RegionGroup.prototype.getRegions = function() { return this._regions; };
Grid.Model.RegionGroup.prototype.getRegion = function(name)
{
var regions = this.getRegions();
for (var i = 0; i < regions.length; i++)
{
var region = regions[i];
if (region.name == name) return region;
}
return null;
};
Grid.Model.RegionGroup.prototype.getSelectedRegions = function()
{
var regions = this.getRegions();
var selectedRegions = [];
for (var i = 0; i < regions.length; i++)
{
var region = regions[i];
if (region.isSelected()) selectedRegions.push(region);
}
return selectedRegions;
};
Grid.Model.RegionGroup.prototype.addRegion = function(region)
{
this._regions.push(region);
};
Grid.Model.RegionGroup.prototype.containsRegion = function(region)
{
return (this._regions.indexOf(region) > -1);
};
Grid.Model.RegionGroup.prototype.removeRegion = function(region, deleteOrphan)
{
Grid.Model.arrayRemove(this._regions, region);
if (deleteOrphan && region.getGroups().length == 0)
{
this.model.deleteRegion(region);
}
};
Grid.Model.RegionGroup.prototype.isMaxMet = function()
{
var selectedRegions = this.getSelectedRegions();
return (this.max > 0 && selectedRegions.length >= this.max);
};

// FILE: model.region.event.js (ebfd2be4) 3/7/2014 11:24:06 AM

Grid.Model.RegionEvent = function(region, name)
{
this.region = region;
this.name = name;
this._image = null;
this._label = null;
this._styles = Grid.Model.getEmptyStyles();
};
Grid.Model.RegionEvent.prototype.getStyles = function() { return this._styles; };
Grid.Model.RegionEvent.prototype.setStyles = function(newStyles)
{
YAHOO.lang.augmentObject(this._styles, newStyles, true);
};
Grid.Model.RegionEvent.prototype.getEntities = function()
{
var entities = [];
if (this._image != null) entities.push(this._image);
if (this._label != null) entities.push(this._label);
return entities;
};
Grid.Model.RegionEvent.prototype.getImage = function() { return this._image; };
Grid.Model.RegionEvent.prototype.setImage = function(url, x, y, width, height)
{
if (this._image != null) this.deleteImage();
this._image = this.region.model.addStaticImage(url, x, y, width, height);
this._image.hide();
};
Grid.Model.RegionEvent.prototype.deleteImage = function()
{
if (this._image == null) return false;
this.region.model.deleteStaticImage(this._image);
this._image = null;
return true;
};
Grid.Model.RegionEvent.prototype.getLabel = function() { return this._label; };
Grid.Model.RegionEvent.prototype.setLabel = function(x, y, text)
{
if (this._label != null) this.deleteLabel();
this._label = this.region.model.addLabel(x, y, text);
this._label.hide();
};
Grid.Model.RegionEvent.prototype.deleteLabel = function()
{
if (this._label == null) return false;
this.region.model.deleteEntity(this._label);
this._label = null;
return true;
};
(function()
{
if (YAHOO.env.ua.gecko > 0) return;
Grid.Model.getEmptyStyles = function()
{
return {
'fill': 'white',
'fill-opacity': '0',
'stroke': 'white',
'stroke-width': '0',
'stroke-opacity': '0',
'stroke-dasharray': ''
};
};
Grid.Model.getDefaultStyles = function()
{
return {
'fill': 'white',
'fill-opacity': '0',
'stroke': 'red',
'stroke-width': '1',
'stroke-opacity': '1',
'stroke-dasharray': ''
};
};
var fixStyles = function(styles)
{
if (styles['stroke-opacity'] == null ||
styles['stroke-opacity'] == '')
{
var strokeWidth = parseInt(styles['stroke-width']);
if (strokeWidth > 0) styles['stroke-opacity'] = '1';
else if (strokeWidth === 0) styles['stroke-opacity'] = '0';
}
};
Grid.Model.RegionEvent.prototype.setStyles = function(newStyles)
{
YAHOO.lang.augmentObject(this._styles, newStyles, true);
fixStyles(this._styles);
};
})();

// FILE: model.palette.js (f7be00de) 3/7/2014 11:24:06 AM

Grid.Model.PaletteImage = function(model, name, url, width, height)
{
Grid.Model.PaletteImage.superclass.constructor.call(this, model);
this.name = name;
this.url = url;
this.width = width || 0;
this.height = height || 0;
this.loaded = false;
};
Lang.extend(Grid.Model.PaletteImage, Grid.Model.Base);
Grid.Model.PaletteImage.prototype.getImages = function()
{
var paletteCanvasImages = [];
var images = this.model.getImages();
for(var i = 0; i < images.length; i++)
{
var image = images[i];
if (image.name == this.name)
{
paletteCanvasImages.push(image);
}
}
return paletteCanvasImages;
};
Grid.Model.PaletteImage.prototype.toString = function() { return this.name; };

// FILE: view.js (2b2f9d1b) 3/7/2014 11:24:06 AM

var SVG_NS = "http://www.w3.org/2000/svg";
var XLINK_NS = "http://www.w3.org/1999/xlink";
var GRID_NS = 'http://www.air.org/2010/grid/';
Grid.View = function(svgFile)
{
this.svgFile = svgFile;
this.paletteImgIndex = 0;
this.paletteCenter = false;
this.paletteScale = false;
this.width = 600;
this.height = 500;
this._svgObject = null;
this._svgDoc = null;
this._svgWin = null;
this._svgRoot = null;
this._svgElement = null;
this._zoomLevel = 1;
this._domCache = {};
this.svgReady = false;
this.svgLoaded = false;
this._suspendRedrawEnabled = false;
this._debug = false;
this._fixedOffset = false;
this._layout = null;
if (Grid.Utils.hasSVGWeb()) {
ErrorHandler.wrapFunctions(this, [
'setAttributes', 'createElement',
'createPoint', 'createSnapPoint', 'movePoint', 'createLine', 'moveLine'
]);
}
};
Grid.View.prototype.render = function(id)
{
var parent = YAHOO.util.Dom.get(id);
var view = this;
var ready = function() {
view.svgReady = true;
view._create(parent);
};
if (Grid.Utils.hasSVGWeb()) {
if (svgweb.pageLoaded) {
ready();
} else {
window.onsvgload = function() { ready(); };
}
}
else if (Grid.Utils.hasSVGNative()) {
ready();
} else {
throw new Error('This browser does not have support for SVG');
}
};
Grid.View.prototype._fixOffset = function()
{
if (this._fixedOffset) return;
Grid.Utils.fixOffset(this._svgObject);
this._fixedOffset = true;
};
Grid.View.prototype._addCache = function(element) {
if (typeof element.id == 'string') this._domCache[element.id] = element;
};
Grid.View.prototype._removeCache = function(element) {
if (typeof element.id == 'string') delete(this._domCache[element.id]);
};
Grid.View.prototype.getElementById = function(id) {
if (this._svgDoc == null) return null;
if (!id) return null;
if (id.nodeType) return id;
if (typeof id == 'string') {
var element = this._domCache[id];
if (element) return element;
else return this._svgDoc.getElementById(id);
}
return null;
};
Grid.View.prototype.getElementsByTagName = function(tagName)
{
if (this._svgDoc == null) return null;
return this._svgDoc.getElementsByTagNameNS(SVG_NS, tagName);
};
Grid.View.prototype.createElement = function(name, attrs) {
if (typeof name != 'string') return false;
var element = null;
if (attrs != null && typeof attrs.id == 'string') {
element = this.getElementById(attrs.id);
}
if (element == null) {
element = this._svgDoc.createElementNS(SVG_NS, name);
}
this.setAttributes(element, attrs);
if (this._debug && element.id) {
logger.debug('Created \'{nodeName}\' with id \'{id}\'', element);
}
this._addCache(element);
return element;
};
Grid.View.prototype.setAttributes = function(node, attrs)
{
if (typeof node == 'string') {
node = this.getElementById(node);
}
if (node == null) return false;
if (attrs == null) return false;
var handle = null;
if (this._suspendRedrawEnabled === true) {
try {
handle = this._svgRoot.suspendRedraw(10000);
} catch (ex) {}
}
for (var name in attrs) {
if (attrs.hasOwnProperty(name)) {
var value = attrs[name];
node.setAttribute(name, value);
}
}
if (handle != null) {
this._svgRoot.unsuspendRedraw(handle);
}
return true;
};
Grid.View.prototype.setAttribute = function(node, name, value)
{
if (typeof node == 'string') {
node = this.getElementById(node);
}
if (node == null) return false;
node.setAttribute(name, value);
return true;
};
Grid.View.prototype.appendChild = function(parent, element)
{
if (typeof parent == 'string') {
parent = this.getElementById(parent);
}
if (parent == null) {
logger.warn('Failed to append the element \'' + element.id + '\' because the parent was not found.');
return false;
}
parent.appendChild(element);
if (Grid.Utils.isSVGFlash()) {
if (parent.getAttribute('style') != '') {
this.setAttributes(element, {
'style': parent.getAttribute('style')
});
}
}
return true;
};
Grid.View.prototype.removeChild = function(parent, element)
{
parent.removeChild(element);
if (YAHOO.lang.isObject(element._fakeNode) &&
YAHOO.lang.isArray(element._fakeNode._listeners)) {
element._fakeNode._listeners = {};
}
};
Grid.View.prototype.removeChildren = function(parent)
{
if (typeof parent == 'string') {
parent = this.getElementById(parent);
}
while (parent && parent.firstChild) {
this.removeChild(parent, parent.firstChild);
}
};
Grid.View.prototype.removeElement = function(id)
{
var element = this.getElementById(id);
if (element == null) {
logger.warn('Cannot remove the element \'' + id + '\' because it does not exist');
return false;
}
this._removeCache(element);
if (element.parentNode != null) {
this.removeChild(element.parentNode, element);
}
if (this._debug) logger.debug('Removed \'{nodeName}\' with id \'{id}\'', element);
return true;
};
Grid.View.prototype.setText = function(id, text)
{
var element = this.getElementById(id);
if (element == null) return false;
this.removeChildren(element);
var textNode = this._svgDoc.createTextNode(text);
element.appendChild(textNode);
return true;
};
Grid.View.prototype.bringToFront = function(id)
{
var element = this.getElementById(id);
if (element == null) return false;
var parent = element.parentNode;
if (parent == null) return false;
this.removeChild(parent, element);
parent.appendChild(element);
return true;
};
Grid.View.prototype.zoom = function(scale) {
this._zoomLevel = scale = (scale || this._zoomLevel || 1);
var zoomedWidth = Math.round(this.width * scale);
var zoomedHeight = Math.round(this.height * scale);
if (this._svgElement) {
if (this._svgElement.width.baseVal) {
this._svgElement.width.baseVal.value = zoomedWidth;
this._svgElement.height.baseVal.value = zoomedHeight;
}
if (YAHOO.env.ua.android > 0) {
this._svgElement.setAttribute('width', zoomedWidth);
this._svgElement.setAttribute('height', zoomedHeight);
}
}
if (this._svgObject) {
this._svgObject.width = zoomedWidth;
this._svgObject.height = zoomedHeight;
}
var groupWrapper = this.getElementById('groupWrapper');
if (groupWrapper) {
var groupTransform = groupWrapper.getAttribute('transform');
var groupTranslate = groupTransform.split(' scale')[0];
this.setAttributes(groupWrapper, {
'transform': groupTranslate + ' scale(' + scale + ')'
});
}
};
Grid.View.prototype.translateElement = function(element, x, y)
{
if (typeof element == 'string') {
element = this.getElementById(element);
}
if (element == null) return null;
var matrix = element.getCTM().inverse();
x = matrix.a * x + matrix.c * y + matrix.e;
y = matrix.b * x + matrix.d * y + matrix.f;
return { x: x, y: y };
};
Grid.View.prototype.dispose = function()
{
if (this._svgObject && this._svgObject.parentNode) {
this._svgObject.parentNode.removeChild(this._svgObject);
}
this._svgObject = null;
this._svgDoc = null;
this._svgWin = null;
this._svgRoot = null;
this._svgElement = null;
this._domCache = null;
if (Grid.Utils.hasSVGWeb()) {
if (svgweb._removedNodes != null) {
for (var i = 0; i < svgweb._removedNodes.length; i++) {
var node = svgweb._removedNodes[i];
if (node._fakeNode) {
node._fakeNode._htcNode = null;
}
node._fakeNode = null;
node._handler = null;
svgweb._removedNodes[i] = null;
}
svgweb._removedNodes = [];
}
}
};
YAHOO.lang.augmentProto(Grid.View, EventLazyProvider);
if (window.svgweb && top != window) top.svgweb = window.svgweb;

// FILE: view.layout.js (e0dca6f2) 3/7/2014 11:24:06 AM

Grid.Layout = function() {
var containerPaddingTop = 0;
var containerPaddingRight = 0;
var containerPaddingBottom = 0;
var containerPaddingLeft = 0;
var canvasWidth = 0;
var canvasHeight = 0;
var canvasBorderOffset = 0;
var paletteWidth = 0;
var toolbarHeight = 0;
var feedbackHeight = 0;
var paletteGutter = 0;
var toolbarGutter = 0;
var feedbackGutter = 0;
this.setContainerPadding = function(top, right, bottom, left) {
containerPaddingTop = top;
containerPaddingRight = right;
containerPaddingBottom = bottom;
containerPaddingLeft = left;
};
this.setCanvasWidth = function(width) {
canvasWidth = width;
};
this.setCanvasHeight = function(height) {
canvasHeight = height;
};
this.setCanvasBorderOffset = function(offset) {
canvasBorderOffset = offset;
};
this.setPaletteWidth = function(width, gutter) {
paletteWidth = width;
paletteGutter = gutter;
};
this.setToolbarHeight = function(height, gutter) {
toolbarHeight = height;
toolbarGutter = gutter;
};
this.setFeedbackHeight = function(height, gutter) {
feedbackHeight = height;
feedbackGutter = gutter;
};
this.getCanvasWidth = function() {
return canvasWidth;
};
this.getCanvasHeight = function() {
return canvasHeight;
};
this.getCanvasBorderOffset = function() {
return canvasBorderOffset;
};
this.getToolbarWidth = function() {
return this.getToolbarHeight() > 0 ? this.getCanvasWidth() : 0;
};
this.getToolbarHeight = function() {
return toolbarHeight;
};
this.getToolbarGutter = function() {
return (toolbarHeight > 0) ? toolbarGutter : 0;
};
this.getFeedbackWidth = function() {
return this.getFeedbackHeight() > 0 ? this.getCanvasWidth() : 0;
};
this.getFeedbackHeight = function() {
return feedbackHeight;
};
this.getFeedbackGutter = function() {
return (feedbackHeight > 0) ? feedbackGutter : 0;
};
this._getWidth = function() {
return this.getPaletteWidth() + this.getPaletteGutter() + this.getCanvasWidth();
};
this._getHeight = function() {
return this.getToolbarHeight() + this.getToolbarGutter() + this.getCanvasHeight() +
this.getFeedbackGutter() + this.getFeedbackHeight();
};
this.getPaletteWidth = function() {
return paletteWidth;
};
this.getPaletteHeight = function() {
return this._getHeight();
};
this.getPaletteGutter = function() {
return (paletteWidth > 0) ? paletteGutter : 0;
};
this.getGridWidth = function() {
return this._getWidth() + containerPaddingLeft + containerPaddingRight;
};
this.getGridHeight = function() {
return this._getHeight() + containerPaddingTop  + containerPaddingBottom;
};
this.getContainerPaddingTop = function() {
return containerPaddingTop;
};
this.getContainerPaddingLeft = function() {
return containerPaddingLeft;
};
this.getContainerPaddingBottom = function() {
return containerPaddingBottom;
};
this.getContainerPaddingRight = function() {
return containerPaddingRight;
};
this.getPaletteX = function() {
return 0;
};
this.getPaletteY = function() {
return 0;
};
this.getToolbarX = function() {
return this.getPaletteWidth() + this.getPaletteGutter();
};
this.getToolbarY = function() {
return 0;
};
this.getCanvasX = function() {
return this.getPaletteWidth() + this.getPaletteGutter();
};
this.getCanvasY = function() {
return this.getToolbarHeight() + this.getToolbarGutter();
};
this.getFeedbackX = function() {
return this.getPaletteWidth() + this.getPaletteGutter();
};
this.getFeedbackY = function() {
return this.getToolbarHeight() + this.getToolbarGutter() + this.getCanvasHeight() + this.getFeedbackGutter();
};
};
Grid.Layout.debug = function(layout) {
console.log('Palette: width=%d height=%d x=%d y=%d visible=%s',
layout.getPaletteWidth(), layout.getPaletteHeight(), layout.getPaletteX(), layout.getPaletteY());
console.log('Toolbar: width=%d height=%d x=%d y=%d visible=%s',
layout.getToolbarWidth(), layout.getToolbarHeight(), layout.getToolbarX(), layout.getToolbarY());
console.log('Canvas: width=%d height=%d x=%d y=%d',
layout.getCanvasWidth(), layout.getCanvasHeight(), layout.getCanvasX(), layout.getCanvasY());
console.log('Feedback: width=%d height=%d x=%d y=%d visible=%s',
layout.getFeedbackWidth(), layout.getFeedbackHeight(), layout.getFeedbackX(), layout.getFeedbackY());
};
Grid.View.prototype.updateLayout = function(layout) {
this.setAttribute('groupPalette', 'transform', 'translate(' +
layout.getPaletteX() + ',' +
layout.getPaletteY() + ')');
this.setAttributes('backgroundPalette', {
'width': layout.getPaletteWidth(),
'height': layout.getPaletteHeight()
});
this.setAttribute('groupToolbar', 'transform', 'translate(' +
layout.getToolbarX() + ',' +
layout.getToolbarY() + ')');
this.setAttributes('backgroundToolbar', {
'width': layout.getToolbarWidth(),
'height': layout.getToolbarHeight()
});
this.setAttribute('groupCanvas', 'transform', 'translate(' +
layout.getCanvasX() + ',' +
layout.getCanvasY() + ')');
this.setAttributes('backgroundCanvas', {
'width': layout.getCanvasWidth(),
'height': layout.getCanvasHeight(),
'x': layout.getCanvasBorderOffset(),
'y': layout.getCanvasBorderOffset()
});
this.setAttribute('groupFeedback', 'transform', 'translate(' +
layout.getFeedbackX() + ',' +
layout.getFeedbackY() + ')');
this.setAttributes('backgroundFeedback', {
'width': layout.getFeedbackWidth(),
'height': layout.getFeedbackHeight()
});
this.setAttribute('groupWrapper', 'transform', 'translate(' +
(layout.getContainerPaddingLeft() + 0.5) + ',' +
(layout.getContainerPaddingTop() + 0.5) + ')');
this.width = layout.getGridWidth();
this.height = layout.getGridHeight();
this.zoom();
};

// FILE: view.loader.js (f8646ae0) 3/7/2014 11:24:06 AM

Grid.View.prototype._create = function(parentEl)
{
var view = this;
var elementDoc = parentEl.ownerDocument;
var elementWin = elementDoc.parentWindow || elementDoc.defaultView;
var isFrame = (window != elementWin);
if (Grid.Utils.hasSVGWeb() && elementWin && !elementWin.svgweb)
{
elementWin.svgweb = window.svgweb;
}
var pageUnloaded = function() {
view.dispose();
};
elementWin.addEventListener('unload', pageUnloaded, false);
if (this._inlineHtml) this._createInline(parentEl);
else this._createObject(parentEl);
};
Grid.View.prototype._createObject = function(parentEl)
{
var svgID = parentEl.id + 'Container';
var svgObject = document.createElement('object', true);
svgObject.setAttribute('id', svgID);
svgObject.setAttribute('name', svgID);
svgObject.setAttribute('type', 'image/svg+xml');
svgObject.setAttribute('data', this.svgFile);
var view = this;
var loaded = function() { view._loadedObject(this); };
if (Grid.Utils.hasSVGWeb())
{
svgObject.addEventListener('SVGLoad', loaded, false);
svgweb.appendChild(svgObject, parentEl);
}
else
{
svgObject.addEventListener('load', loaded, false);
parentEl.appendChild(svgObject);
}
};
Grid.View.prototype._loadedObject = function(svgObject)
{
this._svgObject = svgObject;
this._svgDoc = this._svgObject.contentDocument;
this._svgWin = this._svgDoc.defaultView;
this._svgElement = this._svgDoc.documentElement;
this._svgRoot = this._svgDoc.rootElement;
this.svgLoaded = true;
this.fireLazy('loaded');
};
Grid.View.prototype._createInline = function(parentEl)
{
var callback =
{
success: this._loadedInline,
failure: this._failedInline,
scope: this,
argument: parentEl
};
YAHOO.util.Connect.asyncRequest('GET', this.svgFile, callback);
};
Grid.View.prototype._loadedInline = function(xhrObj)
{
var parentEl = xhrObj.argument;
var svgText = xhrObj.responseText;
parentEl.innerHTML = svgText;
this._svgElement = YAHOO.util.Dom.getChildren(parentEl)[0];
this._svgRoot = this._svgElement;
this._svgObject = this._svgElement;
this._svgDoc = this._svgElement.ownerDocument;
this._svgWin = this._svgDoc.parentWindow || this._svgDoc.defaultView;
this.svgLoaded = true;
this.fireLazy('loaded');
};

// FILE: view.canvas.js (285f52e5) 3/7/2014 11:24:06 AM

Grid.View.prototype.getCanvasResolution = function()
{
var backgroundCanvas = this.getElementById('backgroundCanvas');
return {
width: backgroundCanvas.getAttribute("width") * 1,
height: backgroundCanvas.getAttribute("height") * 1
};
};
Grid.View.prototype.createGridLines = function(spacing)
{
this.clearGridLines();
if (!YAHOO.lang.isNumber(spacing) || spacing == 0) return false;
var gridLines = this.getElementById('gridlines');
var createLine = function(x1, y1, x2, y2)
{
var lineElement = this.createElement('line', {
'x1': x1,
'y1': y1,
'x2': x2,
'y2': y2
});
gridLines.appendChild(lineElement);
};
var res = this.getCanvasResolution();
for (var x = 0; x <= res.width; x += spacing)
{
createLine.call(this, x, 0, x, res.height);
}
for (var y = 0; y <= res.height; y += spacing)
{
createLine.call(this, 0, y, res.width, y);
}
return true;
};
Grid.View.prototype.clearGridLines = function()
{
this.removeChildren('gridlines');
};
Grid.View.prototype.setCanvasCursor = function(type)
{
var groupCanvas = this.getElementById('groupCanvas');
this.setAttributes(groupCanvas, {
'cursor': type
});
};
Grid.View.prototype.setCanvasCustomCursor = function(url, x, y)
{
var groupCanvas = this.getElementById('groupCanvas');
x = x || 0;
y = y || 0;
this.setAttributes(groupCanvas, {
'cursor': 'url(\'' + url + '\') ' + x + ' ' + y + ' , crosshair'
});
};

// FILE: view.palette.js (0877ee20) 3/7/2014 11:24:06 AM

Grid.View.prototype._updatePaletteImgIndex = function(panup)
{
if (panup)
{
this.paletteImgIndex--;
}
else this.paletteImgIndex++;
this._updatePalettePaning();
};
Grid.View.prototype._getPaletteContainerWidth = function()
{
var paletteContainer = this.getElementById('backgroundPalette');
var paletteContainerXY = Grid.Utils.parseElementXY(paletteContainer);
return paletteContainerXY.width;
};
Grid.View.prototype.updateCenterScaleImage = function(paletteCenter, paletteScale)
{
this.paletteCenter = paletteCenter;
this.paletteScale = paletteScale;
this._updatePaletteLayout();
};
Grid.View.prototype._updatePaletteLayout = function()
{
var paletteContainer = this.getElementById('backgroundPalette');
var paletteContainerXY = Grid.Utils.parseElementXY(paletteContainer);
var paletteImages = this.getElementById('paletteImages').childNodes;
var paletteWidth = paletteContainerXY.width;
var x = 2;
var spacing = this.getPaletteSpacing();
var y = spacing;
for(var i = 0; i < paletteImages.length; i++)
{
var paletteImage = paletteImages[i];
var imageXY = Grid.Utils.parseElementXY(paletteImage);
if (this.paletteCenter)
{
if ((paletteWidth - imageXY.width) >= 0)
x = (paletteWidth - imageXY.width)/2;
else {
if (this.paletteScale) x = 0;
else x = (paletteWidth - imageXY.width)/2;
}
}
this.setAttributes(paletteImage, {
'x': x,
'y': y
}, 0);
paletteImage.scale = paletteWidth / imageXY.width;
if (this.paletteScale && paletteImage.scale < 1.0) {
paletteImage.scaled = true;
var transform = 'matrix(' + paletteImage.scale + ',0,0,' + paletteImage.scale + ',0,' + y * (1 - paletteImage.scale) + ')';
paletteImage.setAttribute('transform', transform);
} else if (paletteImage.scaled) {
paletteImage.scaled = false;
var transform = 'matrix(1,0,0,1,0,0)';
paletteImage.setAttribute('transform', transform);
}
if (this.paletteScale) {
y = y + imageXY.height * paletteImage.scale + spacing;
} else {
y = y + imageXY.height + spacing;
}
}
this._updatePalettePaning();
};
Grid.View.prototype._updatePalettePaning = function()
{
var panYoffset = this.getPalettePanOffset();
this.setAttributes(this.getElementById('paletteImages'),
{
'transform': 'translate(0, ' + (0 - panYoffset) + ')'
}, 0);
this.setAttributes(this.getElementById('palettecliprect'),
{
'x': 0,
'y': this.getPaletteClipOffset(panYoffset),
'height': this.getPaletteClipHeight()
}, 0);
};
Grid.View.prototype.getPaletteClipOffset = function(panYoffset)
{
var topClipAdjust = this.getPalettePanHeight();
if (panYoffset == 0) topClipAdjust = 0;
return (panYoffset + topClipAdjust);
};
Grid.View.prototype.getPalettePanOffset = function()
{
var paletteContainer = this.getElementById('backgroundPalette');
var paletteContainerXY = Grid.Utils.parseElementXY(paletteContainer);
var paletteImages = this.getElementById('paletteImages').childNodes;
var panYoffset = 0;
if (this.paletteImgIndex > 0) {
this.getElementById('panup').style.display = 'block';
for (var i=0; i<this.paletteImgIndex; i++) {
var paletteImage = paletteImages[i];
var imageXY = Grid.Utils.parseElementXY(paletteImage);
if (this.paletteScale)
panYoffset += imageXY.height * paletteImage.scale + this.getPaletteSpacing();
else
panYoffset += imageXY.height + this.getPaletteSpacing();
}
panYoffset -=  this.getPalettePanHeight();
} else {
this.getElementById('panup').style.display = 'none';
}
return panYoffset;
};
Grid.View.prototype.getPaletteClipHeight = function()
{
var paletteContainer = this.getElementById('backgroundPalette');
var paletteContainerXY = Grid.Utils.parseElementXY(paletteContainer);
var paletteImages = this.getElementById('paletteImages').childNodes;
var availableHeight = paletteContainerXY.height;
if (this.paletteImgIndex > 0) availableHeight -= this.getPalettePanHeight();
var totalHeight = 0;
for (var i = this.paletteImgIndex; i < paletteImages.length; i++)
{
var paletteImage = paletteImages[i];
var scale = 1;
if (this.paletteScale) scale = paletteImage.scale;
var imageXY = Grid.Utils.parseElementXY(paletteImage);
if (i == paletteImages.length - 1) totalHeight += imageXY.height * scale;
else totalHeight += imageXY.height * scale + this.getPaletteSpacing();
if (availableHeight < totalHeight)
{
availableHeight -= this.getPalettePanHeight();
this.getElementById('pandown').style.display = 'block';
var j = i;
while (totalHeight > availableHeight)
{
var preimage = paletteImages[j--];
var preXY = Grid.Utils.parseElementXY(preimage);
var increase;
if (this.paletteScale)
increase = preXY.height * preimage.scale + this.getPaletteSpacing();
else
increase = preXY.height + this.getPaletteSpacing();
totalHeight -= increase;
}
return totalHeight;
}
}
this.getElementById('pandown').style.display = 'none';
return availableHeight;
};
Grid.View.prototype.getPalettePanHeight = function()
{
return 15;
};
Grid.View.prototype.getPaletteSpacing = function()
{
return 3;
};
Grid.View.prototype.showPalette = function() {
this.setAttributes('groupPalette', { 'display': 'inline' });
};
Grid.View.prototype.hidePalette = function() {
this.setAttributes('groupPalette', { 'display': 'none' });
};
Grid.View.prototype.createPaletteImage = function(id, width, height, url)
{
var paletteElement = this.createElement('image', {
'id': id,
'width': width,
'height': height,
'transform': 'translate(-0.5, -0.5)'
});
paletteElement.setAttributeNS(XLINK_NS, 'xlink:href', url);
this.appendChild('paletteImages', paletteElement);
this._updatePaletteLayout();
return paletteElement;
};
Grid.View.prototype.clonePaletteImage = function(id, cloneID)
{
var paletteElement = this.getElementById(id);
var clonedElement = paletteElement.cloneNode(true);
clonedElement.id = cloneID;
this.appendChild('paletteDragging', clonedElement);
if (paletteElement.scaled) {
var x = paletteElement.getAttribute("x");
var y = paletteElement.getAttribute("y");
var s = "matrix(1,0,0,1,0,0)";
clonedElement.setAttribute("transform", s);
}
return clonedElement;
};
Grid.View.prototype.movePaletteImage = function(id, x, y)
{
var clonedElement = this.getElementById(id);
this.setAttributes(clonedElement,
{
'x': x,
'y': y
});
};
Grid.View.prototype.removePaletteImage = function(id)
{
this.removeElement(id);
this._updatePaletteLayout();
};
Grid.View.prototype.selectPaletteImage = function(paletteID)
{
var paletteElement = this.getElementById(paletteID);
var imageXY = Grid.Utils.parseElementXY(paletteElement);
var selectedPalette = this.getElementById('selectedPalette');
var height = imageXY.height + 4;
if (this.paletteScale) height = imageXY.height * paletteElement.scale + 4;
this.setAttributes(selectedPalette,
{
'x': 0,
'y': imageXY.y - this.getPalettePanOffset(),
'width': 75,
'height': height
}, 0);
selectedPalette.style.display = '';
};
Grid.View.prototype.deselectPaletteImage = function()
{
var selectedPalette = this.getElementById('selectedPalette');
selectedPalette.style.display = 'none';
};

// FILE: view.toolbar.js (37b2719f) 3/7/2014 11:24:06 AM

Grid.View.prototype.showToolbar = function() {
this.setAttributes('groupToolbar', { 'display': 'inline' });
};
Grid.View.prototype.hideToolbar = function() {
this.setAttributes('groupToolbar', { 'display': 'none' });
};

// FILE: view.feedback.js (a9e7cf78) 3/7/2014 11:24:06 AM

Grid.View.prototype.setFeedbackText = function(text)
{
this.setText('feedback', text);
};
Grid.View.prototype.setCoordinatesText = function(text)
{
this.setText('coordinates', text);
};
Grid.View.prototype.showFeedback = function() {
this.setAttributes('groupFeedback', { 'display': 'inline' });
};
Grid.View.prototype.hideFeedback = function() {
this.setAttributes('groupFeedback', { 'display': 'none' });
};

// FILE: view.editor.js (507bd1fa) 3/7/2014 11:24:06 AM

Grid.View.prototype.createSnapToPointAndCircle = function(x, y, r, id)
{
var center = this.createElement("circle", {
"id": 'snapPointCenter_' + id,
"cx": x,
"cy": y,
"r": 4
});
this.appendChild('crtool_snapcenter', center);
var circle = this.createElement("circle", {
"id": 'snapPointCircle_' + id,
"cx": x,
"cy": y,
"r": r
});
this.appendChild('crtool_snapcircle', circle);
};
Grid.View.prototype.createCRToolCircle = function(x, y, r)
{
var container = 'crtool_circle';
var centerId = 'crToolCircleCenter';
var circleId = 'crToolCircle';
var center = this.createElement("circle", {
"id": centerId,
"cx": x,
"cy": y,
"r": 4
});
this.appendChild(container, center);
var circle = this.createElement("circle", {
"id": circleId,
"cx": x,
"cy": y,
"r": r
});
this.appendChild(container, circle);
};
Grid.View.prototype.createCRToolRectangle = function(x1,y1,x2,y2)
{
var container = 'crtool_rectangle';
var rect = this.createElement("rect", {
"id": 'crToolRectangle',
"x": x1,
"y": y1,
"width": x2-x1,
"height": y2-y1
});
this.appendChild(container, rect);
};
Grid.View.prototype.updateHelperLine = function(id, x1, y1, x2, y2)
{
var mergeLine = this.getElementById(id);
if (!mergeLine)
{
mergeLine = this.createElement('line', {
'id': id,
'fill': 'none',
'stroke': 'green',
'stroke-width': '1',
'opacity': '0.7',
'stroke-dasharray': '3, 3'
});
this.appendChild('mergeLines', mergeLine);
}
this.setAttributes(mergeLine,
{
'x1': x1,
'y1': y1,
'x2': x2,
'y2': y2
});
};

// FILE: action.js (79bf0adc) 3/7/2014 11:24:06 AM

Grid.Action = {};
Grid.Action.actions = {};
Grid.Action.registerAction = function(modeName, action) { Grid.Action.actions[modeName] = action; };
Grid.Action.Base = function(grid)
{
this.grid = grid;
this.canvas = grid.canvas;
this.model = grid.model;
this._completed = false;
};
Grid.Action.Base.prototype.isCompleted = function() { return this._completed; };
Grid.Action.Base.prototype.onMouseEvent = function(evt) {};
Grid.Action.Base.prototype.onKeyEvent = function(evt) {};
Grid.Action.Base.prototype.dispose = function() {};
Grid.Action.Base.prototype.finalize = function()
{
this.dispose();
this._completed = true;
};

// FILE: action.move.js (940864e9) 3/7/2014 11:24:06 AM

Grid.Action.Move = function(grid)
{
Grid.Action.Move.superclass.constructor.call(this, grid);
this.moveObject = null;
};
YAHOO.lang.extend(Grid.Action.Move, Grid.Action.Base);
Grid.Action.Move.prototype.dispose = function()
{
if (this.moveObject instanceof Grid.Model.Point) this.canvas.finalizePoint(this.moveObject);
else if (this.moveObject instanceof Grid.Model.Image) this.canvas.finalizeImage(this.moveObject);
};
Grid.Action.Move.prototype.onMouseEvent = function(evt)
{
var focusedObject = this.canvas.getFocused();
if (evt.name == 'mousedown')
{
if (this.moveObject || focusedObject == null || !focusedObject.isMoveable())
{
this.finalize();
}
else
{
this.moveObject = focusedObject;
this.grid.setHint('DraggingObject');
}
}
if (this.moveObject == null) return;
if (evt.name == 'mousemove' || evt.name == 'drag')
{
var x = evt.currentPosition.x,
y = evt.currentPosition.y;
if (typeof this.moveObject.moveTo == 'function')
{
this.moveObject.moveTo(x, y);
}
}
if (evt.name == 'dragend')
{
this.finalize();
}
if (evt.name == 'mouseup' && focusedObject instanceof Grid.Model.Point)
{
this.finalize();
}
};
Grid.Action.Move.prototype.onKeyEvent = function(evt)
{
if (this.moveObject != null)
{
this.canvas.clearFocused();
this.finalize();
}
else
{
var focusedObject = this.canvas.getFocused();
if (focusedObject != null && focusedObject.isMoveable())
{
this.moveObject = focusedObject;
}
else
{
this.finalize();
}
}
};

// FILE: action.point.js (d490d4bb) 3/7/2014 11:24:06 AM

Grid.Action.Point = function(grid)
{
Grid.Action.Point.superclass.constructor.call(this, grid);
this.createdPoint = null;
};
YAHOO.lang.extend(Grid.Action.Point, Grid.Action.Base);
Grid.Action.Point.prototype.dispose = function()
{
if (this.createdPoint)
{
this.createdPoint = this.canvas.finalizePoint(this.createdPoint);
}
};
Grid.Action.Point.prototype.onMouseEvent = function(evt)
{
var x = evt.currentPosition.x,
y = evt.currentPosition.y;
if (evt.name == 'mousedown')
{
var entity = this.model.getEntity(evt.target.id);
if (entity && entity.getType() == 'point')
{
this.createdPoint = entity;
}
else
{
this.createdPoint = this.model.addPoint(x, y);
}
if (this.createdPoint == null) this.finalize();
}
if (evt.name == 'drag' && this.createdPoint.isMoveable())
{
this.createdPoint.moveTo(x, y);
}
if (evt.name == 'mouseup' || evt.name == 'dragend')
{
this.finalize();
}
};
Grid.Action.Point.prototype.onKeyEvent = function(evt)
{
if (!this.createdPoint)
{
this.createdPoint = this.model.addPoint(30, 30);
this.createdPoint.snapToGrid();
}
else
{
this.finalize();
}
};

// FILE: action.line.js (a25d6038) 3/7/2014 11:24:06 AM

Grid.Action.Line = function(grid)
{
Grid.Action.Line.superclass.constructor.call(this, grid);
this.pointType = 'none';
this.sourcePoint = null;
this.targetPoint = null;
this.line = null;
this.moved = false;
};
YAHOO.lang.extend(Grid.Action.Line, Grid.Action.Base);
Grid.Action.Line.prototype.dispose = function()
{
if (this.pointType == 'source')
{
this.canvas.finalizePoint(this.sourcePoint);
}
else if (this.pointType == 'target')
{
this.targetPoint = this.canvas.finalizePoint(this.targetPoint);
if (this.sourcePoint == this.targetPoint)
{
this.model.deleteLine(this.line);
}
}
};
Grid.Action.Line.prototype.getPoint = function() { return this[this.pointType + 'Point']; };
Grid.Action.Line.prototype.setPoint = function(point) { this[this.pointType + 'Point'] = point; };
Grid.Action.Line.prototype.movePoint = function(x, y)
{
var currentPoint = this.getPoint();
currentPoint.moveTo(x, y);
};
Grid.Action.Line.prototype.createLine = function()
{
this.line = this.model.addLine(this.sourcePoint, this.targetPoint);
};
Grid.Action.Line.prototype.canLineBeFinalized = function()
{
if (this.sourcePoint == null || this.targetPoint == null) return false;
if (!this.targetPoint.isMoveable()) return true;
if (!this.moved) return false;
var intersectedPoints = this.targetPoint.getIntersections();
for (var i = 0; i < intersectedPoints.length; i++)
{
if (this.sourcePoint == intersectedPoints[i]) return false;
}
return true;
};
Grid.Action.Line.prototype.onMouseEvent = function(evt)
{
var x = evt.currentPosition.x,
y = evt.currentPosition.y;
if (evt.name == 'mousedown')
{
var clickedEntity = this.model.getEntity(evt.target.id);
if (this.sourcePoint && this.sourcePoint == clickedEntity) return;
if (this.sourcePoint == null)
{
this.pointType = 'source';
if (clickedEntity && clickedEntity.getType == 'point')
{
this.setPoint(clickedEntity);
}
else
{
this.setPoint(this.model.addPoint(x, y));
this.sourcePoint = this.canvas.finalizePoint(this.sourcePoint);
}
}
if (this.targetPoint == null)
{
this.pointType = 'target';
this.setPoint(this.model.addPoint(x, y));
this.createLine();
}
if (this.canLineBeFinalized()) this.finalize();
}
if ((evt.name == 'mousemove' || evt.name == 'drag') && this.targetPoint.isMoveable())
{
this.moved = true;
this.movePoint(x, y);
}
if (evt.name == 'dragend')
{
if (this.canLineBeFinalized()) this.finalize();
}
};
Grid.Action.Line.prototype.onKeyEvent = function(evt)
{
var selected = this.canvas.getFocused();
if (selected && this.pointType == 'none')
{
this.pointType = 'source';
this.setPoint(selected);
}
if (!selected && this.pointType == 'none')
{
this.pointType = 'source';
this.setPoint(this.model.addPoint(30, 30));
}
else if (this.pointType == 'source')
{
this.sourcePoint = this.canvas.finalizePoint(this.sourcePoint);
this.pointType = 'target';
this.setPoint(this.model.addPoint(this.sourcePoint.x, this.sourcePoint.y));
this.createLine();
}
else
{
this.targetPoint = this.canvas.finalizePoint(this.targetPoint);
if (this.sourcePoint == this.targetPoint)
{
this.model.deleteLine(this.line);
}
this.finalize();
}
};
Grid.Action.LineDash = function(grid)
{
Grid.Action.LineDash.superclass.constructor.call(this, grid);
};
YAHOO.lang.extend(Grid.Action.LineDash, Grid.Action.Line);
Grid.Action.LineDash.prototype.createLine = function()
{
this.line = this.model.addLine(this.sourcePoint, this.targetPoint, 'none', 'dashed');
};

// FILE: action.arrow.js (c794903f) 3/7/2014 11:24:06 AM

Grid.Action.ArrowSingle = function(grid)
{
Grid.Action.ArrowSingle.superclass.constructor.call(this, grid);
};
YAHOO.lang.extend(Grid.Action.ArrowSingle, Grid.Action.Line);
Grid.Action.ArrowSingle.prototype.createLine = function()
{
this.line = this.model.addLine(this.sourcePoint, this.targetPoint, 'forward');
};
Grid.Action.ArrowDouble = function(grid)
{
Grid.Action.ArrowDouble.superclass.constructor.call(this, grid);
};
YAHOO.lang.extend(Grid.Action.ArrowDouble, Grid.Action.Line);
Grid.Action.ArrowDouble.prototype.createLine = function()
{
this.line = this.model.addLine(this.sourcePoint, this.targetPoint, 'both');
};

// FILE: action.delete.js (5ec81a89) 3/7/2014 11:24:06 AM

Grid.Action.Delete = function(grid)
{
Grid.Action.Delete.superclass.constructor.call(this, grid);
this.deletedPoint = null;
};
YAHOO.lang.extend(Grid.Action.Delete, Grid.Action.Base);
Grid.Action.Delete.prototype.onMouseEvent = function(evt)
{
if (evt.name == 'mouseup')
{
var selected = this.canvas.getFocused();
if (selected)
{
var type = selected.getType();
switch(type)
{
case 'point': this.model.deletePoint(selected); break;
case 'canvasimage': this.model.deleteImage(selected); break;
case 'circle': this.model.deleteEntity(selected); break;
}
this.finalize();
}
else
{
var targetEntity = this.model.getEntity(evt.target.id);
if (targetEntity && targetEntity.getType() == 'line')
{
this.model.deleteLine(targetEntity);
}
}
}
if (evt.name == 'mouseup' || evt.name == 'dragend') this.finalize();
};
Grid.Action.Delete.prototype.onKeyEvent = function(evt)
{
var selected = this.canvas.getFocused();
if (selected)
{
var type = selected.getType();
switch (type)
{
case 'point': this.model.deletePoint(selected); break;
case 'canvasimage': this.model.deleteImage(selected); break;
}
this.finalize();
}
};

// FILE: action.circle.js (3b572cf1) 3/7/2014 11:24:06 AM

Grid.Action.Circle = function(grid)
{
Grid.Action.Circle.superclass.constructor.call(this, grid);
this.createdCircle = null;
};
YAHOO.lang.extend(Grid.Action.Circle, Grid.Action.Base);
Grid.Action.Circle.prototype.create = function(x, y)
{
var circle = this.model.createCircle(x, y, 10);
this.model.addCircle(circle);
return circle;
};
Grid.Action.Circle.prototype.dispose = function () {
this.createdCircle.snap();
this.createdCircle = null;
};
Grid.Action.Circle.prototype.onMouseEvent = function(evt)
{
var x = evt.currentPosition.x,
y = evt.currentPosition.y;
if (evt.name == 'mousedown')
{
var entity = this.model.getEntity(evt.target.id);
if (entity && entity.getType() == 'circle')
{
this.createdCircle = entity;
}
else
{
this.createdCircle = this.create(x, y);
}
if (this.createdCircle == null) this.finalize();
}
if (evt.name == 'drag') {
var radius = evt.currentPosition.x - evt.clickedPosition.x;
this.createdCircle.radius = (radius < 10) ? this.createdCircle.radius : radius;
this.createdCircle.update();
}
if (evt.name == 'mouseup' || evt.name == 'dragend')
{
this.finalize();
}
};
Grid.Action.Circle.prototype.onKeyEvent = function(evt)
{
if (!this.createdPoint)
{
this.createdPoint = this.create(30, 30);
this.createdPoint.snapToGrid();
}
else
{
this.finalize();
}
};

// FILE: toolbar.js (8f38bc0f) 3/7/2014 11:24:07 AM

Grid.Toolbar = function(grid)
{
this.grid = grid;
this.view = grid.view;
this._buttonHash = {};
this._buttons = [];
};
Grid.Toolbar.prototype.init = function()
{
var buttonNames = ['move', 'delete', 'point', 'connect', 'arrow', 'arrw2', 'dash', 'circle'];
var grid = this.grid;
for (var i = 0; i < buttonNames.length; i++)
{
var buttonName = buttonNames[i];
var button = null;
switch (buttonName)
{
case 'move': button = new Grid.Toolbar.Button.Circle(this, buttonName); break;
default: button = new Grid.Toolbar.Button(this, buttonName); break;
}
button.hide();
this._buttons.push(button);
this._buttonHash[buttonName] = button;
(function (button) {
var buttonGroup = button.getGroup();
Grid.Utils.addMouseListener(buttonGroup, 'mousedown', function () {
if (!grid.isReadOnly()) {
grid.setMode(button.name);
}
}, false);
})(button);
}
};
Grid.Toolbar.prototype.getButton = function(buttonName) { return this._buttonHash[buttonName]; };
Grid.Toolbar.prototype.getButtons = function() { return this._buttons; };
Grid.Toolbar.prototype.getVisibleButtons = function()
{
var visibleButtons = [];
for (var i = 0; i < this._buttons.length; i++)
{
var button = this._buttons[i];
if (button.isVisible()) visibleButtons.push(button);
}
return visibleButtons;
};
Grid.Toolbar.prototype.resetButtons = function()
{
for (var i = 0; i < this._buttons.length; i++)
{
var button = this._buttons[i];
button.hide();
}
};
Grid.Toolbar.prototype.enableButtons = function(buttonNames)
{
this.resetButtons();
for (var i = 0; i < buttonNames.length; i++) {
var button = this._buttonHash[buttonNames[i]];
button.show();
}
var spacing = 5;
var x = spacing;
var y = 2;
for (var i = 0; i < this._buttons.length; i++) {
var button = this._buttons[i];
if (!button.isVisible()) continue;
var buttonGroup = button.getGroup();
this.view.setAttributes(buttonGroup,
{
'transform': 'translate(' + x + ', ' + y + ')'
});
x = x + button.width + spacing;
}
};
Grid.Toolbar.prototype.processKeyEvent = function(evt)
{
if (evt.key == 'enter')
{
this.grid.setArea('canvas');
return;
}
if (evt.key != 'left' && evt.key != 'right') return;
var selectedButton = this.getButton(this.grid.getMode());
var visibleButtons = this.getVisibleButtons();
if (visibleButtons.length == 0) return;
for (var i = 0; i < visibleButtons.length; i++)
{
var button = visibleButtons[i];
if (button == selectedButton)
{
if (evt.key == 'left')
{
if (i == 0) selectedButton = visibleButtons[visibleButtons.length - 1];
else selectedButton = visibleButtons[i - 1];
}
else if (evt.key == 'right')
{
if (i == (visibleButtons.length - 1)) selectedButton = visibleButtons[0];
else selectedButton = visibleButtons[i + 1];
}
break;
}
}
this.grid.setMode(selectedButton.name);
};
Grid.Action.registerAction('move', Grid.Action.Move);
Grid.Action.registerAction('delete', Grid.Action.Delete);
Grid.Action.registerAction('point', Grid.Action.Point);
Grid.Action.registerAction('connect', Grid.Action.Line);
Grid.Action.registerAction('arrow', Grid.Action.ArrowSingle);
Grid.Action.registerAction('arrw2', Grid.Action.ArrowDouble);
Grid.Action.registerAction('dash', Grid.Action.LineDash);
Grid.Action.registerAction('circle', Grid.Action.Circle);

// FILE: toolbar.button.js (90ecf603) 3/7/2014 11:24:07 AM

Grid.Toolbar.Button = function(toolbar, name)
{
this.name = name;
this.width = 100;
this.toolbar = toolbar;
this.grid = toolbar.grid;
this.view = toolbar.view;
this._visible = true;
this._state = Grid.Toolbar.Button.State.Up;
this._iconFillElements = [];
this._iconStrokeElements = [];
this._init();
};
Grid.Toolbar.Button.State =
{
Up: 0,
Selected: 1,
Over: 2,
SelectedOver: 3
};
Grid.Toolbar.Button.prototype._init = function()
{
var buttonGroup = this.getGroup();
for (var i = 0; i < buttonGroup.childNodes.length; i++)
{
var element = buttonGroup.childNodes[i];
if (element.nodeType == 1)
{
if (element.getAttribute('fill') == '#ffffff') this._iconFillElements.push(element);
if (element.getAttribute('stroke') == '#ffffff') this._iconStrokeElements.push(element);
}
if (typeof window.Messages == 'object' && element.nodeName == 'text')
{
var key = "GridSVG.Label.button_"+element.textContent.replace(" ","_");
var alternateLabel = window.Messages.get(key);
if(alternateLabel != key) {
element.textContent = alternateLabel;
}
}
}
};
Grid.Toolbar.Button.prototype.getGroup = function()
{
return this.view.getElementById('button_' + this.name);
};
Grid.Toolbar.Button.prototype.getContainer = function()
{
var buttonGroup = this.getGroup();
var path = null;
for (var i = 0; i < buttonGroup.childNodes.length; i++)
{
var node = buttonGroup.childNodes[i];
if (node.nodeName == 'path')
{
path = node;
break;
}
}
return path;
};
Grid.Toolbar.Button.prototype.show = function()
{
var buttonGroup = this.getGroup();
buttonGroup.style.display = '';
this._visible = true;
};
Grid.Toolbar.Button.prototype.hide = function()
{
var buttonGroup = this.getGroup();
buttonGroup.style.display = 'none';
this._visible = false;
};
Grid.Toolbar.Button.prototype.isVisible = function() { return this._visible; };
Grid.Toolbar.Button.prototype._setIconColor = function(color)
{
for (var i = 0; i < this._iconFillElements.length; i++)
{
var element = this._iconFillElements[i];
element.setAttribute('fill', color);
}
for (var i = 0; i < this._iconStrokeElements.length; i++)
{
var element = this._iconStrokeElements[i];
element.setAttribute('stroke', color);
}
};
Grid.Toolbar.Button.prototype.deselect = function()
{
this._state = Grid.Toolbar.Button.State.Up;
this._setIconColor('#ffffff');
var container = this.getContainer();
container.setAttribute('fill', 'url(#buttons_background_up)');
};
Grid.Toolbar.Button.prototype.select = function()
{
this._state = Grid.Toolbar.Button.State.Selected;
this._setIconColor('#1f5181');
var container = this.getContainer();
container.setAttribute('fill', 'url(#buttons_background_selected)');
};
Grid.Toolbar.Button.Circle = function(toolbar, name)
{
Grid.Toolbar.Button.Circle.superclass.constructor.call(this, toolbar, name);
this.width = 18;
};
Lang.extend(Grid.Toolbar.Button.Circle, Grid.Toolbar.Button);
Grid.Toolbar.Button.Circle.prototype.getContainer = function()
{
var buttonGroup = this.getGroup();
var circle = null;
for (var i = 0; i < buttonGroup.childNodes.length; i++)
{
var node = buttonGroup.childNodes[i];
if (node.nodeName == 'circle')
{
circle = node;
break;
}
}
return circle;
};

// FILE: palette.js (63a68ea5) 3/7/2014 11:24:07 AM

Grid.Palette = function(grid)
{
this.grid = grid;
this.view = grid.view;
this.model = grid.model;
this.canvas = grid.canvas;
this._selectedImage = null;
this.moving = false;
if (Grid.Utils.hasSVGWeb())
{
ErrorHandler.wrapFunctions(this, ['processMouseEvent', 'subscribeToModelEvents']);
}
};
Grid.Palette.prototype.clearMoving = function()
{
this.moving = false;
var imageID = this._selectedImage.getID();
var cloneID = imageID + '_clone';
this.view.removeElement(cloneID);
this.grid.setModeHint();
};
Grid.Palette.prototype.getSelected = function() { return this._selectedImage; };
Grid.Palette.prototype.hasSelected = function () { return this._selectedImage != null; };
Grid.Palette.prototype.setSelected = function(paletteImage)
{
if (this.moving) this.clearMoving();
if (this._selectedImage && this._selectedImage == paletteImage) return false;
if (this._selectedImage)
{
var id = this._selectedImage.getID() + '_border';
this.view.deselectPaletteImage();
logger.debug('palette unselected: ' + id);
}
this._selectedImage = paletteImage || null;
if (paletteImage)
{
var id = paletteImage.getID();
this.view.selectPaletteImage(id);
logger.debug('palette selected: ' + id);
this.grid.setMode('move');
this.grid.canvas.clearFocused();
}
return true;
};
Grid.Palette.prototype.clearSelected = function()
{
return this.setSelected(null);
};
Grid.Palette.prototype.processMouseEvent = function(evt)
{
if (!this.moving && evt.name == 'mousedown')
{
if ((evt.target.id == 'panup') || (evt.target.id == 'pandown'))
{
if (evt.target.id == 'panup') {
this.grid.view._updatePaletteImgIndex(true);
} else {
this.grid.view._updatePaletteImgIndex(false);
}
return;
}
if (evt.target.nodeName == 'image' && evt.target.id.indexOf('paletteimage_') != -1)
{
this.setSelected(this.model.getEntity(evt.target.id));
}
else
{
this.clearSelected();
}
}
var paletteImage = this.getSelected();
if (paletteImage == null) return;
var imageID = paletteImage.getID();
var cloneID = imageID + '_clone';
var gridX = evt.currentPosition.x - Math.round(paletteImage.width / 2);
var gridY = evt.currentPosition.y - paletteImage.height;
if (!this.moving && (evt.name == 'mousedown' || evt.name == 'dragbegin'))
{
this.moving = true;
this.view.clonePaletteImage(imageID, cloneID);
this.view.movePaletteImage(cloneID, gridX, gridY);
this.grid.setHint('DraggingObject');
}
else if (this.moving && (evt.name == 'mousemove' || evt.name == 'drag'))
{
this.view.movePaletteImage(cloneID, gridX, gridY);
}
else if (this.moving && (evt.name == 'mousedown' || evt.name == 'dragend'))
{
this.clearMoving();
this.clearSelected();
var canvasPosition = this.view.translateElement('groupCanvas', evt.raw.clientX, evt.raw.clientY);
if (canvasPosition && canvasPosition.x > 0 && canvasPosition.y > 0)
{
var image = this.model.addImage(paletteImage.name, canvasPosition.x, canvasPosition.y);
this.grid.canvas.finalizeImage(image);
this.grid.setArea('canvas');
}
}
};
Grid.Palette.prototype.processKeyEvent = function(evt)
{
var selected = this.getSelected();
var paletteImages = this.model.getPaletteImages();
if (evt.key == 'space')
{
var image = this.model.addImage(selected.name, 0, 0);
this.grid.canvas.finalizeImage(image);
this.grid.canvas.setFocused(image);
this.grid.setArea('canvas');
this.grid.setMode('move');
this.clearSelected();
this.grid.canvas.processKeyEvent(evt);
}
if (selected == null && (evt.key == 'up' || evt.key == 'down'))
{
this.setSelected(paletteImages[0]);
return;
}
if (evt.key == 'up' || evt.key == 'down')
{
if (paletteImages.length == 0) return;
var paletteIndex = -1;
for (var i = 0; i < paletteImages.length; i++)
{
if (paletteImages[i] == selected)
{
paletteIndex = i;
break;
}
}
if (evt.key == 'down')
{
if (paletteIndex < paletteImages.length - 1)
{
this.setSelected(paletteImages[paletteIndex + 1]);
}
else
{
this.setSelected(paletteImages[0]);
}
}
if (evt.key == 'up')
{
if (paletteIndex == 0)
{
this.setSelected(paletteImages[paletteImages.length - 1]);
}
else
{
this.setSelected(paletteImages[paletteIndex - 1]);
}
}
}
};
Grid.Palette.prototype.subscribeToModelEvents = function()
{
var palette = this;
var view = this.view;
var question = this.model;
this.model.subscribe('onAdd', function(entity)
{
var id = entity.getID();
if (entity instanceof Grid.Model.PaletteImage)
{
view.createPaletteImage(id, entity.width, entity.height, entity.url);
}
});
this.model.subscribe('onDelete', function(entity)
{
var id = entity.getID();
if (entity instanceof Grid.Model.PaletteImage)
{
view.removePaletteImage(id);
}
});
};

// FILE: canvas.js (b03ca385) 3/7/2014 11:24:06 AM

Grid.Canvas = function(grid)
{
this.grid = grid;
this.view = grid.view;
this.model = grid.model;
this._currentHover = null;
this._currentFocus = null;
this._currentAction = null;
if (Grid.Utils.hasSVGWeb())
{
ErrorHandler.wrapFunctions(this,
[
'finalizePoint', 'finalizeLines', 'processMouseEvent', 'processKeyEvent', 'subscribeToModelEvents'
]);
}
this.init();
};
YAHOO.lang.augmentProto(Grid.Canvas, EventLazyProvider);
Grid.Canvas.prototype.init = function()
{
var canvas = this;
var view = this.view;
var onEntityEvent = function(name, entity)
{
logger.debug('EVENT - {name} ({id})', { name: name, id: entity.getID() });
entity.updateElement(view);
};
this.subscribe('onHover', function(entity) { onEntityEvent('onHover', entity); });
this.subscribe('onHoverOut', function(entity) { onEntityEvent('onHoverOut', entity); });
this.subscribe('onFocus', function(entity) { onEntityEvent('onFocus', entity); });
this.subscribe('onFocusOut', function(entity) { onEntityEvent('onFocusOut', entity); });
this.subscribe('onActionStart', function(action)
{
var mode = this.grid.getMode();
var focusedEntity = canvas.getFocused();
if (mode == 'move' && focusedEntity != null)
{
if (focusedEntity.isSelected()) focusedEntity.deselect();
else focusedEntity.select();
}
});
};
Grid.Canvas.prototype.getHovering = function() { return this._currentHover; };
Grid.Canvas.prototype.clearHovering = function()
{
if (this._currentHover == null) return false;
var entity = this._currentHover;
this._currentHover = null;
entity.setHovering(false);
this.fireLazy('onHoverOut', entity);
if (entity.isFocusable() === Grid.Model.Focusable.Auto) this.clearFocused(entity);
return true;
};
Grid.Canvas.prototype.setHovering = function(entity)
{
if (this._currentHover == entity) return false;
this.clearHovering();
if (entity == null) return false;
if (!entity.isHoverable()) return false;
if (this.performingAction()) return false;
var allowHover = this.fireLazy('onBeforeHover', entity);
if (allowHover)
{
this._currentHover = entity;
entity.setHovering(true);
this.fireLazy('onHover', entity);
if (entity.isFocusable() === Grid.Model.Focusable.Auto) this.setFocused(entity);
}
return allowHover;
};
Grid.Canvas.prototype.getFocused = function() { return this._currentFocus; };
Grid.Canvas.prototype.clearFocused = function(entity)
{
if (this._currentFocus == null) return false;
if (entity != null && entity != this._currentFocus) return false;
entity = this._currentFocus;
this._currentFocus = null;
entity.setFocused(false);
this.fireLazy('onFocusOut', entity);
return true;
};
Grid.Canvas.prototype.setFocused = function(entity)
{
if (entity == this._currentFocus) return false;
this.clearFocused();
if (entity == null) return false;
if (this.grid.palette.moving == true) return false;
if (!entity.isFocusable()) return false;
var allowFocus = this.fireLazy('onBeforeFocus', entity);
if (allowFocus)
{
this._currentFocus = entity;
entity.setFocused(true);
this.fireLazy('onFocus', entity);
}
return allowFocus;
};
Grid.Canvas.prototype.performingAction = function() { return (this._currentAction != null); };
Grid.Canvas.prototype.startAction = function()
{
if (this._currentAction != null) return false;
var focusedEntity = this.getFocused();
if (focusedEntity != null && focusedEntity.isMoveable())
{
this.clearHovering();
}
var mode = this.grid.getMode();
var actionClass = Grid.Action.actions[mode];
if (actionClass == null) return false;
this._currentAction = new actionClass(this.grid);
this.fireLazy('onActionStart', this._currentAction);
return true;
};
Grid.Canvas.prototype.stopAction = function()
{
if (this._currentAction == null) return false;
if (!this._currentAction.isCompleted()) this._currentAction.finalize();
this.grid.setModeHint();
var action = this._currentAction;
this._currentAction = null;
this.fireLazy('onActionEnd', action);
return true;
};
Grid.Canvas.prototype.finalizePoint = function(point)
{
var lines = point.getLines();
point.snap();
var intersectedPoints = point.getIntersections();
if (intersectedPoints.length == 0)
{
this.finalizeLines(lines);
return point;
}
var mergePoint = intersectedPoints[0];
point.moveLines(mergePoint);
if (point == this.getFocused()) this.setFocused(mergePoint);
this.model.deletePoint(point);
this.finalizeLines(mergePoint.getLines());
return mergePoint;
};
Grid.Canvas.prototype.finalizeLines = function(pointLines)
{
if (this._currentAction instanceof Grid.Action.Line && this._currentAction.targetPoint == null) return;
var toleranceParallel = 10;
var toleranceDistance = 4;
for (var i = 0; i < pointLines.length; i++)
{
var pointLine = pointLines[i];
var lines = this.model.getLinesByDir(pointLine.dirType);
for (var j = 0; j < lines.length; j++)
{
var line = lines[j];
if (pointLine == line) continue;
var isParallel = pointLine.isParallelTo(line, toleranceParallel);
if (!isParallel) continue;
var distance = pointLine.distanceFrom(line);
if (distance > toleranceDistance) continue;
var newLine = pointLine.getLongestLine(line);
this.model.deleteLine(line);
this.model.deleteLine(pointLine);
var mergedLine = this.model.addLine(newLine.source, newLine.target, pointLine.dirType, pointLine.style);
if (line.source.getLines().length == 0) this.model.deletePoint(line.source);
if (line.target.getLines().length == 0) this.model.deletePoint(line.target);
if (pointLine.source.getLines().length == 0) this.model.deletePoint(pointLine.source);
if (pointLine.target.getLines().length == 0) this.model.deletePoint(pointLine.target);
var mergedLines = [];
mergedLines.push(mergedLine);
this.finalizeLines(mergedLines);
return;
}
}
};
Grid.Canvas.prototype.finalizeImage = function(image)
{
image.snap();
};
Grid.Canvas.prototype.processMouseEvent = function(evt)
{
this._checkForMouseHover(evt);
this._checkForMouseFocus(evt);
this._processMouseAction(evt);
};
Grid.Canvas.prototype._checkForMouseHover = function(evt)
{
if (evt.name != 'mousemove' || this.performingAction()) return;
if (evt.target == null || evt.target.id == null) return;
var entity = this.model.getEntity(evt.target.id);
if (entity && entity.isHoverable()) this.setHovering(entity);
else this.clearHovering();
};
Grid.Canvas.prototype._checkForMouseFocus = function(evt)
{
if (evt.name != 'mousedown') return;
if (evt.target == null) return;
var entity = this.model.getEntity(evt.target.id);
if (entity && entity.isFocusable()) this.setFocused(entity);
else this.clearFocused();
};
Grid.Canvas.prototype._processMouseAction = function(evt                  )
{
var mode = this.grid.getMode();
if (this._currentAction == null)
{
if (evt.name != 'mousedown') return;
this.startAction();
}
try
{
this._currentAction.onMouseEvent(evt);
}
catch (ex)
{
this._currentAction = null;
throw ex;
}
if (this._currentAction != null && this._currentAction.isCompleted()) this.stopAction();
};
Grid.Canvas.prototype.getFocusableObjects = function(typeFilter)
{
var focusableEntities = [];
var entities = this.model.getEntities();
for (var i = 0; i < entities.length; i++)
{
var entity = entities[i];
if ((typeof typeFilter != 'function' || entity instanceof typeFilter) && entity.isFocusable())
{
focusableEntities.push(entities[i]);
}
}
return focusableEntities;
};
Grid.Canvas.prototype.processKeyEvent = function(evt)
{
var focusedObject = this.getFocused();
if (evt.key == 'esc')
{
this.clearFocused();
this.stopAction();
}
if (evt.key == 'enter' && this._currentAction == null)
{
var objects;
if (this.grid.getMode() == 'move' || this.grid.getMode() == 'delete')
{
objects = this.getFocusableObjects(Grid.Model.Base);
}
else
{
objects = this.getFocusableObjects(Grid.Model.Point);
}
var nextObject = this._nextObjectInFocusableOrder(focusedObject, objects);
if (focusedObject != nextObject)
{
this.stopAction();
}
this.setFocused(nextObject);
return;
};
if (evt.key == 'space')
{
this._processKeyAction('keydown', evt);
};
if (this._currentAction == null) return;
var moveKey = (!evt.dom.ctrlKey && (evt.key == 'left' || evt.key == 'right' || evt.key == 'up' || evt.key == 'down'));
if (focusedObject && moveKey)
{
var x = focusedObject.x,
y = focusedObject.y;
var moveSize = evt.dom.shiftKey ? 1 : 10;
if (evt.key == 'left') focusedObject.moveLeft(moveSize);
if (evt.key == 'right') focusedObject.moveRight(moveSize);
if (evt.key == 'up') focusedObject.moveUp(moveSize);
if (evt.key == 'down') focusedObject.moveDown(moveSize);
}
};
Grid.Canvas.prototype._processKeyAction = function(name, evt)
{
var mode = this.grid.getMode();
if (this._currentAction == null) this.startAction();
try
{
this._currentAction.onKeyEvent(evt);
}
catch(ex)
{
this._currentAction.finalize();
this._currentAction = null;
throw ex;
}
if (this._currentAction.isCompleted())
{
this._currentAction = null;
logger.debug('Action - {mode} completed', { mode: mode });
}
};
Grid.Canvas.prototype._firstObjectInFocusableOrder = function(positions)
{
var firstPosition = null;
for (var i = 0; i < positions.length; i++)
{
var existingPosition = positions[i];
if (firstPosition == null)
{
firstPosition = existingPosition;
}
else if (existingPosition.y < firstPosition.y || (existingPosition.y == firstPosition.y && existingPosition.x < firstPosition.x))
{
firstPosition = existingPosition;
}
}
return firstPosition;
};
Grid.Canvas.prototype._nextObjectInFocusableOrder = function(currentPosition, positions)
{
if (currentPosition == null) return this._firstObjectInFocusableOrder(positions);
var nextPosition = null;
for (var i = 0; i < positions.length; i++)
{
var existingPosition = positions[i];
if (existingPosition.y < currentPosition.y || (existingPosition.y == currentPosition.y && existingPosition.x <= currentPosition.x))
{
continue;
}
if (nextPosition == null)
{
nextPosition = existingPosition;
}
else if (existingPosition.y < nextPosition.y || (existingPosition.y == nextPosition.y && existingPosition.x < nextPosition.x))
{
nextPosition = existingPosition;
}
}
if (nextPosition == null) nextPosition = this._firstObjectInFocusableOrder(positions);
return nextPosition;
};
Grid.Canvas.prototype.reorderImages = function()
{
var imageSorter = function(imageA, imageB)
{
var sizeA = imageA.getSize();
var sizeB = imageB.getSize();
return sizeA > sizeB ? -1 : sizeA < sizeB ? 1 : 0;
};
var images = this.model.getImages();
images.sort(imageSorter);
for (var i = 0; i < images.length; i++)
{
var image = images[i];
this.view.bringToFront(image.getID());
}
};
Grid.Canvas.prototype.subscribeToModelEvents = function()
{
var canvas = this;
var view = this.view;
this.model.subscribe('onAdd', function(entity)
{
entity.createElement(view);
entity.updateElement(view);
if (entity instanceof Grid.Model.Point) canvas.setFocused(entity);
if (entity instanceof Grid.Model.Image) canvas.reorderImages();
});
this.model.subscribe('onDelete', function(entity)
{
canvas.clearHovering();
canvas.clearFocused(entity);
entity.removeElement(view);
});
this.model.subscribe('onMove', function(entity) { entity.moveElement(view); });
this.model.subscribe('onUpdate', function(entity) { entity.updateElement(view); });
};

// FILE: importexport.js (d0daf786) 3/7/2014 11:24:06 AM

Grid.ImportExport = function(gquestion)
{
var gridquestion = gquestion;
var answerSpaceXml;
this.isStudentResponseValid = function()
{
if (answerSpaceXml == null) return false;
var xmlobject = Grid.ImportExport.parseFromString(answerSpaceXml);
var originalquestion = new Grid.Model();
originalquestion._paletteimages = gridquestion._paletteimages;
var imageLoader = new Grid.ImportExport.ImageLoader();
Grid.ImportExport.loadHotspots(xmlobject, originalquestion, imageLoader);
var presetAnswerList = xmlobject.getElementsByTagName("PreSetAnswerPart");
if ((presetAnswerList) && (presetAnswerList[0]) && (presetAnswerList[0].childNodes[0]))
{
var presetAnswerXml = Grid.ImportExport.serializeToString(presetAnswerList[0]);
this.loadAnswer(presetAnswerXml, originalquestion);
}
if (!pointsEqual(originalquestion.getPoints(), gridquestion.getPoints())) return true;
if (!edgesEqual(originalquestion.getLines(), gridquestion.getLines())) return true;
if (!imagesEqual(originalquestion.getImages(), gridquestion.getImages())) return true;
if (!arrowEqual(originalquestion.getLinesByDir("forward"), gridquestion.getLinesByDir("forward"))) return true;
if (!doubleArrowEqual(originalquestion.getLinesByDir("both"), gridquestion.getLinesByDir("both"))) return true;
var regions = gridquestion.getRegions();
for (var i = 0; i < regions.length; i++)
{
var originalRegion = originalquestion.getRegion(regions[i].name);
if (originalRegion) {
if (regions[i].isSelected() != originalRegion.isSelected()) return true;
}
}
return false;
function pointsEqual(points1, points2)
{
if (points1.length != points2.length) return false;
if (points1.length == 0) return true;
for (var i = 0; i < points1.length; i++)
{
var found = false;
for (var j = 0; j < points2.length; j++)
{
if ((points1[i].x == points2[j].x) && (points1[i].y == points2[j].y)) found = true;
}
if (!found) return false;
}
return true;
}
function edgesEqual(edges1, edges2)
{
if (edges1.length != edges2.length) return false;
if (edges1.length == 0) return true;
for (var i = 0; i < edges1.length; i++)
{
var found = false;
for (var j = 0; j < edges2.length; j++)
{
if (((edges1[i].source.x == edges2[j].source.x) && (edges1[i].source.y == edges2[j].source.y)
&& (edges1[i].target.x == edges2[j].target.x) && (edges1[i].target.y == edges2[j].target.y)) ||
((edges1[i].source.x == edges2[j].target.x) && (edges1[i].source.y == edges2[j].target.y)
&& (edges1[i].target.x == edges2[j].source.x) && (edges1[i].target.y == edges2[j].source.y))
) found = true;
}
if (!found) return false;
}
return true;
}
function imagesEqual(images1, images2)
{
if (images1.length != images2.length) return false;
if (images1.length == 0) return true;
for (var i = 0; i < images1.length; i++)
{
var found = false;
for (var j = 0; j < images2.length; j++)
{
if ((images1[i].name == images2[j].name) && (images1[i].x == images2[j].x)
&& (images1[i].y == images2[j].y)) found = true;
}
if (!found) return false;
}
return true;
}
function arrowEqual(arrows1, arrows2)
{
if (arrows1.length != arrows2.length) return false;
if (arrows1.length == 0) return true;
for (var i = 0; i < arrows1.length; i++)
{
var found = false;
for (var j = 0; j < arrows2.length; j++)
{
if (((arrows1[i].source.x == arrows2[j].source.x) && (arrows1[i].source.y == arrows2[j].source.y)
&& (arrows1[i].target.x == arrows2[j].target.x) && (arrows1[i].target.y == arrows2[j].target.y)))
found = true;
}
if (!found) return false;
}
return true;
}
function doubleArrowEqual(da1, da2)
{
return edgesEqual(da1, da2);
}
};
this.getAnswerXml = function()
{
function getSnapPoints(xmlDoc, QuestionPartNode)
{
var SnapPointNode = xmlDoc.createElement('SnapPoint');
var snapPoints = gridquestion.getSnapPoints();
var str = "";
for (var i = 0; i < snapPoints.length; i++)
{
if (i == 0) str = snapPoints[0].snapRadius + "@";
str += snapPoints[i].x + "," + snapPoints[i].y;
if (i != snapPoints.length - 1) str += ";";
}
var textNode = xmlDoc.createTextNode(str);
SnapPointNode.appendChild(textNode);
QuestionPartNode.appendChild(SnapPointNode);
}
function getTerminatedEdgeObjects(xmlDoc, ObjectSetNode)
{
var arrows = gridquestion.getLinesByDir("forward");
for (var i = 0; i < arrows.length; i++)
{
var tNode = xmlDoc.createElement('TerminatedEdgeObject');
var sourceXY = arrows[i].source.x + ',' + translateCoordinate(arrows[i].source.y);
var targetXY = arrows[i].target.x + ',' + translateCoordinate(arrows[i].target.y);
var str = "(" + sourceXY + "),(" + targetXY + "),Type-1";
var textNode = xmlDoc.createTextNode(str);
tNode.appendChild(textNode);
ObjectSetNode.appendChild(tNode);
}
var doubleArrows = gridquestion.getLinesByDir("both");
for (var i = 0; i < doubleArrows.length; i++)
{
var tNode = xmlDoc.createElement('TerminatedEdgeObject');
var sourceXY = doubleArrows[i].source.x + ',' + translateCoordinate(doubleArrows[i].source.y);
var targetXY = doubleArrows[i].target.x + ',' + translateCoordinate(doubleArrows[i].target.y);
var str = "(" + sourceXY + "),(" + targetXY + "),Type-2";
var textNode = xmlDoc.createTextNode(str);
tNode.appendChild(textNode);
ObjectSetNode.appendChild(tNode);
}
}
function createAtomicObject(xmlDoc, ObjectSetNode)
{
var images = gridquestion.getImages();
for (var i = 0; i < images.length; i++)
{
var AtomicObjectNode = xmlDoc.createElement('AtomicObject');
var pointXY = images[i].x + "," + translateCoordinate(images[i].y);
var str = "{" + images[i].name + "(" + pointXY + ")}";
var TextNode = xmlDoc.createTextNode(str);
AtomicObjectNode.appendChild(TextNode);
ObjectSetNode.appendChild(AtomicObjectNode);
}
}
function createRegionGroupObjects(xmlDoc, ObjectSetNode)
{
var regionGroupsList = gridquestion.getRegionGroups();
for (var i = 0; i < regionGroupsList.length; i++)
{
var regionGroupObj = regionGroupsList[i];
var regionGroupNode = xmlDoc.createElement('RegionGroupObject');
regionGroupNode.setAttribute('name', regionGroupObj.name);
regionGroupNode.setAttribute('numselected', regionGroupObj.getSelectedRegions().length);
var regionsList = regionGroupObj.getRegions();
for (var j = 0; j < regionsList.length; j++)
{
var regionObj = regionsList[j];
var regionNode = xmlDoc.createElement('RegionObject');
regionNode.setAttribute('name', regionObj.name);
regionNode.setAttribute('isselected', regionObj.isSelected().toString());
regionGroupNode.appendChild(regionNode);
}
ObjectSetNode.appendChild(regionGroupNode);
}
}
function createPointObject(xmlDoc, ObjectSetNode, points)
{
if (!(points)) return;
for (var i = 0; i < points.length; i++)
{
var ObjectNode = xmlDoc.createElement('Object');
var PointVectorNode = xmlDoc.createElement('PointVector');
var EdgeVectorNode = xmlDoc.createElement('EdgeVector');
var LabelListNode = xmlDoc.createElement('LabelList');
var ValueListNode = xmlDoc.createElement('ValueList');
var pointStr = "{(" + points[i].x + ',' + translateCoordinate(points[i].y) + ")}";
var PointTextNode = xmlDoc.createTextNode(pointStr);
PointVectorNode.appendChild(PointTextNode);
var edgeStr = " {} ";
var EdgeTextNode = xmlDoc.createTextNode(edgeStr);
EdgeVectorNode.appendChild(EdgeTextNode);
var labelStr = " {} ";
var LabelTextNode = xmlDoc.createTextNode(labelStr);
LabelListNode.appendChild(LabelTextNode);
var valueStr = " {} ";
var ValueTextNode = xmlDoc.createTextNode(valueStr);
ValueListNode.appendChild(ValueTextNode);
ObjectNode.appendChild(PointVectorNode);
ObjectNode.appendChild(EdgeVectorNode);
ObjectNode.appendChild(LabelListNode);
ObjectNode.appendChild(ValueListNode);
ObjectSetNode.appendChild(ObjectNode);
}
}
function createConnectedLinesObj(xmlDoc, ObjectSetNode, thisWorkingLines)
{
var ObjectNode = xmlDoc.createElement('Object');
var PointVectorNode = xmlDoc.createElement('PointVector');
var EdgeVectorNode = xmlDoc.createElement('EdgeVector');
var LabelListNode = xmlDoc.createElement('LabelList');
var ValueListNode = xmlDoc.createElement('ValueList');
var pointsStr = "{";
var linesStr = "{";
var previousLeftPoint = "";
var linePoints = [];
for (var i = 0; i < thisWorkingLines.length; i++)
{
var sourceXY = thisWorkingLines[i].source.x + ',' + translateCoordinate(thisWorkingLines[i].source.y);
var targetXY = thisWorkingLines[i].target.x + ',' + translateCoordinate(thisWorkingLines[i].target.y);
linesStr += " {(" + sourceXY + '),(' + targetXY + ")}";
if (i == 0)
{
linePoints.push(sourceXY);
linePoints.push(targetXY);
} else
{
if (!findExistingItem(linePoints, sourceXY)) linePoints.push(sourceXY);
if (!findExistingItem(linePoints, targetXY)) linePoints.push(targetXY);
}
}
for (var i = 0; i < linePoints.length; i++)
{
pointsStr += "(" + linePoints[i] + ")";
}
pointsStr += "}";
var PointVectorTextNode = xmlDoc.createTextNode(pointsStr);
PointVectorNode.appendChild(PointVectorTextNode);
linesStr += "}";
var EdgeVectorTextNode = xmlDoc.createTextNode(linesStr);
EdgeVectorNode.appendChild(EdgeVectorTextNode);
var labelStr = " {} ";
var LabelTextNode = xmlDoc.createTextNode(labelStr);
LabelListNode.appendChild(LabelTextNode);
var valueStr = " {} ";
var ValueTextNode = xmlDoc.createTextNode(valueStr);
ValueListNode.appendChild(ValueTextNode);
ObjectNode.appendChild(PointVectorNode);
ObjectNode.appendChild(EdgeVectorNode);
ObjectNode.appendChild(LabelListNode);
ObjectNode.appendChild(ValueListNode);
ObjectSetNode.appendChild(ObjectNode);
}
function findExistingItem(array, item)
{
for (var i = 0; i < array.length; i++)
{
if (item == array[i]) return true;
}
return false;
}
function addLinePointsToQueue(pointQueue, line)
{
var rtnPointQueue = pointQueue;
if (!pointExistsInQueue(pointQueue, line.source)) rtnPointQueue.push(line.source);
if (!pointExistsInQueue(pointQueue, line.target)) rtnPointQueue.push(line.target);
return rtnPointQueue;
}
function pointExistsInQueue(pointQueue, point)
{
for (var i = 0; i < pointQueue.length; i++)
{
if (point == pointQueue[i]) return true;
}
return false;
}
function getNewLinesConnectedToPoint(remainingLines, workingLines, pointQueue, point)
{
var newLines = [];
for (var i = 0; i < remainingLines.length; i++)
{
if ((remainingLines[i].source == point) || (remainingLines[i].target == point))
{
var found = false;
for (var j = 0; j < workingLines.length; j++)
{
if (workingLines[j] == remainingLines[i])
{
found = true;
break;
}
}
if (!found) newLines.push(remainingLines[i]);
}
}
return newLines;
}
function getRemainingLines(remainingLines, thisWorkingLines)
{
var rLines = [];
for (var i = 0; i < remainingLines.length; i++)
{
var found = false;
for (var j = 0; j < thisWorkingLines.length; j++)
{
if (remainingLines[i] == thisWorkingLines[j])
{
found = true;
break;
}
}
if (!found) rLines.push(remainingLines[i]);
}
return rLines;
}
function identifyObjects(xmlDoc, ObjectSetNode)
{
var lines = gridquestion.getLinesByDir("none");
var points = gridquestion.getPoints();
var remainingLines = gridquestion.getLinesByDir("none");
while (remainingLines.length > 0)
{
var thisWorkingLines = [];
var thisPointQueue = [];
thisWorkingLines.push(remainingLines[0]);
var newQueue = addLinePointsToQueue(thisPointQueue, remainingLines[0]);
thisPointQueue = newQueue;
while ((thisPointQueue) && (thisPointQueue.length > 0))
{
var newPoint = thisPointQueue.shift();
var newLines = getNewLinesConnectedToPoint(remainingLines, thisWorkingLines, thisPointQueue, newPoint);
if (newLines)
{
for (var i = 0; i < newLines.length; i++)
{
thisWorkingLines.push(newLines[i]);
addLinePointsToQueue(thisPointQueue, newLines[i]);
}
}
}
var rLines = getRemainingLines(remainingLines, thisWorkingLines);
remainingLines = rLines;
if (thisWorkingLines.length > 0)
{
createConnectedLinesObj(xmlDoc, ObjectSetNode, thisWorkingLines);
}
}
var iPoints = getIsolatedPoints();
if (iPoints.length > 0) createPointObject(xmlDoc, ObjectSetNode, iPoints);
createAtomicObject(xmlDoc, ObjectSetNode);
createRegionGroupObjects(xmlDoc, ObjectSetNode);
}
function getIsolatedPoints()
{
var lines = gridquestion.getLines();
var points = gridquestion.getPoints();
var iPoints = [];
for (var i = 0; i < points.length; i++)
{
var found = false;
for (var j = 0; j < lines.length; j++)
{
if ((points[i] == lines[j].source) || (points[i] == lines[j].target))
{
found = true;
break;
}
}
if (!found) iPoints.push(points[i]);
}
return iPoints;
}
function getIndent(depth)
{
var str = "";
for (var i = 0; i < depth * 3; i++)
{
str += " ";
}
return str;
}
function getIndentedText(xNode, depth)
{
var alignedText = '';
if (xNode.nodeType == 3)
{
if (xNode.nodeValue)
return (alignedText + xNode.nodeValue);
else
return (alignedText);
}
alignedText = getIndent(depth) + '<' + xNode.nodeName + '>';
var length = alignedText.length;
for (var i = 0; i < xNode.childNodes.length; i++)
{
if (xNode.childNodes[i].nodeType == 3)
alignedText += getIndentedText(xNode.childNodes[i], depth + 1);
else
alignedText += '\n' + getIndentedText(xNode.childNodes[i], depth + 1);
}
var trimedText = alignedText.replace(/^\s+|\s+$/g, "");
if ((trimedText.charAt(trimedText.length - 1) == '}') || (xNode.nodeName == 'TerminatedEdgeObject') || (alignedText.length == length))
{
return (alignedText + '</' + xNode.nodeName + '>');
} else
{
return (alignedText + '\n' + getIndent(depth) + '</' + xNode.nodeName + '>');
}
}
var xmlDoc = Grid.ImportExport.parseFromString("<root></root>");
var AnswerSetNode = xmlDoc.createElement('AnswerSet');
var QuestionNode = xmlDoc.createElement('Question');
QuestionNode.setAttribute('id', gridquestion.id);
AnswerSetNode.appendChild(QuestionNode);
var QuestionPartNode = xmlDoc.createElement('QuestionPart');
QuestionPartNode.setAttribute('id', 1);
QuestionNode.appendChild(QuestionPartNode);
var ObjectSetNode = xmlDoc.createElement('ObjectSet');
QuestionPartNode.appendChild(ObjectSetNode);
identifyObjects(xmlDoc, ObjectSetNode);
var TerminatedEdgeObjectNode = xmlDoc.createElement('TerminatedEdgeObject');
getTerminatedEdgeObjects(xmlDoc, ObjectSetNode);
getSnapPoints(xmlDoc, QuestionPartNode);
Grid.ImportExport.writeShapes(QuestionPartNode, gridquestion);
var currentTime = new Date();
var month = currentTime.getMonth() + 1;
var day = currentTime.getDate();
var year = currentTime.getFullYear() + '';
var hours = currentTime.getHours();
var minutes = currentTime.getMinutes();
var APM = 'AM';
if (hours > 11) APM = 'PM';
var timeInfo = month + '/' + day + '/' + year.substring(2, 4) + '  ' + hours + ':' + minutes + ' ' + APM;
var header =
'<?xml version="1.0" encoding="UTF-8"?>\n' +
'<!-- MACHINE GENERATED ' + timeInfo + '. DO NOT EDIT -->\n' +
'<!DOCTYPE AnswerSet [\n' +
'<!ELEMENT AnswerSet (Question+)>\n' +
'<!ELEMENT AtomicObject (#PCDATA)>\n' +
'<!ELEMENT EdgeVector (#PCDATA)>\n' +
'<!ELEMENT GridImageTestPoints (TestPoint*)>\n' +
'<!ELEMENT LabelList (#PCDATA)>\n' +
'<!ELEMENT Object (PointVector,EdgeVector,LabelList,ValueList)>\n' +
'<!ELEMENT ObjectSet (Object,AtomicObject+)>\n' +
'<!ELEMENT PointVector (#PCDATA)>\n' +
'<!ELEMENT Question (QuestionPart)>\n' +
'<!ATTLIST Question id NMTOKEN #REQUIRED>\n' +
'<!ELEMENT QuestionPart (LabelList,GridImageTestPoints,ObjectSet)>\n' +
'<!ATTLIST QuestionPart id NMTOKEN #REQUIRED>\n' +
'<!ELEMENT TestPoint (#PCDATA)>\n' +
'<!ELEMENT ValueList (#PCDATA)>\n' +
']>\n';
if (typeof XMLSerializer != 'undefined')
{
var serializer = new XMLSerializer();
var answerXml = serializer.serializeToString(AnswerSetNode);
return (header + answerXml);
}
else if (AnswerSetNode.xml)
{
return (header + AnswerSetNode.xml);
}
else
{
throw Error('This browser does not support serializing XML nodes');
}
};
var parseImageFiles = function(questionXml)
{
var getTextContent = function(node)
{
if (node && node.childNodes && node.childNodes.length)
return node.childNodes[0].nodeValue;
return null;
};
var imageFiles = [];
var xmlDoc = Grid.ImportExport.parseFromString(questionXml);
var imageNodes = xmlDoc.getElementsByTagName('FileSpec');
Grid.ImportExport.eachNode(imageNodes, function(imageNode)
{
var imageFile = getTextContent(imageNode);
if (imageFiles.indexOf(imageFile) == -1) imageFiles.push(imageFile);
});
imageNodes = xmlDoc.getElementsByTagName('Image');
Grid.ImportExport.eachNode(imageNodes, function(imageNode)
{
var imageFile = imageNode.getAttribute('src');
if (imageFiles.indexOf(imageFile) == -1) imageFiles.push(imageFile);
});
return imageFiles;
};
this.loadItem = function(questionXml, callbackCreated, callbackFailure)
{
var imageFiles = parseImageFiles(questionXml);
var imageLoader = new Grid.ImportExport.ImageLoader();
if (imageFiles.length == 0)
{
this.loadItem2(questionXml, callbackCreated, imageLoader);
return;
}
for (var i = 0; i < imageFiles.length; i++)
{
var url = Grid.ImportExport.resolveUrl(imageFiles[i]);
imageLoader.addImage(url);
}
var self = this;
imageLoader.load(function()
{
var imageErrors = imageLoader.getErrors();
if (imageErrors.length == 0)
{
self.loadItem2.call(self, questionXml, callbackCreated, imageLoader);
}
else
{
callbackFailure('Error loading DOM images', imageErrors);
}
});
};
this.loadItem2 = function(questionXml, callback, imageLoader)
{
answerSpaceXml = questionXml;
function removeQuotes(str)
{
var first = str.indexOf('"');
if (first == -1) return str;
str = str.substring(first + 1);
var second = str.lastIndexOf('"');
if (second == -1) return str;
return str.substring(0, second);
}
function addBackgroundImage(bkgNode)
{
var node = bkgNode.firstChild;
var fileSpec = "";
var position = "";
while (node)
{
if (node.nodeName == "FileSpec")
{
fileSpec = removeQuotes(node.childNodes[0].nodeValue);
}
else if (node.nodeName == "Position")
{
position = removeQuotes(node.childNodes[0].nodeValue);
}
if ((fileSpec != "") && (position != ""))
{
var xy = position.split(',');
var url = Grid.ImportExport.resolveUrl(fileSpec);
var htmlImage = imageLoader.getImage(url);
if (htmlImage != null)
{
gridquestion.addBackgroundImage(htmlImage.src, xy[0] * 1, xy[1] * 1, htmlImage.width, htmlImage.height);
}
return;
}
node = node.nextSibling;
}
}
function addPalleteImage(palleteNode)
{
var node = palleteNode.firstChild;
var labelName = "";
var fileName = "";
while (node)
{
if (node.nodeName == "FileSpec")
{
fileName = removeQuotes(node.childNodes[0].nodeValue);
}
else if (node.nodeName == "Label")
{
labelName = removeQuotes(node.childNodes[0].nodeValue);
labelName = YAHOO.lang.trim(labelName);
}
if ((fileName != "") && (labelName != ""))
{
var url = Grid.ImportExport.resolveUrl(fileName);
var htmlImage = imageLoader.getImage(url);
if (htmlImage != null)
{
gridquestion.addPaletteImage(labelName, htmlImage.src, htmlImage.width, htmlImage.height);
}
return;
}
node = node.nextSibling;
}
}
gridquestion.clearQuestion();
var xmlobject = Grid.ImportExport.parseFromString(questionXml);
Grid.ImportExport.loadOptions(xmlobject, gridquestion);
var backgroundImageList = xmlobject.getElementsByTagName("ImageSpec");
if ((backgroundImageList) && (backgroundImageList[0]) && (backgroundImageList[0].childNodes[0]))
{
for (var i = 0; i < backgroundImageList.length; i++)
{
addBackgroundImage(backgroundImageList[i]);
}
}
var palleteImageList = xmlobject.getElementsByTagName("IconSpec");
if ((palleteImageList) && (palleteImageList[0]) && (palleteImageList[0].childNodes[0]))
{
for (var i = 0; i < palleteImageList.length; i++)
{
addPalleteImage(palleteImageList[i]);
}
}
Grid.ImportExport.loadHotspots(xmlobject, gridquestion, imageLoader);
var presetAnswerList = xmlobject.getElementsByTagName("PreSetAnswerPart");
if ((presetAnswerList) && (presetAnswerList[0]) && (presetAnswerList[0].childNodes[0]))
{
this.loadAnswer(Grid.ImportExport.serializeToString(presetAnswerList[0]));
}
if (gridquestion.getPaletteImages().length > 0 &&
gridquestion.getPoints().length == 0 &&
gridquestion.getImages().length == 0) {
gridquestion.options.showPalette = true;
} else {
gridquestion.options.showPalette = false;
}
if (typeof callback == 'function') callback();
};
this.loadAnswer = function(response, gridq)
{
function addSnapPoint(snapPoint, gridq)
{
if (snapPoint.childNodes.length == 0) return;
var snapStr = snapPoint.childNodes[0].nodeValue;
var first = snapStr.indexOf("@");
var snapRadius = parseInt(snapStr.substring(0, first));
snapStr = snapStr.substring(first + 1) + ";";
var index = snapStr.indexOf(";");
while (index != -1)
{
var pntStr = snapStr.substring(0, index);
var indexComma = pntStr.indexOf(",");
var x = parseInt(pntStr.substring(0, indexComma));
var y = parseInt(pntStr.substring(indexComma + 1));
if (gridq == null) gridquestion.addSnapPoint(x, y, snapRadius);
else gridq.addSnapPoint(x, y, snapRadius);
snapStr = snapStr.substring(index + 1);
index = snapStr.indexOf(";");
}
}
function addAtomicObj(obj, gridq)
{
var atomicStr = obj.childNodes[0].nodeValue;
var first = atomicStr.indexOf("{");
var second = atomicStr.indexOf("(");
var third = atomicStr.indexOf(")");
var labelName = atomicStr.substring(first + 1, second);
var pntStr = atomicStr.substring(second + 1, third);
var indexComma = pntStr.indexOf(",");
var x = parseInt(pntStr.substring(0, indexComma));
var y = parseInt(pntStr.substring(indexComma + 1));
if (gridq == null)
gridquestion.addImage(YAHOO.lang.trim(labelName), x, translateCoordinate(y));
else
gridq.addImage(YAHOO.lang.trim(labelName), x, translateCoordinate(y));
}
function addTerminatedEdgeObj(obj, gridq)
{
var arrowStr = obj.childNodes[0].nodeValue;
var index = arrowStr.indexOf(",Type-");
var type = arrowStr.substring(index + 6);
var dirType = "both";
if (type == "1") dirType = "forward";
parseSingleLine(arrowStr.substring(0, index), dirType, gridq);
}
function addObj(obj, gridq)
{
var node = obj.firstChild;
while (node)
{
if (node.nodeName == "PointVector")
{
parsePointVectorString(node.childNodes[0].nodeValue, gridq);
}
else if (node.nodeName == "EdgeVector")
{
parseEdgeVectorString(node.childNodes[0].nodeValue, gridq);
}
node = node.nextSibling;
}
}
function parsePointVectorString(pointsStr, gridq)
{
var indexLeft = pointsStr.indexOf("(");
var indexRight = pointsStr.indexOf(")");
while ((indexLeft != -1) && (indexRight != -1))
{
var pntStr = pointsStr.substring(indexLeft + 1, indexRight);
pointsStr = pointsStr.substring(indexRight + 1);
var indexComma = pntStr.indexOf(",");
var x = parseInt(pntStr.substring(0, indexComma));
var y = parseInt(pntStr.substring(indexComma + 1));
if (gridq == null)
gridquestion.addPoint(x, translateCoordinate(y));
else
{
gridq.addPoint(x, translateCoordinate(y));
}
indexLeft = pointsStr.indexOf("(");
indexRight = pointsStr.indexOf(")");
}
}
function parseEdgeVectorString(edgesStr, gridq)
{
var firstLeft = edgesStr.indexOf("{");
var lastRight = edgesStr.lastIndexOf("}");
edgesStr = edgesStr.substring(firstLeft + 1, lastRight);
var indexLeft = edgesStr.indexOf("{");
var indexRight = edgesStr.indexOf("}");
while ((indexLeft != -1) && (indexRight != -1))
{
var eStr = edgesStr.substring(indexLeft + 1, indexRight);
parseSingleLine(eStr, "none", gridq);
edgesStr = edgesStr.substring(indexRight + 1);
indexLeft = edgesStr.indexOf("{");
indexRight = edgesStr.indexOf("}");
}
}
function parseSingleLine(eStr, dirType, gridq)
{
var indexLeft = eStr.indexOf("(");
var indexRight = eStr.indexOf(")");
var pntStr = eStr.substring(indexLeft + 1, indexRight);
var indexComma = pntStr.indexOf(",");
var x = parseInt(pntStr.substring(0, indexComma));
var y = parseInt(pntStr.substring(indexComma + 1));
var point1;
if (gridq == null)
{
if (dirType != "none")
point1 = gridquestion.addPoint(x, translateCoordinate(y));
else
point1 = getExistingPoint(x, translateCoordinate(y), gridq);
} else
{
if (dirType != "none")
point1 = gridq.addPoint(x, translateCoordinate(y));
else
point1 = getExistingPoint(x, translateCoordinate(y), gridq);
}
pntStr = eStr.substring(indexRight + 1);
indexLeft = pntStr.indexOf("(");
indexRight = pntStr.indexOf(")");
pntStr = pntStr.substring(indexLeft + 1, indexRight);
indexComma = pntStr.indexOf(",");
x = parseInt(pntStr.substring(0, indexComma));
y = parseInt(pntStr.substring(indexComma + 1));
var point2;
if (gridq == null)
{
if (dirType != "none")
point2 = gridquestion.addPoint(x, translateCoordinate(y));
else
point2 = getExistingPoint(x, translateCoordinate(y), gridq);
if ((point1) && (point2))
{
gridquestion.addLine(point1, point2, dirType);
}
}
else
{
if (dirType != "none")
point2 = gridq.addPoint(x, translateCoordinate(y));
else
point2 = getExistingPoint(x, translateCoordinate(y), gridq);
if ((point1) && (point2))
{
gridq.addLine(point1, point2, dirType);
}
}
}
function getExistingPoint(x, y, gridq)
{
var points;
if (gridq == null)
points = gridquestion.getPoints();
else
points = gridq.getPoints();
for (var i = 0; i < points.length; i++)
{
if ((points[i].x == x) && (points[i].y == y))
return points[i];
}
return null;
}
if (gridq == null) gridquestion.clearResponse();
else gridq.clearResponse();
var xmlobject = Grid.ImportExport.parseFromString(response);
var objectList = xmlobject.getElementsByTagName("Object");
if ((objectList) && (objectList[0]) && (objectList[0].childNodes[0]))
{
for (var i = 0; i < objectList.length; i++)
{
addObj(objectList[i], gridq);
}
}
var atomicObjList = xmlobject.getElementsByTagName("AtomicObject");
if ((atomicObjList) && (atomicObjList[0]) && (atomicObjList[0].childNodes[0]))
{
for (var i = 0; i < atomicObjList.length; i++)
{
addAtomicObj(atomicObjList[i], gridq);
}
}
var terminatedEdgeList = xmlobject.getElementsByTagName("TerminatedEdgeObject");
if ((terminatedEdgeList) && (terminatedEdgeList[0]) && (terminatedEdgeList[0].childNodes[0]))
{
for (var i = 0; i < terminatedEdgeList.length; i++)
{
addTerminatedEdgeObj(terminatedEdgeList[i], gridq);
}
}
var snapPointList = xmlobject.getElementsByTagName("SnapPoint");
if ((snapPointList) && (snapPointList[0]) && (snapPointList[0].childNodes[0]))
{
for (var i = 0; i < snapPointList.length; i++)
{
addSnapPoint(snapPointList[i], gridq);
}
}
var model = ((gridq != null) ? gridq : gridquestion);
Grid.ImportExport.loadRegionGroupObjects(xmlobject, model);
Grid.ImportExport.loadShapes(xmlobject, model);
if (gridq == null) gridquestion.importing = true;
};
function translateCoordinate(y)
{
return (gridquestion.options.canvasHeight - y);
}
};
Grid.ImportExport.parseFromString = function(text)
{
var xmlDoc;
if (window.DOMParser) {
xmlDoc = (new window.DOMParser()).parseFromString(text, "text/xml");
} else {
xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
xmlDoc.async = "false";
xmlDoc.validateOnParse = "false";
xmlDoc.loadXML(text);
}
var errorMsg = null;
if (xmlDoc.parseError && xmlDoc.parseError.errorCode != 0) {
errorMsg = "XML Parsing Error: " + xmlDoc.parseError.reason
+ " at line " + xmlDoc.parseError.line
+ " at position " + xmlDoc.parseError.linepos;
} else {
if (xmlDoc.documentElement) {
if (xmlDoc.documentElement.nodeName == "parsererror") {
errorMsg = xmlDoc.documentElement.childNodes[0].nodeValue;
}
} else {
errorMsg = "XML Parsing Error";
}
}
if (errorMsg) {
throw new Error(errorMsg);
}
return xmlDoc;
};
Grid.ImportExport.serializeToString = function(node)
{
return node.xml || (new XMLSerializer()).serializeToString(node);
};
Grid.ImportExport.eachNode = function(nodeList, func)
{
var nodes = [];
for (var i = 0; i < nodeList.length; i++)
{
var node = nodeList[i] || nodeList.item(i);
nodes.push(node);
}
YAHOO.util.Dom.batch(nodes, func);
};
Grid.ImportExport.resolveUrl = function(url)
{
url = url.replace(/&amp;/g, '&');
url = url.split('&').join('&amp;').split('<').join('&lt;').split('"').join('&quot;');
var el = document.createElement('div');
el.innerHTML = '<a href="' + url + '">x</a>';
return el.firstChild.href;
};
Grid.ImportExport.getFilename = function(path)
{
return path.substr(path.lastIndexOf('/') + 1);
};
Grid.ImportExport.ImageLoader = function()
{
this._requests = [];
this._completedCount = 0;
this._completedCallback = null;
this.getRequests = function() { return this._requests; };
this.addImage = function(url, callback, label)
{
var request = { url: url, callback: callback, image: null, label: label };
this._requests.push(request);
};
this.getImage = function(url)
{
for (var i = 0; i < this._requests.length; i++)
{
var request = this._requests[i];
if (request.url == url) return request.image;
}
return null;
};
this.isCompleted = function()
{
return (this._completedCount == this._requests.length);
};
this.getErrors = function()
{
var imageErrors = [];
for (var i = 0; i < this._requests.length; i++)
{
var request = this._requests[i];
if (request.image.state != 1)
{
imageErrors.push(request.image);
}
}
return imageErrors;
};
this.load = function(callback)
{
this._completedCallback = callback;
for (var i = 0; i < this._requests.length; i++)
{
var request = this._requests[i];
this._requestImage(request);
}
};
this._requestImage = function(request)
{
var self = this;
request.image = new Image();
request.image.state = 0;
request.image.name = request.label;
var completed = function()
{
if (typeof (request.callback) == 'function')
{
request.callback(request.image);
}
self._requestCompleted();
};
request.image.onload = function()
{
request.image.state = 1;
completed();
};
request.image.onerror = function()
{
request.image.state = -1;
completed();
};
request.image.onabort = function()
{
request.image.state = -1;
completed();
};
request.image.src = request.url;
};
this._requestCompleted = function()
{
this._completedCount++;
if (this._completedCount == this._requests.length && typeof (this._completedCallback) == 'function')
{
var images = [];
for (var i = 0; i < this._requests.length; i++)
{
images.push(this._requests[i].image);
}
this._completedCallback(images);
}
};
};
String.prototype.startsWith = function(str)
{return (this.match("^"+str)==str);
};

// FILE: importexport.options.js (0a545402) 3/7/2014 11:24:06 AM

Grid.ImportExport.removeQuotes = function(str) {
var first = str.indexOf('"');
if (first == -1) return str;
str = str.substring(first + 1);
var second = str.lastIndexOf('"');
if (second == -1) return str;
return str.substring(0, second);
};
Grid.ImportExport.hasElementValue = function(xml, id) {
var el = xml.getElementsByTagName(id);
return (el && el[0] && el[0].childNodes[0]);
};
Grid.ImportExport.getElementString = function(xml, id) {
var el = xml.getElementsByTagName(id);
if (el && el[0] && el[0].childNodes[0]) {
return this.removeQuotes(el[0].childNodes[0].nodeValue);
}
return null;
};
Grid.ImportExport.getElementBool = function(xml, id) {
var value = Grid.ImportExport.getElementString(xml, id);
return (value && value === 'true');
};
Grid.ImportExport.getElementInt = function(xml, id) {
var value = Grid.ImportExport.getElementString(xml, id);
return (value) ? parseInt(value) : 0;
};
Grid.ImportExport.loadOptions = function(gridXml, model) {
var options = model.options;
if (this.hasElementValue(gridXml, 'UpdateLayout')) {
options.updateLayout = this.getElementBool(gridXml, 'UpdateLayout');
}
if (this.hasElementValue(gridXml, 'ContainerPaddingTop')) {
options.containerPaddingTop = this.getElementInt(gridXml, 'ContainerPaddingTop');
}
if (this.hasElementValue(gridXml, 'ContainerPaddingRight')) {
options.containerPaddingRight = this.getElementInt(gridXml, 'ContainerPaddingRight');
}
if (this.hasElementValue(gridXml, 'ContainerPaddingBottom')) {
options.containerPaddingBottom = this.getElementInt(gridXml, 'ContainerPaddingBottom');
}
if (this.hasElementValue(gridXml, 'ContainerPaddingLeft')) {
options.containerPaddingLeft = this.getElementInt(gridXml, 'ContainerPaddingLeft');
}
if (this.hasElementValue(gridXml, 'PaletteWidth')) {
options.paletteWidth = this.getElementInt(gridXml, 'PaletteWidth');
}
if (this.hasElementValue(gridXml, 'PaletteGutter')) {
options.paletteGutter = this.getElementInt(gridXml, 'PaletteGutter');
}
var centerImageNode = gridXml.getElementsByTagName("CenterImage");
if ((centerImageNode) && (centerImageNode[0]) && (centerImageNode[0].childNodes[0])) {
options.paletteCenter = (centerImageNode[0].childNodes[0].nodeValue == 'true') ? true : false;
}
var scaleImageNode = gridXml.getElementsByTagName("ScaleImage");
if ((scaleImageNode) && (scaleImageNode[0]) && (scaleImageNode[0].childNodes[0])) {
options.paletteScale = (scaleImageNode[0].childNodes[0].nodeValue == 'true') ? true : false;
}
if (this.hasElementValue(gridXml, 'ShowToolbar')) {
options.showToolbar = this.getElementBool(gridXml, 'ShowToolbar');
}
if (this.hasElementValue(gridXml, 'ToolbarHeight')) {
options.toolbarHeight = this.getElementInt(gridXml, 'ToolbarHeight');
}
if (this.hasElementValue(gridXml, 'ToolbarGutter')) {
options.toolbarGutter = this.getElementInt(gridXml, 'ToolbarGutter');
}
var buttonNode = gridXml.getElementsByTagName("ShowButtons");
if ((buttonNode) && (buttonNode[0]) && (buttonNode[0].childNodes[0]) && (buttonNode[0].childNodes[0].nodeValue)) {
var buttons = this.removeQuotes(buttonNode[0].childNodes[0].nodeValue).split(",");
for (var i = 0; i < buttons.length; i++) {
options.addButton(buttons[i]);
}
}
if (this.hasElementValue(gridXml, 'CanvasWidth')) {
options.canvasWidth = this.getElementInt(gridXml, 'CanvasWidth');
}
if (this.hasElementValue(gridXml, 'CanvasWidthExt')) {
options.canvasWidthExt = this.getElementInt(gridXml, 'CanvasWidthExt');
}
if (this.hasElementValue(gridXml, 'CanvasHeight')) {
options.canvasHeight = this.getElementInt(gridXml, 'CanvasHeight');
}
if (this.hasElementValue(gridXml, 'CanvasHeightExt')) {
options.canvasHeightExt = this.getElementInt(gridXml, 'CanvasHeightExt');
}
if (this.hasElementValue(gridXml, 'CanvasBorderOffset')) {
options.canvasBorderOffset = this.getElementInt(gridXml, 'CanvasBorderOffset');
}
if (this.hasElementValue(gridXml, 'ProperLineGeometry')) {
options.properLineGeometry = this.getElementBool(gridXml, 'ProperLineGeometry');
}
var selectionToleranceNode = gridXml.getElementsByTagName("SelectionTolerance");
if ((selectionToleranceNode) && (selectionToleranceNode[0]) && (selectionToleranceNode[0].childNodes[0])) {
options.selectionTolerance = parseInt(this.removeQuotes(selectionToleranceNode[0].childNodes[0].nodeValue));
}
var gridSpacingNode = gridXml.getElementsByTagName("GridSpacing");
if ((gridSpacingNode) && (gridSpacingNode[0]) && (gridSpacingNode[0].childNodes[0])) {
var spacingStr = gridSpacingNode[0].childNodes[0].nodeValue;
spacingStr = this.removeQuotes(spacingStr.replace(/^\s+|\s+$/g, ""));
var strSplit = spacingStr.split(",");
options.gridSpacing = parseInt(strSplit[0].replace(/^\s+|\s+$/g, ""));
if (strSplit[1].replace(/^\s+|\s+$/g, "") == "Y") options.snapToGrid = true;
else options.snapToGrid = false;
}
var gridColorNode = gridXml.getElementsByTagName("GridColor");
if ((gridColorNode) && (gridColorNode[0]) && (gridColorNode[0].childNodes[0])) {
options.gridColor = this.removeQuotes(gridColorNode[0].childNodes[0].nodeValue);
options.showGridLines = (options.gridColor != 'None');
}
if (this.hasElementValue(gridXml, 'ShowFeedback')) {
options.showFeedback = this.getElementBool(gridXml, 'ShowFeedback');
}
if (this.hasElementValue(gridXml, 'FeedbackHeight')) {
options.feedbackHeight = this.getElementInt(gridXml, 'FeedbackHeight');
}
if (this.hasElementValue(gridXml, 'FeedbackGutter')) {
options.feedbackGutter = this.getElementInt(gridXml, 'FeedbackGutter');
}
};

// FILE: importexport.hotspot.js (80746697) 3/7/2014 11:24:06 AM

Grid.ImportExport.parseRegion = function(regionNode)
{
var region =
{
name: regionNode.getAttribute('name'),
shape: regionNode.getAttribute('shape'),
coords: regionNode.getAttribute('coords'),
events: []
};
var eventNodes = regionNode.getElementsByTagName('Event');
Grid.ImportExport.eachNode(eventNodes, function(eventNode)
{
var regionEvent =
{
name: eventNode.getAttribute('name'),
styles: {},
image: null,
label: null
};
var stylesNode = eventNode.getElementsByTagName('Styles');
if (stylesNode.length == 1)
{
Grid.ImportExport.eachNode(stylesNode[0].attributes, function(styleAttrib)
{
regionEvent.styles[styleAttrib.name] = styleAttrib.value;
});
}
var imageNode = eventNode.getElementsByTagName('Image');
if (imageNode.length == 1)
{
imageNode = imageNode[0];
regionEvent.image =
{
src: imageNode.getAttribute('src'),
x: imageNode.getAttribute('x') * 1,
y: imageNode.getAttribute('y') * 1
};
}
var labelNode = eventNode.getElementsByTagName('Label');
if (labelNode.length == 1)
{
labelNode = labelNode[0];
regionEvent.label =
{
text: labelNode.getAttribute('text'),
x: labelNode.getAttribute('x') * 1,
y: labelNode.getAttribute('y') * 1
};
}
region.events.push(regionEvent);
});
return region;
};
Grid.ImportExport.parseRegionGroup = function(regionGroupNode)
{
var regionGroup =
{
name: regionGroupNode.getAttribute('name'),
min: regionGroupNode.getAttribute('min') * 1,
max: regionGroupNode.getAttribute('max') * 1,
includes: []
};
var regionNodes = regionGroupNode.getElementsByTagName('Region');
Grid.ImportExport.eachNode(regionNodes, function(regionNode)
{
var regionName = regionNode.getAttribute('name');
regionGroup.includes.push(regionName);
});
var includeNodes = regionGroupNode.getElementsByTagName('Include');
Grid.ImportExport.eachNode(includeNodes, function(includeNode)
{
var regionName = includeNode.getAttribute('region');
regionGroup.includes.push(regionName);
});
return regionGroup;
};
Grid.ImportExport.loadHotspots = function(xmlobject, model, imageLoader)
{
var hotspots = { regions: [], groups: [] };
var regionNodes = xmlobject.getElementsByTagName("Region");
Grid.ImportExport.eachNode(regionNodes, function(regionNode)
{
var regionJson = Grid.ImportExport.parseRegion(regionNode);
hotspots.regions.push(regionJson);
});
var regionGroupNodes = xmlobject.getElementsByTagName("RegionGroup");
Grid.ImportExport.eachNode(regionGroupNodes, function(regionGroupNode)
{
var groupJson = Grid.ImportExport.parseRegionGroup(regionGroupNode);
hotspots.groups.push(groupJson);
});
Grid.ImportExport.eachNode(hotspots.regions, function(regionJson)
{
var region = model.createRegion(regionJson.name, regionJson.shape, regionJson.coords);
if (region == null) return;
Grid.ImportExport.eachNode(regionJson.events, function(eventJson)
{
var event = region.createEvent(eventJson.name);
event.setStyles(eventJson.styles);
if (eventJson.label != null)
{
event.setLabel(eventJson.label.x, eventJson.label.y, eventJson.label.text);
}
if (eventJson.image != null)
{
var url = Grid.ImportExport.resolveUrl(eventJson.image.src);
var htmlImage = imageLoader.getImage(url);
if (htmlImage != null)
{
event.setImage(url, eventJson.image.x, eventJson.image.y, htmlImage.width, htmlImage.height);
}
}
});
region.update();
});
Grid.ImportExport.eachNode(hotspots.groups, function(groupJson)
{
var regionGroup = model.createRegionGroup(groupJson.name, groupJson.min, groupJson.max);
for (var i = 0; i < groupJson.includes.length; i++)
{
var region = model.getRegion(groupJson.includes[i]);
if (region != null) regionGroup.addRegion(region);
}
});
};
Grid.ImportExport.parseRegionGroupObjects = function(xmlobject)
{
var regionObjects = [];
var regionObjNodes = xmlobject.getElementsByTagName("RegionObject");
Grid.ImportExport.eachNode(regionObjNodes, function(regionObjNode)
{
var regionObject =
{
name: regionObjNode.getAttribute('name'),
selected: (regionObjNode.getAttribute('isselected') == 'true')
};
regionObjects.push(regionObject);
});
return regionObjects;
};
Grid.ImportExport.loadRegionGroupObjects = function(xmlobject, model)
{
var regionObjects = Grid.ImportExport.parseRegionGroupObjects(xmlobject);
for (var i = 0; i < regionObjects.length; i++)
{
var regionObject = regionObjects[i];
var region = model.getRegion(regionObject.name);
if (region != null)
{
if (regionObject.selected) region.select();
else region.deselect();
}
}
};
Grid.ImportExport.getRegionGroupsXmlString = function(model)
{
var xmlDoc = Grid.ImportExport.getRegionGroupsXmlDoc(model);
return Grid.ImportExport.serializeToString(xmlDoc);
};
Grid.ImportExport.getRegionGroupsXmlDoc = function(model)
{
var xmlDoc = Grid.ImportExport.parseFromString('<HotSpots></HotSpots>');
var appendEvent = function(event, parentNode)
{
var eventNode = xmlDoc.createElement('Event');
eventNode.setAttribute('name', event.name);
var styles = event.getStyles();
var stylesNode = xmlDoc.createElement('Styles');
for (var styleName in styles)
{
var styleValue = styles[styleName];
stylesNode.setAttribute(styleName, styleValue);
}
eventNode.appendChild(stylesNode);
var image = event.getImage();
if (image != null)
{
var imageNode = xmlDoc.createElement('Image');
imageNode.setAttribute('src', image.url);
imageNode.setAttribute('x', image.x);
imageNode.setAttribute('y', image.y);
eventNode.appendChild(imageNode);
}
var label = event.getLabel();
if (label != null)
{
var labelNode = xmlDoc.createElement('Label');
labelNode.setAttribute('text', label.text);
labelNode.setAttribute('x', label.x);
labelNode.setAttribute('y', label.y);
eventNode.appendChild(labelNode);
}
parentNode.appendChild(eventNode);
};
var appendRegion = function(region, parentNode)
{
var regionNode = xmlDoc.createElement('Region');
var shapeName = region.getType();
var shapeCoords = region.getCoords();
regionNode.setAttribute('name', region.name);
regionNode.setAttribute('shape', shapeName);
regionNode.setAttribute('coords', shapeCoords);
var events = region.getEvents();
for (var i = 0; i < events.length; i++)
{
appendEvent(events[i], regionNode);
}
parentNode.appendChild(regionNode);
};
var appendRegionGroup = function(regionGroup, parentNode)
{
var regionGroupNode = xmlDoc.createElement('RegionGroup');
regionGroupNode.setAttribute('name', regionGroup.name);
regionGroupNode.setAttribute('min', regionGroup.min);
regionGroupNode.setAttribute('max', regionGroup.max);
var regions = regionGroup.getRegions();
for (var i = 0; i < regions.length; i++)
{
var region = regions[i];
var includeNode = xmlDoc.createElement('Include');
includeNode.setAttribute('region', region.name);
regionGroupNode.appendChild(includeNode);
}
parentNode.appendChild(regionGroupNode);
};
var regions = model.getRegions();
var regionsNode = xmlDoc.createElement('Regions');
xmlDoc.documentElement.appendChild(regionsNode);
for (var i = 0; i < regions.length; i++)
{
appendRegion(regions[i], regionsNode);
}
var regionGroups = model.getRegionGroups();
var regionGroupsNode = xmlDoc.createElement('RegionGroups');
xmlDoc.documentElement.appendChild(regionGroupsNode);
for (var i = 0; i < regionGroups.length; i++)
{
appendRegionGroup(regionGroups[i], regionGroupsNode);
}
return xmlDoc;
};

// FILE: importexport.shapes.js (c4542add) 3/7/2014 11:24:06 AM

Grid.ImportExport.translateCoordinate = function(model, y)
{
return (model.options.canvasHeight - y);
};
Grid.ImportExport.writeShapes = function(rootNode, model) {
var xmlDoc = rootNode.ownerDocument;
var circles = model.getCircles();
if (circles && circles.length > 0) {
var circlesNode = this.createCirclesElement(xmlDoc, circles);
rootNode.appendChild(circlesNode);
}
var lines = model.getLines();
if (lines && lines.length > 0) {
var linesNode = this.createLinesElement(xmlDoc, lines);
rootNode.appendChild(linesNode);
}
};
Grid.ImportExport.createCirclesElement = function(xmlDoc, circles) {
var circlesNode = xmlDoc.createElement('Circles');
for (var i = 0; i < circles.length; i++) {
var circle = circles[i];
var circleNode = xmlDoc.createElement('Circle');
circleNode.setAttribute('x', circle.x);
circleNode.setAttribute('y', circle.y);
circleNode.setAttribute('r', circle.radius);
circlesNode.appendChild(circleNode);
}
return circlesNode;
};
Grid.ImportExport.createLinesElement = function(xmlDoc, lines) {
var linesNode = xmlDoc.createElement('Lines');
for (var i = 0; i < lines.length; i++) {
var line = lines[i];
var lineNode = xmlDoc.createElement('Line');
lineNode.setAttribute('sourceX', line.source.x);
lineNode.setAttribute('sourceY', line.source.y);
lineNode.setAttribute('targetX', line.target.x);
lineNode.setAttribute('targetY', line.target.y);
lineNode.setAttribute('dir', line.dirType);
lineNode.setAttribute('style', line.style);
linesNode.appendChild(lineNode);
}
return linesNode;
};
Grid.ImportExport.loadShapes = function(xmlDoc, model) {
var circlesNode = xmlDoc.getElementsByTagName('Circles')[0];
if (circlesNode) this.loadCircles(circlesNode, model);
var linesNode = xmlDoc.getElementsByTagName('Lines')[0];
if (linesNode) this.loadLines(linesNode, model);
};
Grid.ImportExport.loadCircles = function(circlesNode, model) {
var circleList = circlesNode.getElementsByTagName('Circle');
for (var i = 0; i < circleList.length; i++) {
var circleNode = circleList[i];
var x = parseInt(circleNode.getAttribute('x'));
var y = parseInt(circleNode.getAttribute('y'));
var r = parseInt(circleNode.getAttribute('r'));
var circle = model.createCircle(x, y, r);
model.addCircle(circle);
}
};
Grid.ImportExport.loadLines = function(linesNode, model) {
var lineList = linesNode.getElementsByTagName('Line');
var lines = model.getLines();
for (var i = 0; i < lineList.length; i++) {
var lineNode = lineList[i];
var sourceX = parseInt(lineNode.getAttribute('sourceX'));
var sourceY = parseInt(lineNode.getAttribute('sourceY'));
var targetX = parseInt(lineNode.getAttribute('targetX'));
var targetY = parseInt(lineNode.getAttribute('targetY'));
var dir = lineNode.getAttribute('dir');
var style = lineNode.getAttribute('style');
if (style != 'dashed') continue;
for (var j = 0; j < lines.length; j++) {
var line = lines[j];
if (sourceX == line.source.x &&
sourceY == line.source.y &&
targetX == line.target.x &&
targetY == line.target.y &&
dir == line.dirType) {
line.style = style;
line.update();
}
}
}
};

// FILE: ImportExport.qti.js (17d76a6f) 3/7/2014 11:24:06 AM

Grid.QtiImportExport = function(model) {
var gridquestion = model;
var answerSpaceXml;
var defaultEvents = [
{
name: "select",
styles: {
'fill': "white",
'fill-opacity': "0",
'stroke': "red",
'stroke-dasharray': "",
'stroke-opacity': "",
'stroke-width': "6"
},
image: null,
label: null
},
{
name: "hover",
styles: {
'fill': "white",
'fill-opacity': "0",
'stroke': "blue",
'stroke-dasharray': "",
'stroke-opacity': "",
'stroke-width': "4"
},
image: null,
label: null
}
];
this._importexport = new Grid.ImportExport(model);
this.loadItem = function(qtiXmlStr, callbackCreated, callbackFailure) {
var imageFiles = parseImageFiles(qtiXmlStr);
var imageLoader = new Grid.ImportExport.ImageLoader();
if (imageFiles.length == 0) {
loadItem2(qtiXmlStr, callbackCreated, imageLoader, imageFiles);
return;
}
for (var i = 0; i < imageFiles.length; i++) {
var url = Grid.ImportExport.resolveUrl(imageFiles[i].url);
imageLoader.addImage(url);
}
var self = this;
imageLoader.load(function() {
var imageErrors = imageLoader.getErrors();
if (imageErrors.length == 0) {
loadItem2.call(self, qtiXmlStr, callbackCreated, imageLoader, imageFiles);
} else {
callbackFailure('Error loading DOM images', imageErrors);
}
});
};
this.loadAnswer = function(response, gridq) {
this._importexport.loadAnswer.call(this, response, gridq);
};
this.getAnswerXml = function() {
this._importexport.getAnswerXml.call(this);
};
this.isStudentResponseValid = function() {
this._importexport.isStudentResponseValid.call(this);
};
var parseImageFiles = function(qtiXmlStr) {
var imageFiles = [];
var xmlDoc = Grid.ImportExport.parseFromString(qtiXmlStr);
var nodes = xmlDoc.getElementsByTagName('object');
Grid.ImportExport.eachNode(nodes, function(node) {
var nodeType = node.getAttribute('type');
if (nodeType.indexOf('image') != -1) {
var imageFile = {
url: node.getAttribute('data'),
height: node.getAttribute('height'),
width: node.getAttribute('width')
};
if (imageFiles.indexOf(imageFile) == -1) {
imageFiles.push(imageFile);
}
}
});
return imageFiles;
};
var addBackgroundImage = function(imageFiles, imageLoader) {
for (var i = 0; i < imageFiles.length; i++) {
var img = imageFiles[i];
var url = Grid.ImportExport.resolveUrl(img.url);
var htmlImage = imageLoader.getImage(url);
if ((htmlImage != null) && (img.height != null) && (img.width != null)) {
gridquestion.addBackgroundImage(htmlImage.src, 0, 0, htmlImage.width, htmlImage.height);
}
}
};
var parseHotspotChoice = function(regionNode) {
var region = {
name: regionNode.getAttribute('identifier'),
shape: regionNode.getAttribute('shape'),
coords: regionNode.getAttribute('coords'),
events: defaultEvents
};
return region;
};
var loadHotspots = function(xmlDoc, localModel, imageLoader) {
var hotspots = [];
var qtiObject = xmlDoc.getElementsByTagName('hotspotInteraction')[0];
var minChoices = qtiObject.getAttribute('minChoices');
var maxChoices = qtiObject.getAttribute('maxChoices');
var regionGroup = localModel.createRegionGroup('All', minChoices, maxChoices);
var regionNodes = xmlDoc.getElementsByTagName('hotspotChoice');
Grid.ImportExport.eachNode(regionNodes, function(regionNode) {
var regionJson = parseHotspotChoice(regionNode);
hotspots.push(regionJson);
});
Grid.ImportExport.eachNode(hotspots, function(regionJson) {
var region = localModel.createRegion(regionJson.name, regionJson.shape, regionJson.coords);
if (region == null) return;
regionGroup.addRegion(region);
if (regionJson.events == null) regionJson.events = defaultEvents;
Grid.ImportExport.eachNode(regionJson.events, function(eventJson) {
var event = region.createEvent(eventJson.name);
event.setStyles(eventJson.styles);
if (eventJson.label != null) {
event.setLabel(eventJson.label.x, eventJson.label.y, eventJson.label.text);
}
if (eventJson.image != null) {
var url = Grid.ImportExport.resolveUrl(eventJson.image.src);
var htmlImage = imageLoader.getImage(url);
if (htmlImage != null) {
event.setImage(url, eventJson.image.x, eventJson.image.y, htmlImage.width, htmlImage.height);
}
}
});
region.update();
});
};
var loadItem2 = function(qtiXmlStr, callback, imageLoader, imageFiles) {
answerSpaceXml = qtiXmlStr;
var xmlDoc = Grid.ImportExport.parseFromString(qtiXmlStr);
addBackgroundImage(imageFiles, imageLoader);
loadHotspots(xmlDoc, gridquestion, imageLoader);
if (typeof callback == 'function') callback();
};
};

// FILE: module_grid.js (8031dd07) 3/7/2014 11:24:06 AM

(function() {
function isGrid(item) {
return item.isResponseType('grid');
}
function isQTI(item) {
return item.isResponseType('hotspot');
}
ContentManager.onItemEvent('rendered', function(page, item) {
if (!isGrid(item)) return;
try {
Grid.Utils.loadImageFiles(page, item.gridAnswerSpace);
} catch(ex) {
TDS.Diagnostics.report(ex);
}
});
ContentManager.onItemEvent('loaded', function(page, item)
{
if (isGrid(item) || isQTI(item)) {
process(page, item);
}
});
function process(page, item) {
var doc = page.getDoc();
var gridContainer = doc.getElementById('GridContainer_' + item.position);
var gridStatus = doc.getElementById('StudentGrid_' + item.position + '_Status');
if (gridContainer == null) return;
var gridSvg = ContentManager.resolveBaseUrl('Scripts/Grid2/grid.svg');
var grid = new Grid(gridContainer, gridSvg);
if (isQTI(item)) {
ContentManager.QTI.loadStem(item);
grid.importexport = new Grid.QtiImportExport(grid.model);
};
item.grid = grid;
YUD.addClass(gridContainer, 'loading');
grid.allowTab = false;
grid.isReadOnly = item.isReadOnly;
var GridComponent = function(panelName)
{
this.id = panelName;
this.getXY = function() { return [0, 0]; };
this.focus = function()
{
grid.setArea(panelName);
Util.Dom.focus(grid.ui._svgWin);
};
this.blur = function()
{
grid.setArea(null);
if (!Util.Browser.isIE()) {
Util.Dom.blur(grid.ui._svgWin);
}
};
this.toString = function() { return panelName; };
};
var gridComponents = {};
gridComponents['canvas'] = new GridComponent('canvas');
gridComponents['palette'] = new GridComponent('palette');
gridComponents['toolbar'] = new GridComponent('toolbar');
grid.subscribe('onStateChange', function(gridEvt) {
if (gridStatus != null) gridStatus.innerHTML = gridEvt.name;
if (gridEvt.state == GridState.Ready) {
ContentManager.addKeyEvents(grid.ui._svgRoot);
if (typeof (KeyManager) == 'object') {
KeyManager.attachListener(grid.ui._svgRoot);
}
setTimeout(function() {
var gridResponse = null;
if (typeof (window.TestShell) == 'object' &&
typeof (window.TestShell.PageManager) == 'object') {
var response = window.TestShell.PageManager.getResponse(item.position);
gridResponse = response.getLastValue();
} else {
gridResponse = item.value;
}
if (Grid.QtiImportExport && grid.importexport instanceof Grid.QtiImportExport) {
grid.loadXml(item.qti.xml, gridResponse);
} else {
grid.loadXml(item.gridAnswerSpace, gridResponse);
}
}, 0);
}
if (gridEvt.state == GridState.Loaded) {
YUD.removeClass(gridContainer, 'loading');
if (grid.question.options.showPalette) item.addComponent(gridComponents['palette']);
if (grid.question.options.showButtons.length > 0) item.addComponent(gridComponents['toolbar']);
item.addComponent(gridComponents['canvas']);
var zoomInfo = page.getZoom();
var zoomFactor = (zoomInfo == null) ? 1 : zoomInfo.levels[zoomInfo.currentLevel].factor;
setTimeout(function() {
grid.ui.zoom(zoomFactor);
}, 0);
if (page.isShowing()) {
grid.ui._fixOffset();
}
}
if (gridEvt.state == GridState.Error) {
YUD.removeClass(gridContainer, 'loading');
YUD.addClass(gridContainer, 'failed');
if (grid.ui && grid.ui._svgObject) {
YUD.setStyle(grid.ui._svgObject, 'display', 'none');
}
}
ContentManager.log('GRID ' + item.position + ': STATE - ' + gridEvt.name);
});
grid.subscribe('onModeChange', function(gridEvt) {
ContentManager.log('GRID ' + item.position + ': MODE - ' + gridEvt.name);
});
grid.subscribe('onAreaChange', function(gridEvt) {
if (gridEvt.name != null) {
item.setActive(gridEvt);
item.setActiveComponent(gridComponents[gridEvt.name]);
}
ContentManager.log('GRID ' + item.position + ': AREA - ' + gridEvt.name);
});
if (typeof TDS.Diagnostics == 'object') {
grid.subscribe('onStateChange', function(gridEvt) {
if (gridEvt.state == GridState.Created) {
TDS.Diagnostics.addErrorHandler(grid.view._svgWin);
}
});
grid.subscribe('onError', function(evt) {
if (evt.exception) {
TDS.Diagnostics.report(evt.exception);
}
});
}
grid.init();
}
ContentManager.onItemEvent('show', function(page, item) {
if (!item.grid) return;
var grid = item.grid;
if (!grid.ui._svgObject) return;
grid.ui._fixOffset();
});
ContentManager.onItemEvent('zoom', function(page, item) {
if (item.grid) {
item.grid.ui.zoom(page.getZoomFactor());
}
});
})();
(function() {
var getter = function(item, response) {
var grid = (item.grid || item.grid2);
if (grid) {
response.value = grid.getResponseXml();
response.isValid = grid.isValid();
response.isSelected = response.isValid;
}
};
var setter = function(item, value) {
if (item && item.grid) {
item.grid.importexport.loadAnswer(value);
}
};
ContentManager.registerResponseHandler('grid', getter, setter);
})();
if (typeof (Grid.Utils) == 'undefined') Grid.Utils = {};
Grid.Utils.parseImageFiles = function(questionXml)
{
var eachNode = function(nodeList, func)
{
var nodes = [];
for (var i = 0; i < nodeList.length; i++)
{
nodes.push(nodeList[i] || nodeList.item(i));
}
YAHOO.util.Dom.batch(nodes, func);
};
var getTextContent = function(node)
{
if (node && node.childNodes && node.childNodes.length)
return node.childNodes[0].nodeValue;
return null;
};
var imageFiles = [];
var xmlDoc = Util.Xml.parseFromString(questionXml);
var imageNodes = xmlDoc.getElementsByTagName('FileSpec');
eachNode(imageNodes, function(imageNode)
{
var imageFile = getTextContent(imageNode);
if (imageFiles.indexOf(imageFile) == -1) imageFiles.push(imageFile);
});
imageNodes = xmlDoc.getElementsByTagName('Image');
eachNode(imageNodes, function(imageNode)
{
var imageFile = imageNode.getAttribute('src');
if (imageFiles.indexOf(imageFile) == -1) imageFiles.push(imageFile);
});
return imageFiles;
};
Grid.Utils.loadImageFiles = function(page, questionXml)
{
var imageFiles = Grid.Utils.parseImageFiles(questionXml);
for (var i = 0; i < imageFiles.length; i++)
{
var imageFile = imageFiles[i];
var imageUrl = Grid.ImportExport.resolveUrl(imageFile);
var img = new Image();
page.addImage(img);
img.src = imageUrl;
}
};

// FILE: SetSimNameSpace.js (d502f2e2) 3/7/2014 11:24:14 AM

if (typeof Simulator == 'undefined' || !Simulator) {
var Simulator = {};
}
Simulator.nameSpace = function() {
var nsObj = null, parts;
for (var i = 0; i < arguments.length; i++) {
parts = ('' + arguments[i]).split('.');
nsObj = Simulator;
for (var j = (parts[0] === 'Simulator') ? 1 : 0; j < parts.length; j++) {
nsObj[parts[j]] = nsObj[parts[j]] || {};
nsObj = nsObj[parts[j]];
}
}
console.log('Set up ' + arguments[0] + '.' + arguments[1] + ' namespace');
return nsObj;
};
Simulator.Animation = Simulator.nameSpace('Simulator', 'Animation');
Simulator.Control = Simulator.nameSpace('Simulator', 'Control');
Simulator.Display = Simulator.nameSpace('Simulator', 'Display');
Simulator.Input = Simulator.nameSpace('Simulator', 'Input');
Simulator.Utils = Simulator.nameSpace('Simulator', 'Utils');

// FILE: swfobject.js (25b1dbca) 3/7/2014 11:24:14 AM

var swfobject = function () {
var UNDEF = "undefined",
OBJECT = "object",
SHOCKWAVE_FLASH = "Shockwave Flash",
SHOCKWAVE_FLASH_AX = "ShockwaveFlash.ShockwaveFlash",
FLASH_MIME_TYPE = "application/x-shockwave-flash",
EXPRESS_INSTALL_ID = "SWFObjectExprInst",
ON_READY_STATE_CHANGE = "onreadystatechange",
win = window,
doc = document,
nav = navigator,
plugin = false,
domLoadFnArr = [main],
regObjArr = [],
objIdArr = [],
listenersArr = [],
storedAltContent,
storedAltContentId,
storedCallbackFn,
storedCallbackObj,
isDomLoaded = false,
isExpressInstallActive = false,
dynamicStylesheet,
dynamicStylesheetMedia,
autoHideShow = true,
ua = function () {
var w3cdom = typeof doc.getElementById != UNDEF && typeof doc.getElementsByTagName != UNDEF && typeof doc.createElement != UNDEF,
u = nav.userAgent.toLowerCase(),
p = nav.platform.toLowerCase(),
windows = p ? /win/.test(p) : /win/.test(u),
mac = p ? /mac/.test(p) : /mac/.test(u),
webkit = /webkit/.test(u) ? parseFloat(u.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : false,
ie = ! +"\v1",
playerVersion = [0, 0, 0],
d = null;
if (typeof nav.plugins != UNDEF && typeof nav.plugins[SHOCKWAVE_FLASH] == OBJECT) {
d = nav.plugins[SHOCKWAVE_FLASH].description;
if (d && !(typeof nav.mimeTypes != UNDEF && nav.mimeTypes[FLASH_MIME_TYPE] && !nav.mimeTypes[FLASH_MIME_TYPE].enabledPlugin)) {
plugin = true;
ie = false;
d = d.replace(/^.*\s+(\S+\s+\S+$)/, "$1");
playerVersion[0] = parseInt(d.replace(/^(.*)\..*$/, "$1"), 10);
playerVersion[1] = parseInt(d.replace(/^.*\.(.*)\s.*$/, "$1"), 10);
playerVersion[2] = /[a-zA-Z]/.test(d) ? parseInt(d.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0;
}
}
else if (typeof win.ActiveXObject != UNDEF) {
try {
var a = new ActiveXObject(SHOCKWAVE_FLASH_AX);
if (a) {
d = a.GetVariable("$version");
if (d) {
ie = true;
d = d.split(" ")[1].split(",");
playerVersion = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
}
}
}
catch (e) { }
}
return { w3: w3cdom, pv: playerVersion, wk: webkit, ie: ie, win: windows, mac: mac };
} (),
onDomLoad = function () {
if (!ua.w3) { return; }
if ((typeof doc.readyState != UNDEF && doc.readyState == "complete") || (typeof doc.readyState == UNDEF && (doc.getElementsByTagName("body")[0] || doc.body))) {
callDomLoadFunctions();
}
if (!isDomLoaded) {
if (typeof doc.addEventListener != UNDEF) {
doc.addEventListener("DOMContentLoaded", callDomLoadFunctions, false);
}
if (ua.ie && ua.win) {
doc.attachEvent(ON_READY_STATE_CHANGE, function () {
if (doc.readyState == "complete") {
doc.detachEvent(ON_READY_STATE_CHANGE, arguments.callee);
callDomLoadFunctions();
}
});
if (win == top) {
(function () {
if (isDomLoaded) { return; }
try {
doc.documentElement.doScroll("left");
}
catch (e) {
setTimeout(arguments.callee, 0);
return;
}
callDomLoadFunctions();
})();
}
}
if (ua.wk) {
(function () {
if (isDomLoaded) { return; }
if (!/loaded|complete/.test(doc.readyState)) {
setTimeout(arguments.callee, 0);
return;
}
callDomLoadFunctions();
})();
}
addLoadEvent(callDomLoadFunctions);
}
} ();
function callDomLoadFunctions() {
if (isDomLoaded) { return; }
try {
var t = doc.getElementsByTagName("body")[0].appendChild(createElement("span"));
t.parentNode.removeChild(t);
}
catch (e) { return; }
isDomLoaded = true;
var dl = domLoadFnArr.length;
for (var i = 0; i < dl; i++) {
domLoadFnArr[i]();
}
}
function addDomLoadEvent(fn) {
if (isDomLoaded) {
fn();
}
else {
domLoadFnArr[domLoadFnArr.length] = fn;
}
}
function addLoadEvent(fn) {
if (typeof win.addEventListener != UNDEF) {
win.addEventListener("load", fn, false);
}
else if (typeof doc.addEventListener != UNDEF) {
doc.addEventListener("load", fn, false);
}
else if (typeof win.attachEvent != UNDEF) {
addListener(win, "onload", fn);
}
else if (typeof win.onload == "function") {
var fnOld = win.onload;
win.onload = function () {
fnOld();
fn();
};
}
else {
win.onload = fn;
}
}
function main() {
if (plugin) {
testPlayerVersion();
}
else {
matchVersions();
}
}
function testPlayerVersion() {
var b = doc.getElementsByTagName("body")[0];
var o = createElement(OBJECT);
o.setAttribute("type", FLASH_MIME_TYPE);
var t = b.appendChild(o);
if (t) {
var counter = 0;
(function () {
if (typeof t.GetVariable != UNDEF) {
var d = t.GetVariable("$version");
if (d) {
d = d.split(" ")[1].split(",");
ua.pv = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
}
}
else if (counter < 10) {
counter++;
setTimeout(arguments.callee, 10);
return;
}
b.removeChild(o);
t = null;
matchVersions();
})();
}
else {
matchVersions();
}
}
function matchVersions() {
var rl = regObjArr.length;
if (rl > 0) {
for (var i = 0; i < rl; i++) {
var id = regObjArr[i].id;
var cb = regObjArr[i].callbackFn;
var cbObj = { success: false, id: id };
if (ua.pv[0] > 0) {
var obj = getElementById(id);
if (obj) {
if (hasPlayerVersion(regObjArr[i].swfVersion) && !(ua.wk && ua.wk < 312)) {
setVisibility(id, true);
if (cb) {
cbObj.success = true;
cbObj.ref = getObjectById(id);
cb(cbObj);
}
}
else if (regObjArr[i].expressInstall && canExpressInstall()) {
var att = {};
att.data = regObjArr[i].expressInstall;
att.width = obj.getAttribute("width") || "0";
att.height = obj.getAttribute("height") || "0";
if (obj.getAttribute("class")) { att.styleclass = obj.getAttribute("class"); }
if (obj.getAttribute("align")) { att.align = obj.getAttribute("align"); }
var par = {};
var p = obj.getElementsByTagName("param");
var pl = p.length;
for (var j = 0; j < pl; j++) {
if (p[j].getAttribute("name").toLowerCase() != "movie") {
par[p[j].getAttribute("name")] = p[j].getAttribute("value");
}
}
showExpressInstall(att, par, id, cb);
}
else {
displayAltContent(obj);
if (cb) { cb(cbObj); }
}
}
}
else {
setVisibility(id, true);
if (cb) {
var o = getObjectById(id);
if (o && typeof o.SetVariable != UNDEF) {
cbObj.success = true;
cbObj.ref = o;
}
cb(cbObj);
}
}
}
}
}
function getObjectById(objectIdStr) {
var r = null;
var o = getElementById(objectIdStr);
if (o && o.nodeName == "OBJECT") {
if (typeof o.SetVariable != UNDEF) {
r = o;
}
else {
var n = o.getElementsByTagName(OBJECT)[0];
if (n) {
r = n;
}
}
}
return r;
}
function canExpressInstall() {
return !isExpressInstallActive && hasPlayerVersion("6.0.65") && (ua.win || ua.mac) && !(ua.wk && ua.wk < 312);
}
function showExpressInstall(att, par, replaceElemIdStr, callbackFn) {
isExpressInstallActive = true;
storedCallbackFn = callbackFn || null;
storedCallbackObj = { success: false, id: replaceElemIdStr };
var obj = getElementById(replaceElemIdStr);
if (obj) {
if (obj.nodeName == "OBJECT") {
storedAltContent = abstractAltContent(obj);
storedAltContentId = null;
}
else {
storedAltContent = obj;
storedAltContentId = replaceElemIdStr;
}
att.id = EXPRESS_INSTALL_ID;
if (typeof att.width == UNDEF || (!/%$/.test(att.width) && parseInt(att.width, 10) < 310)) { att.width = "310"; }
if (typeof att.height == UNDEF || (!/%$/.test(att.height) && parseInt(att.height, 10) < 137)) { att.height = "137"; }
doc.title = doc.title.slice(0, 47) + " - Flash Player Installation";
var pt = ua.ie && ua.win ? "ActiveX" : "PlugIn",
fv = "MMredirectURL=" + win.location.toString().replace(/&/g, "%26") + "&MMplayerType=" + pt + "&MMdoctitle=" + doc.title;
if (typeof par.flashvars != UNDEF) {
par.flashvars += "&" + fv;
}
else {
par.flashvars = fv;
}
if (ua.ie && ua.win && obj.readyState != 4) {
var newObj = createElement("div");
replaceElemIdStr += "SWFObjectNew";
newObj.setAttribute("id", replaceElemIdStr);
obj.parentNode.insertBefore(newObj, obj);
obj.style.display = "none";
(function () {
if (obj.readyState == 4) {
obj.parentNode.removeChild(obj);
}
else {
setTimeout(arguments.callee, 10);
}
})();
}
createSWF(att, par, replaceElemIdStr);
}
}
function displayAltContent(obj) {
if (ua.ie && ua.win && obj.readyState != 4) {
var el = createElement("div");
obj.parentNode.insertBefore(el, obj);
el.parentNode.replaceChild(abstractAltContent(obj), el);
obj.style.display = "none";
(function () {
if (obj.readyState == 4) {
obj.parentNode.removeChild(obj);
}
else {
setTimeout(arguments.callee, 10);
}
})();
}
else {
obj.parentNode.replaceChild(abstractAltContent(obj), obj);
}
}
function abstractAltContent(obj) {
var ac = createElement("div");
if (ua.win && ua.ie) {
ac.innerHTML = obj.innerHTML;
}
else {
var nestedObj = obj.getElementsByTagName(OBJECT)[0];
if (nestedObj) {
var c = nestedObj.childNodes;
if (c) {
var cl = c.length;
for (var i = 0; i < cl; i++) {
if (!(c[i].nodeType == 1 && c[i].nodeName == "PARAM") && !(c[i].nodeType == 8)) {
ac.appendChild(c[i].cloneNode(true));
}
}
}
}
}
return ac;
}
function createSWF(attObj, parObj, id) {
var r, el = getElementById(id);
if (ua.wk && ua.wk < 312) { return r; }
if (el) {
if (typeof attObj.id == UNDEF) {
attObj.id = id;
}
if (ua.ie && ua.win) {
var att = "";
for (var i in attObj) {
if (attObj[i] != Object.prototype[i]) {
if (i.toLowerCase() == "data") {
parObj.movie = attObj[i];
}
else if (i.toLowerCase() == "styleclass") {
att += ' class="' + attObj[i] + '"';
}
else if (i.toLowerCase() != "classid") {
att += ' ' + i + '="' + attObj[i] + '"';
}
}
}
var par = "";
for (var j in parObj) {
if (parObj[j] != Object.prototype[j]) {
par += '<param name="' + j + '" value="' + parObj[j] + '" />';
}
}
el.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + att + '>' + par + '</object>';
objIdArr[objIdArr.length] = attObj.id;
r = getElementById(attObj.id);
}
else {
var o = createElement(OBJECT);
o.setAttribute("type", FLASH_MIME_TYPE);
for (var m in attObj) {
if (attObj[m] != Object.prototype[m]) {
if (m.toLowerCase() == "styleclass") {
o.setAttribute("class", attObj[m]);
}
else if (m.toLowerCase() != "classid") {
o.setAttribute(m, attObj[m]);
}
}
}
for (var n in parObj) {
if (parObj[n] != Object.prototype[n] && n.toLowerCase() != "movie") {
createObjParam(o, n, parObj[n]);
}
}
el.parentNode.replaceChild(o, el);
r = o;
}
}
return r;
}
function createObjParam(el, pName, pValue) {
var p = createElement("param");
p.setAttribute("name", pName);
p.setAttribute("value", pValue);
el.appendChild(p);
}
function removeSWF(id) {
var obj = getElementById(id);
if (obj && obj.nodeName == "OBJECT") {
if (ua.ie && ua.win) {
obj.style.display = "none";
(function () {
if (obj.readyState == 4) {
removeObjectInIE(id);
}
else {
setTimeout(arguments.callee, 10);
}
})();
}
else {
obj.parentNode.removeChild(obj);
}
}
}
function removeObjectInIE(id) {
var obj = getElementById(id);
if (obj) {
for (var i in obj) {
if (typeof obj[i] == "function") {
obj[i] = null;
}
}
obj.parentNode.removeChild(obj);
}
}
function getElementById(id) {
var el = null;
try {
el = doc.getElementById(id);
}
catch (e) { }
return el;
}
function createElement(el) {
return doc.createElement(el);
}
function addListener(target, eventType, fn) {
target.attachEvent(eventType, fn);
listenersArr[listenersArr.length] = [target, eventType, fn];
}
function hasPlayerVersion(rv) {
var pv = ua.pv, v = rv.split(".");
v[0] = parseInt(v[0], 10);
v[1] = parseInt(v[1], 10) || 0;
v[2] = parseInt(v[2], 10) || 0;
return (pv[0] > v[0] || (pv[0] == v[0] && pv[1] > v[1]) || (pv[0] == v[0] && pv[1] == v[1] && pv[2] >= v[2])) ? true : false;
}
function createCSS(sel, decl, media, newStyle) {
if (ua.ie && ua.mac) { return; }
var h = doc.getElementsByTagName("head")[0];
if (!h) { return; }
var m = (media && typeof media == "string") ? media : "screen";
if (newStyle) {
dynamicStylesheet = null;
dynamicStylesheetMedia = null;
}
if (!dynamicStylesheet || dynamicStylesheetMedia != m) {
var s = createElement("style");
s.setAttribute("type", "text/css");
s.setAttribute("media", m);
dynamicStylesheet = h.appendChild(s);
if (ua.ie && ua.win && typeof doc.styleSheets != UNDEF && doc.styleSheets.length > 0) {
dynamicStylesheet = doc.styleSheets[doc.styleSheets.length - 1];
}
dynamicStylesheetMedia = m;
}
if (ua.ie && ua.win) {
if (dynamicStylesheet && typeof dynamicStylesheet.addRule == OBJECT) {
dynamicStylesheet.addRule(sel, decl);
}
}
else {
if (dynamicStylesheet && typeof doc.createTextNode != UNDEF) {
dynamicStylesheet.appendChild(doc.createTextNode(sel + " {" + decl + "}"));
}
}
}
function setVisibility(id, isVisible) {
if (!autoHideShow) { return; }
var v = isVisible ? "visible" : "hidden";
if (isDomLoaded && getElementById(id)) {
getElementById(id).style.visibility = v;
}
else {
createCSS("#" + id, "visibility:" + v);
}
}
function urlEncodeIfNecessary(s) {
var regex = /[\\\"<>\.;]/;
var hasBadChars = regex.exec(s) != null;
return hasBadChars && typeof encodeURIComponent != UNDEF ? encodeURIComponent(s) : s;
}
var cleanup = function () {
if (ua.ie && ua.win) {
window.attachEvent("onunload", function () {
var ll = listenersArr.length;
for (var i = 0; i < ll; i++) {
listenersArr[i][0].detachEvent(listenersArr[i][1], listenersArr[i][2]);
}
var il = objIdArr.length;
for (var j = 0; j < il; j++) {
removeSWF(objIdArr[j]);
}
for (var k in ua) {
ua[k] = null;
}
ua = null;
for (var l in swfobject) {
swfobject[l] = null;
}
swfobject = null;
});
}
} ();
return {
registerObject: function (objectIdStr, swfVersionStr, xiSwfUrlStr, callbackFn) {
if (ua.w3 && objectIdStr && swfVersionStr) {
var regObj = {};
regObj.id = objectIdStr;
regObj.swfVersion = swfVersionStr;
regObj.expressInstall = xiSwfUrlStr;
regObj.callbackFn = callbackFn;
regObjArr[regObjArr.length] = regObj;
setVisibility(objectIdStr, false);
}
else if (callbackFn) {
callbackFn({ success: false, id: objectIdStr });
}
},
getObjectById: function (objectIdStr) {
if (ua.w3) {
return getObjectById(objectIdStr);
}
},
embedSWF: function (swfUrlStr, replaceElemIdStr, widthStr, heightStr, swfVersionStr, xiSwfUrlStr,
flashvarsObj, parObj, attObj, simDocument, callbackFn) {
if (simDocument != null) doc = simDocument;
var callbackObj = { success: false, id: replaceElemIdStr };
if (ua.w3 && !(ua.wk && ua.wk < 312) && swfUrlStr && replaceElemIdStr && widthStr && heightStr && swfVersionStr) {
setVisibility(replaceElemIdStr, false);
addDomLoadEvent(function () {
widthStr += "";
heightStr += "";
var att = {};
if (attObj && typeof attObj === OBJECT) {
for (var i in attObj) {
att[i] = attObj[i];
}
}
att.data = swfUrlStr;
att.width = widthStr;
att.height = heightStr;
var par = {};
if (parObj && typeof parObj === OBJECT) {
for (var j in parObj) {
par[j] = parObj[j];
}
}
if (flashvarsObj && typeof flashvarsObj === OBJECT) {
for (var k in flashvarsObj) {
if (typeof par.flashvars != UNDEF) {
par.flashvars += "&" + k + "=" + flashvarsObj[k];
}
else {
par.flashvars = k + "=" + flashvarsObj[k];
}
}
}
if (hasPlayerVersion(swfVersionStr)) {
var obj = createSWF(att, par, replaceElemIdStr);
if (att.id == replaceElemIdStr) {
setVisibility(replaceElemIdStr, true);
}
callbackObj.success = true;
callbackObj.ref = obj;
}
else if (xiSwfUrlStr && canExpressInstall()) {
att.data = xiSwfUrlStr;
showExpressInstall(att, par, replaceElemIdStr, callbackFn);
return;
}
else {
setVisibility(replaceElemIdStr, true);
}
if (callbackFn) { callbackFn(callbackObj); }
});
}
else if (callbackFn) { callbackFn(callbackObj); }
},
switchOffAutoHideShow: function () {
autoHideShow = false;
},
ua: ua,
getFlashPlayerVersion: function () {
return { major: ua.pv[0], minor: ua.pv[1], release: ua.pv[2] };
},
hasFlashPlayerVersion: hasPlayerVersion,
createSWF: function (attObj, parObj, replaceElemIdStr) {
if (ua.w3) {
return createSWF(attObj, parObj, replaceElemIdStr);
}
else {
return undefined;
}
},
showExpressInstall: function (att, par, replaceElemIdStr, callbackFn) {
if (ua.w3 && canExpressInstall()) {
showExpressInstall(att, par, replaceElemIdStr, callbackFn);
}
},
removeSWF: function (objElemIdStr) {
if (ua.w3) {
removeSWF(objElemIdStr);
}
},
createCSS: function (selStr, declStr, mediaStr, newStyleBoolean) {
if (ua.w3) {
createCSS(selStr, declStr, mediaStr, newStyleBoolean);
}
},
addDomLoadEvent: addDomLoadEvent,
addLoadEvent: addLoadEvent,
getQueryParamValue: function (param) {
var q = doc.location.search || doc.location.hash;
if (q) {
if (/\?/.test(q)) { q = q.split("?")[1]; }
if (param == null) {
return urlEncodeIfNecessary(q);
}
var pairs = q.split("&");
for (var i = 0; i < pairs.length; i++) {
if (pairs[i].substring(0, pairs[i].indexOf("=")) == param) {
return urlEncodeIfNecessary(pairs[i].substring((pairs[i].indexOf("=") + 1)));
}
}
}
return "";
},
expressInstallCallback: function () {
if (isExpressInstallActive) {
var obj = getElementById(EXPRESS_INSTALL_ID);
if (obj && storedAltContent) {
obj.parentNode.replaceChild(storedAltContent, obj);
if (storedAltContentId) {
setVisibility(storedAltContentId, true);
if (ua.ie && ua.win) { storedAltContent.style.display = "block"; }
}
if (storedCallbackFn) { storedCallbackFn(storedCallbackObj); }
}
isExpressInstallActive = false;
}
}
};
} ();

// FILE: Object2.js (6e541d7d) 3/7/2014 11:24:14 AM

Object.size = function(obj) {
var size = 0;
if(obj.length) size = obj.length;
if(size == 0) {
try {
for (var propName in obj) {
if (obj.hasOwnProperty(propName)) size++;
}
} catch(err) {
logError('Javascript error: ' + err.message + ' occurred. Object size could not be determined.');
return Simulator.Constants.FAILURE;
}
}
return size;
};

// FILE: HTML2JSMap2.js (3c3fa47f) 3/7/2014 11:24:14 AM

Simulator.HTML2JSMap = function(sim) {
var source = 'HTML2JSMap';
var map = [];
var dbg = function() {return sim.getDebug();};
this.inspect = function(embedded, force) {
var buff = [];
var sep = '\n';
buff.push('Inspecting ' + source + sep);
for ( var i in map) {
buff.push(i + ' = ' + map[i].getName() + ' ' + map[i].getEname() + sep);
}
buff.push('End Inspecting ' + source + sep + sep);
if(!embedded) force == true ? debugf(buff.join('')) : debug(buff.join(''));
else return buff.join('');
};
this.mapJSFromHTML = function(jsObject, htmlElement) {
if(!jsObject || !htmlElement) dbg().logError(source, 'jsOject or htmlElement is null. Cannot map JSFromHTML');
else {
map[htmlElement.id] = jsObject;
}
};
this.getJSFromHTML = function(htmlElement) {
return map[htmlElement.id];
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};

// FILE: Constants2.js (5b242848) 3/7/2014 11:24:14 AM

Simulator.Constants = function() {};
Simulator.Constants.HIDDEN = false;
Simulator.Constants.VISIBLE = true;
Simulator.Constants.SUCCESS = 1;
Simulator.Constants.NONE = 0;
Simulator.Constants.FAILURE = -1;
Simulator.Constants.YES = 1;
Simulator.Constants.NO = 0;
Simulator.Constants.SIM_CONTAINER_NAME = 'container';
Simulator.Constants.TIME_BASED_ANIMATION = 'timeline';
Simulator.Constants.INTERACTIVE_ANIMATION = 'interactive';
Simulator.Constants.STATIC_ANIMATION = 'static';
Simulator.Constants.INPUT_PANEL_NAME = 'inputPanel';
Simulator.Constants.ANIMATION_PANEL_NAME = 'animationPanel';
Simulator.Constants.DATA_DISPLAY_PANEL_NAME = 'dataOutputPanel';
Simulator.Constants.CONTROL_PANEL_NAME = 'controlElementsPanel';
Simulator.Constants.ITERATION_DELIMITTER = '\\0x1D\\';  // Use to be ';'
Simulator.Constants.KEY_VALUE_DELIMITTER = '\\0x1F\\';   // Use to be ':'
Simulator.Constants.PAIR_DELIMITTER = '\\0x1E\\';  // Use to be ','
Simulator.Constants.MULTIPLE_VALUE_DELIMITTER = '|';
Simulator.Constants.SPEECH_LABEL_PREFIX = 'Move To ';
Simulator.Constants.SPEECH_ITEM_VALUE_PREFIX = 'Select ';
Simulator.Constants.SPEECH_CMD_ITEM_PREFIX = 'Click ';
Simulator.Constants.ANIMATION_FINISHED = 'animationFinished';
Simulator.Constants.ANIMATION_STARTED = 'animationStarted';
Simulator.Constants.ANIMATION_THREAD_FINISHED = 'animationThreadFinished';
Simulator.Constants.ANIMATION_LOADED = 'animationLoaded';
Simulator.Constants.ANIMATION_REPORT_STATUS = 'reportStatus';
Simulator.Constants.ANIMATION_REPORTING = 'animationReporting';
Simulator.Constants.ANIMATION_UNRESPONSIVE = 'animationUnresponsive';
Simulator.Constants.ANIMATION_ABORTED = 'animationAborted';
Simulator.Constants.ANIMATION_UNABLE_TO_START = 'animationUnableToStart';
Simulator.Constants.ANIMATION_NOT_READY = 0;
Simulator.Constants.PARAM_COMMAND = 'command';
Simulator.Constants.PARAM_INFO = 'info';
Simulator.Constants.PARAM_DATA = 'data';
Simulator.Constants.PARAM_INPUT = 'input';
Simulator.Constants.PARAM_UPDATE = 'update';
Simulator.Constants.PARAM_OUTPUT = 'output';
Simulator.Constants.PARAM_DEBUG_OUTPUT = 'debug';
Simulator.Constants.PARAM_ERROR = 'error';
Simulator.Constants.SET_ID_CMD = 'setID';
Simulator.Constants.PLAY_CMD = 'play';
Simulator.Constants.STOP_CMD = 'stop';
Simulator.Constants.REWIND_CMD = 'rewind';
Simulator.Constants.RESTART_CMD = 'restart';
Simulator.Constants.OUTPUT_REQ_CMD = 'outputRequest';
Simulator.Constants.INPUT_NAME_PART = 0;
Simulator.Constants.INPUT_VALUE_PART = 1;
Simulator.Constants.START_FRAME = 'startFrame';
Simulator.Constants.ANIMATION_COMPLETED = 'animationCompleted';
Simulator.Constants.ANIMATION_PLAYING = 'animationPlaying';
Simulator.Constants.ANIMATION_PAUSED = 'animationPaused';
Simulator.Constants.ANIMATION_STOPPED = 'animationStopped';
Simulator.Constants.ANIMATION_REWOUND = 'animationRewound';
Simulator.Constants.ANIMATION_READY = 'animationReady';
Simulator.Constants.ANIMATION_ERROR = 'animationError';
Simulator.Constants.ANIMATION_PROPERTIES = 'properties';
Simulator.Constants.GET_ANIMATION_PROPERTIES = 'properties';
Simulator.Constants.ANIMATION_ALIVE = 'alive';
Simulator.Constants.SIM_CALLBACK = 'Simulator.Animation.FlashAnimationInterface.AnimationMediaOutput';
Simulator.Constants.DEFAULT_INITIAL_TRIAL_NUM = 0;
Simulator.Constants.NO_DATA_INDICATOR = '';
Simulator.Constants.HTML5_ANIMATION = 'html5';
Simulator.Constants.FLASH_ANIMATION = 'flash';
Simulator.Constants.IMAGE_ANIMATION = 'image';
Simulator.Constants.HOTTEXT_ANIMATION = 'hotText';

// FILE: Whiteboard2.js (47c6306a) 3/7/2014 11:24:14 AM

Simulator.Whiteboard = function (sim) {
var categories = [];
var source = 'Whiteboard';
var dbg = function () {return sim.getDebug();};
var key = Math.random()*1000;
this.addCategory = function(catName) {
if(catName in categories) return false;
else {
categories[catName] = [];
return true;
}
};
this.getCategory = function(name) {
if(name in categories) return categories[name];
else return null;
};
this.getCategoryAsString = function(name, separator) {
var buff = [];
var num = 0;
if(name in categories) {
var cat = categories[name];
for(var item in cat) {
if(cat.hasOwnProperty(item)) {
if(num > 0) buff.push(Simulator.Constants.PAIR_DELIMITTER + ' ');
buff.push(item);
if(separator) buff.push(Simulator.Constants.KEY_VALUE_DELIMITTER + ' ');
else buff.push(Simulator.Constants.KEY_VALUE_DELIMITTER);
buff.push(this.getItem(name, item));
num++;
}
}
return buff.join('');
}
else return null;
};
this.categoryExists = function(categoryName) {
return category in categories;
};
this.itemExists = function(categoryName, itemName) {
if(categoryName in categories) {
var category = categories[categoryName];
return (itemName in category);
}
else return false;
};
this.addItem = function(category, item) {
if(category in categories) {
var cat= categories[category];
if(item in cat) return null;
else {
cat[item] = null;
return key;
}
} else return null;
};
this.setItem = function(category, item, value, itemKey) {
if(category in categories) {
if(key == itemKey) {
var cat = categories[category];
cat[item] = value;
return true;
}
else return false;
}
else return false;
};
this.getItem = function(category, theItem) {
if(category in categories) {
cat = categories[category];
if(cat[theItem]) return cat[theItem];
else return null;
}
else return null;
};
this.clearCategory = function(category) {
if(categories[category]) categories[category] = [];
};
this.clearWhiteboard = function() {
for(var p in categories) {
categories[p] = [];
}
};
this.inspect = function(embedded, force) {
var buff = [];
var sep = '\n\n';
buff.push('Inspecting Whiteboard:'); buff.push(sep);
for ( var i in categories) {
var aCat = categories[i];
buff.push('Inspecting '); buff.push(i); buff.push(' category:'); buff.push(sep);
for(var k in aCat) {
buff.push(i); buff.push('['); buff.push(k); buff.push('] = '); buff.push(aCat[k]); buff.push(sep);
}
}
if(!embedded) (force) ? dbg().debugf(buff.join(''), null, true) : dbg().debug(buff.join(''), null, true);
return buff.join('');
};
};

// FILE: Utils2.js (3547fea0) 3/7/2014 11:24:14 AM

Simulator.Utils.Utils = function (sim) {
var source = 'Utils';
var timeMark = 0;
var IE = 'Microsoft Internet Explorer';
var MSIE = 'MSIE';
var FIREFOX = 'Firefox';
var CHROME = 'Chrome';
var OPERA = 'Opera';
var SAFARI = 'Safari';
var sequenceNumber = 0;
var dbg = function () { return sim.getDebug(); };
this.getChildElement = function (id, numChild) {
var HTMLElement = document.getElementById(id);
var num = 0;
var child = null;
if (HTMLElement) {
var children = HTMLElement.childNodes;
if (chldren.length > 0) {
for (var i = 0; i < children.length; i++) {
child = children[i];
if (child.nodeName[0] != '#') {
if (num == numChild) return child;
else num++;
}
}
return null;
} else return HTMLElement;
} else dbg().logError(source, 'Could not get HTMLElement');
};
this.applyFilter = function (functionName, data) {
var result = null;
var elements = [];
switch (functionName) {
case 'max':
result = Math.max.apply(Math, data);
break;
case 'min':
result = Math.min.apply(Math, data);
break;
case 'first':
result = data[0];
break;
case 'last':
result = data[data.length - 1];
break;
case 'average':
var sum = 0;
for (var i = 0; i < data.length; i++) {
sum += parseFloat(data[i]);
}
result = sum / data.length;
break;
case 'sum':
var sum = 0;
for (var i = 0; i < data.length; i++) {
sum += parseFloat(data[i]);
}
result = sum;
break;
case 'numNonZero':
var num = 0;
for (var i = 0; i < data.length; i++) {
if (data[i] !== 0) num++;
}
result = num;
break;
case 'zeroNotNull':
if (data[0] == 'null') result = '0';
else result = data[0];
break;
case 'blankNotNull':
if (data[0] === 'null') result = Simulator.Constants.NO_DATA_INDICATOR;
else result = data[0];
break;
case 'blankNotZero':
if (parseFloat(data[0]) == 0) result = Simulator.Constants.NO_DATA_INDICATOR;
else result = data[0];
break;
default:
if (functionName.substr(0, 4) == 'set[') {
var resultArray = [];
elements = functionName.replace(/set\s*\[/, '');
elements = elements.replace(/\s*\]$/, '');
var parts = functionName.substr(4).split(',');
for (var i = 0; i < parts.length; i++) {
resultArray.push(data[parseInt(parts[i])]);
}
result = resultArray.join(',');
}
}
return result;
};
this.getFileName = function (path, includeExtension) {
var filename = path.substring(path.lastIndexOf('/') + 1);
var index = filename.lastIndexOf('.');
if (!includeExtension) filename = filename.substring(0, index);
return filename;
};
this.getElementsByClassName = function (classname, node) {
if (!node) node = document.getElementsByTagName('body')[0];
var a = [];
var re = new RegExp('\\b' + classname + '\\b');
var els = node.getElementsByTagName('*');
for (var i = 0, j = els.length; i < j; i++)
if (re.test(els[i].className)) a.push(els[i]);
return a;
};
this.getElementsByTagValue = function (node, tagName, tagValue) {
if (!node) node = document.getElementsByTagName('body')[0];
var a = [];
var els = node.getElementsByTagName(tagName);
for (var i = 0; j < els.length; i++)
if (els[i].nodeValue == tagValue) a.push(els[i]);
return a;
};
this.associationStoreToString = function (associationStore, sep) {
buff = [];
num = 0;
for (var i in associationStore) {
if (associationStore.hasOwnProperty(i)) {
if (num > 0) buff.push(', ');
if (sep) buff.push('\n');
buff.push(i); buff.push(': '); buff.push(associationStore[i]);
num++;
}
}
return buff.join('');
};
this.assocArrayIsEmpty = function (theArray) {
for (var i in theArray) {
if (i) {
if (theArray.hasOwnProperty(i))
return false;
}
}
return true;
};
this.appendText = function (node, txt, noBreak) {
if (!noBreak) {
node.innerHTML = node.innerHTML + '<br>';
}
node.appendChild(document.createTextNode(txt));
if (!noBreak) {
node.innerHTML = node.innerHTML + '<br>';
}
};
this.appendBlankVertcalSpace = function (parentElement, theNum) {
var num = 1;
var newBreak = null;
if (theNum) num = theNum;
for (var i = 0; i < num; i++) {
newBreak = document.createElement('br');
newBreak.style.border = 'none';
parentElement.appendChild(newBreak);
}
};
this.appendElement = function (node, tag, id, htm) {
var ne = document.createElement(tag);
if (id) ne.id = id;
if (htm) ne.innerHTML = htm;
node.appendChild(ne);
};
this.getNextSequenceNumber = function () {
return ++sequenceNumber;
};
this.replaceAll = function (inThisString, replaceThis, withThis) {
var re = new RegExp('[' + replaceThis + ']', 'g');
return inThisString.replace(re, withThis);
};
this.setObjectDimensions = function (governingObject, subjectObject) {
var dimensions = setDimensions(governingObject.height, governingObject.width, subjectObject.height, subjectObject.width);
subjectObject.height = dimensions.height;
subjectObject.width = dimensions.width;
};
this.removeHeadingAndTrailingQuotes = function (theString, theTypeOfQuotes) {
var fIndex, lIndex, strLength;
var typeOfQuotes = 'both';
if (theTypeOfQuotes) typeOfQuotes = theTypeOfQuotes;
if (theString) theString = theString.trim();
if (typeOfQuotes === 'double' || typeOfQuotes === 'both') {
fIndex = theString.indexOf('"');
lIndex = theString.lastIndexOf('"');
strLength = theString.length;
if (fIndex == 0 && lIndex == strLength - 1)
theString = theString.substr(1, lIndex - 1);
}
if (typeOfQuotes === 'single' || typeOfQuotes === 'both') {
fIndex = theString.indexOf("'");
lIndex = theString.lastIndexOf("'");
strLength = theString.length;
if (fIndex == 0 && lIndex == strLength - 1)
theString = theString.substr(1, lIndex - 1);
}
return theString;
};
this.setDimensions = function (governingObjectHeight, governingObjectWidth, subjectObjectHeight, subjectObjectWidth, padding) {
var x = subjectObjectHeight / governingObjectHeight;
var y = subjectObjectWidth / governingObjectWidth;
var z = subjectObjectHeight / subjectObjectWidth;    // Get proportion
if (!padding)
padding = 0;
if (x >= y) {
subjectObjectHeight = governingObjectHeight;
subjectObjectWidth = subjectObjectHeight / z;
} else {
subjectObjectWidth = governingObjectWidth;
subjectObjectHeight = subjectObjectWidth * z;
}
var dimensions = {};
if (z > 1) {
dimensions.width = subjectObjectWidth - padding;
dimensions.height = dimensions.width * z;
} else {
dimensions.height = subjectObjectHeight - padding;
dimensions.width = dimensions.height / z;
}
return dimensions;
};
this.elementInArray = function (array, element, isSubstring) {
for (var i = 0; i < array.length; i++) {
if (!isSubstring) if (array[i] == element) return true;
else if (array[i].indexOf(element) != -1) return true;
}
return false;
};
this.getAttributes = function (node) {
var attr = [];
var attributes = node.attributes;
if (attributes != null && attributes != undefined) {
for (var j = 0; j < attributes.length; j++) {
var id = attributes[j].nodeName;
attr[id] = attributes[j].nodeValue;
}
}
return attr;
};
this.getNumberLength = function (num) {
var str = num + '';
return str.length;
};
this.isInternetExplorer = function () {
return navigator.userAgent.indexOf(MSIE) != -1;
};
this.isIE8orBelow = function () {
var info = this.getBrowserInfo(['name', 'major version'], null);
return (info['name'] === IE && parseInt(info['major version']) < 9);
};
this.isFireFox = function () {
return navigator.userAgent.indexOf(FIREFOX) != -1;
};
this.isChrome = function () {
return navigator.userAgent.indexOf(CHROME) != -1;
};
this.isOpera = function () {
return navigator.userAgent.indexOf(OPERA) !== -1;
};
this.isSafari = function () {
return navigator.userAgent.indexOf(SAFARI) !== -1;
};
this.getBrowserInfo = function (infoArray, sep) {
var nVer = navigator.appVersion;
var nAgt = navigator.userAgent;
var browserName = navigator.appName;
var fullVersion = '' + parseFloat(navigator.appVersion);
var majorVersion = parseInt(navigator.appVersion, 10);
var nameOffset, verOffset, ix;
if ((verOffset = nAgt.indexOf(OPERA)) !== -1) {
browserName = opera;
fullVersion = nAgt.substring(verOffset + 6);
if ((verOffset = nAgt.indexOf('Version')) !== -1)
fullVersion = nAgt.substring(verOffset + 8);
}
else if ((verOffset = nAgt.indexOf(MSIE)) !== -1) {
browserName = IE;
fullVersion = nAgt.substring(verOffset + 5);
}
else if ((verOffset = nAgt.indexOf(CHROME)) !== -1) {
browserName = CHROME;
fullVersion = nAgt.substring(verOffset + 7);
}
else if ((verOffset = nAgt.indexOf(SAFARI)) !== -1) {
browserName = SAFARI;
fullVersion = nAgt.substring(verOffset + 7);
if ((verOffset = nAgt.indexOf('Version')) !== -1)
fullVersion = nAgt.substring(verOffset + 8);
}
else if ((verOffset = nAgt.indexOf(FIREFOX)) !== -1) {
browserName = FIREFOX;
fullVersion = nAgt.substring(verOffset + 8);
}
else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) <
(verOffset = nAgt.lastIndexOf('/'))) {
browserName = nAgt.substring(nameOffset, verOffset);
fullVersion = nAgt.substring(verOffset + 1);
if (browserName.toLowerCase() === browserName.toUpperCase()) {
browserName = navigator.appName;
}
}
if ((ix = fullVersion.indexOf(';')) !== -1)
fullVersion = fullVersion.substring(0, ix);
if ((ix = fullVersion.indexOf(' ')) !== -1)
fullVersion = fullVersion.substring(0, ix);
majorVersion = parseInt('' + fullVersion, 10);
if (isNaN(majorVersion)) {
fullVersion = '' + parseFloat(navigator.appVersion);
majorVersion = parseInt(navigator.appVersion, 10);
}
buff = [];
if (!sep) sep = ' ';
for (var i = 0; i < infoArray.length; i++) {
switch (infoArray[i]) {
case 'name': buff.push('Name  = ' + browserName);
break;
case 'major version': buff.push('Major version = ' + majorVersion);
break;
case 'full version': buff.push('Full version = ' + fullVersion);
break;
case 'appName': buff.push('App Name = ' + navigator.appName);
break;
case 'agent': buff.push('User Agent = ' + navigator.userAgent);
break;
case 'platform': buff.push('Platform = ' + navigator.platform);
break;
}
}
return buff.join(sep);
};
this.markTime = function () {
var d = new Date;
timeMark = d.getTime();
};
this.getElapsedTime = function () {
var d = new Date;
var nowTime = d.getTime();
return nowTime - timeMark;
};
this.getClass = function (obj) {
if (typeof obj === "undefined")
return "undefined";
if (obj === null)
return "null";
else return Object.prototype.toString.call(obj).match(/^\[object\s(.*)\]$/)[1];
};
this.getJSObjName = function (obj) {
if (!obj) return null;
else if (obj.getName) return obj.getName();
else if (obj.name) return obj.name;
else return this.getJSObjNameViaConstructor(obj);
};
this.getJSObjNameViaConstructor = function (obj) {
var str = obj.constructor.name;
if (!str) str = obj.constructor.toString();
var index = str.indexOf('(');
if (index > -1) {
str = str.substring(0, index);
index = str.indexOf('function');
if (index == 0) str = str.substring('function'.length);
}
return str.trim();
};
this.createTimeOutCallbackStr = function (obj, fctn, args) {
var buff = [];
buff.push(obj);
buff.push('.');
buff.push(fctn);
buff.push('(\'');
buff.push(args);
buff.push('\')');
return buff.join('');
};
this.bindEvent = function (el, event, handler) {
if (el.addEventListener)
el.addEventListener(event, handler, false);
else if (el.attachEvent)
el.attachEvent("on" + event, handler);
}
this.canPlayHtml5 = function () {
if (YAHOO.env.ua.ie > 0 &&
YAHOO.env.ua.ie < 9) return false;
if (Util.Browser.getFirefoxVersion() > 0 &&
Util.Browser.getFirefoxVersion() < 4) return false;
return true;
}
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
};
};

// FILE: Debug2.js (d3da706c) 3/7/2014 11:24:14 AM

Simulator.Utils.Debug = function (sim) {
var Count = 0;
var debugOn = false;
var prevSetting = false;
var dLevel = 'SimWarning';
var stackLevel = 2;
var eventMgr = function () { return sim.getEventManager(); }
var util = function() { return sim.getUtils(); };
this.tdebug = function (source, str1, appendCount, appendTime, str2) {
if (typeof console != 'object') return;
else if (debugOn) {
var buff = [];
if (source) {
if(util().isFireFox()) {
var line = callerLine((new Error).stack.split("\n")[stackLevel]);
buff.push(source + ' line ' + line + ': ');
}
else buff.push(source + ': ');
}
buff.push(str1);
if (appendCount) buff.push(Count++);
if (appendTime) buff.push(getTime());
if (str2) buff.push(str2);
console.log(buff.join(' '));
}
};
this.debug = function (source, str, obj, trace) {
if (typeof console != 'object') return;
var buff = [];
if (debugOn) {
if (source) {
if(util().isFireFox()) {
var line = callerLine((new Error).stack.split("\n")[stackLevel]);
buff.push(source + ' line ' + line + ': ');
}
else buff.push(source + ': ');
}
buff.push(str);
if (obj) buff.push(' = '); buff.push(obj); buff.push('\n\n');
console.log(buff.join(''));
if (trace == 'trace') {
console.log('--- Program stack trace: ---\n');
printStackTrace();
console.log('\n--- End of program stack trace ---\n\n');
}
}
};
this.debugf = function (source, str, obj, trace) {
if (typeof console != 'object') return;
var buff = [];
if (source) {
if(util().isFireFox()) {
var line = callerLine((new Error).stack.split("\n")[stackLevel]);
buff.push(source + ' line ' + line + ': ');
}
else buff.push(source + ': ');
}
buff.push(str);
if (obj) buff.push(' = '); buff.push(obj); buff.push('\n\n');
console.log(buff.join(''));
if (trace == 'trace') {
console.log('--- Program stack trace: ---\n');
printStackTrace();
console.log('\n--- End of program stack trace ---\n\n');
}
};
var iDest = 'console';
this.setIDest = function (dest) {
iDest = dest;
};
this.iDebug = function (source, str, obj, force) {
if (typeof console != 'object') return;
if (debugOn || force) {
var buff = [];
if (source) {
if(util().isFireFox()) {
var line = callerLine((new Error).stack.split("\n")[stackLevel]);
buff.push(source + ' line ' + line + ': ');
}
}
buff.push(str);
if (obj) buff.push(' = '); buff.push(obj); buff.push('\n\n');
if (iDest == 'screen') Simulator.showAlert('',buff.join(''));
else console.log(buff.join(''));
}
};
this.writeToConsole = function(str) {
console.log(str);
};
this.inspectArray = function (source, name, theArray, doNotIinspectObjects, embedded, force) {
if (typeof console != 'object') return;
var buff = [];
var sep = '\n\n';
if (debugOn || force) {
if (source) {
if(util().isFireFox()) {
var line = callerLine((new Error).stack.split("\n")[stackLevel]);
buff.push(source + ' line ' + line + ': ');
}
else buff.push(source + ': ');
}
buff.push('Inspecting '); buff.push(name); buff.push(sep);
if (theArray.length == 0) {
for (var p in theArray) {
buff.push(name); buff.push('['); buff.push(p); buff.push('] = ');
if(theArray[p].getSourceName) { buff.push(theArray[p].getSourceName()); buff.push(sep);}
else if(theArray[p].getName) { buff.push(theArray[p].getName()); buff.push(sep);}
else {buff.push(String(theArray[p])); buff.push(sep);}
if(!doNotIinspectObjects) if (theArray[p].inspect != undefined) buff.push(theArray[p].inspect(true));
}
} else {
for (var i = 0; i < theArray.length; i++) {
buff.push(name); buff.push('['); buff.push(i); buff.push('] = ');
if(theArray[i].getSourceName) {
buff.push(theArray[i].getSourceName()); buff.push(' ');
}
if(theArray[i].getName) {
buff.push(theArray[i].getName()); buff.push(sep);
}
else {
buff.push(theArray[i]); buff.push(sep);
}
buff.push('Inspecting '); buff.push(typeof theArray[i]); buff.push(sep);
if(!doNotIinspectObjects) if (theArray[i].inspect != undefined) buff.push(theArray[i].inspect(true));
}
}
buff.push('End of inspection of '); buff.push(name); buff.push(sep);
console.log(buff.join(''));
}
};
this.setDebug = function (flag) {
prevSetting = debugOn;
if(flag === 'on' || flag === true) debugOn = true;
else debugOn = false;
};
this.setErrorReportLevel = function (level) {
dLevel = (level == 'SimWarning' || level == 'SimError' || level == 'SimFatalError') ? level : 'SimError';
};
this.debugIsOn = function () {
return debugOn;
};
this.resetDebug = function () {
debugOn = prevSetting;
};
this.logWarning = function (source, str, notify, trace) {
var trace = 'noTrace';
if (trace) trace = 'trace';
logMsg = true;
if (dLevel == 'SimWarning') this.debugf(source, 'Warning: ' + str                                                            );
logMsg = false;
if (notify) Simulator.showAlertWarning(str);
};
this.logError = function (source, str, notify, noTrace) {
var noTrace = 'trace';
if (noTrace) trace = 'noTrace';
logMsg = true;
if (dLevel != 'SimFatalError') this.debugf(source, '**** ERROR: ' + str                                                            );
logMsg = false;
if (notify) Simulator.showAlert('**** ERROR: ' + str);
};
this.logFatalError = function (source, str) {
logMsg = true;
this.debugf(source, '!!!!!! FATAL ERROR: ' + str                                                                                                             );
logMsg = false;
eventMgr().postEvent(new Simulator.Event(this, 'info', 'fatalErrorOccurred', str));
Simulator.showAlert('Fatal Error',str);
};
function AssertException(message) {
this.message = message;
AssertException.prototype.toString = function () {
return 'AssertException: ' + this.message;
};
}
this.assert = function (exp, message) {
if (!exp) {
throw new AssertException(message);
}
};
function printStackTrace() {
if (isFireFox()) console.trace();
else if (isChrome()) {
var obj = {};
Error.captureStackTrace(obj, getStackTrace);
console.log(obj);
}
else if (isInternetExplorer());
else if (isSafari());
else if (isOpera());
else console.log('Unknown browser: ' + getBrowserInfo(['name']));
}
function callerLine(str) {
var index = str.lastIndexOf(':');
return str.substr(index + 1);
};
};

// FILE: Queue2.js (9300fb40) 3/7/2014 11:24:14 AM

Simulator.Utils.Queue = function (sim) {
var source = 'Queue';
var dbg = function () { return sim.getDebug(); };
var queue = [];
var offset = 0;
this.length = function () {
return (queue.length - offset);
};
this.isEmpty = function () {
return (queue.length == 0);
};
this.insertAt = function (item, index) {
var offsetIndex = index + offset;
if (offsetIndex >= 0 && offsetIndex < queue.length) queue.splice(offsetIndex, 0, item);
else if (offsetIndex == queue.length) queue.push(item);
};
this.add = function (item) {
queue.push(item);
};
this.elementAt = function (index) {
var offsetIndex = index + offset;
if (offsetIndex >= 0 && offsetIndex < queue.length) return queue[offsetIndex];
else return undefined;
};
this.remove = function () {
if (queue.length == 0)
return null;
var item = queue[offset];
if (++offset * 2 >= queue.length) {
queue = queue.slice(offset);
offset = 0;
}
return item;
};
this.peek = function () {
return (queue.length > 0 ? queue[offset] : null);
};
this.clear = function () {
var item = this.remove();
while (item != null) {
item = this.remove();
}
};
this.inspect = function (embedded, force) {
var buff = [];
buff.push('\nInspecting Queue:');
buff.push('Contains ' + queue.length + (queue.length == 1 ? ' item' : ' items'));
buff.push('Queue offset = ' + offset);
for (var i = offset; i < queue.length; i++) {
buff.push('queue[' + i + '] = ' + queue[i]);
}
buff.push('End inspecting Queue\n');
if (embedded) return buff.join('\n');
else {
if (force) debugf(buff.join('\n'));
else debug(buff.join('\n'));
}
};
this.entriesAsString = function () {
var buff = [];
for (var i = 0; i < queue.length; i++) {
buff.push(queue[i]);
}
return buff.join(',');
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Utils.OrderedQueue = function (sim) {
Simulator.Utils.Queue.call(this, sim);
var source = 'OrderedQueue';
dbg = function () {return sim.getDebug();};
this.add = function (item) {
var len = this.length();
if (typeof (item) != 'object') {
if (this.isEmpty()) {
this.insertAt(item, 0);
return;
}
else for (var i = 0; i < len; i++) {
if (item < this.elementAt(i)) {
this.insertAt(item, i);
return;
}
}
this.insertAt(item, len);
}
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Utils.OrderedQueue.prototype = new Simulator.Utils.Queue();
Simulator.Utils.OrderedQueue.parent = Simulator.Utils.Queue;
Simulator.Utils.OrderedQueue.prototype.constructor = Simulator.Utils.OrderedQueue;

// FILE: Stack2.js (525edc9c) 3/7/2014 11:24:14 AM

Simulator.Utils.Stack = function (sim) {
var source = 'Stack';
this.store = [];
var dbg = function () {return sim.getDebug();};
this.push = function (data) {
this.store.push(data);
};
this.pop = function () {
if (this.store.length > 0) return this.store.pop();
else return null;
};
this.peek = function () {
return this.store[this.store.length - 1];
};
this.inspect = function (embedded, forced) {
var buff = [];
buff.push('\nInspecting Stack:');
buff.push('Stack contains ' + this.store.length + (this.store.length == 1 ? ' element' : ' elements'));
var last = this.store.length - 1;
for (var i = last; i >= 0; i--) {
if (typeof (this.store[i]) == 'object') {
if (this.store[i].inspect != undefined) buff.push(this.store[i].inspect(true, true));
}
else buff.push('stack nonobject element: ' + this.store[i]);
}
buff.push('End inspecting Stack\n');
if (embedded) return buff.join('\n');
else forced == null ? debug(buff.join('\n')) : debugf(buff.join('\n'));
};
this.elementAt = function (num) {
if (num < this.store.length && num >= 0) return this.store[num];
};
this.insertAt = function (obj, index) {
if (index >= 0 && index < this.store.length) this.store.splice(index, 0, obj);
else if (index == this.store.length) this.store.push(obj);
};
this.numElements = function () {
return this.store.length;
};
this.clear = function () {
var item = this.pop();
while (item != null) {
item = this.pop();
}
};
this.entriesAsString = function () {
var buff = [];
for (var i = this.store.length - 1; i > -1; i--) {
buff.push(this.store[i]);
}
return buff.join(',');
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};

// FILE: String2.js (5355229f) 3/7/2014 11:24:14 AM

String.prototype.trim = function () {
return this.replace(/^\s+|\s+$/g,'');
};
String.prototype.ltrim = function() {
return this.replace(/^\s+/,'');
};
String.prototype.rtrim = function() {
return this.replace(/\s+$/,'');
};

// FILE: Dictionary2.js (d6257e6b) 3/7/2014 11:24:14 AM

Simulator.Utils.Dictionary = function (sim) {
var source = 'Dictionary';
var elements = [];
var dbg = function () {return sim.getDebug();};
this.exists = function (key) {
return (elements[key] == undefined);
};
this.keyExists = function (key) {
return (key in elements);
};
this.setValue = function (key, value) {
this.addKey(key);
elements[key] = value;
};
this.addKey = function (key, value) {
if (!this.keyExists(key)) {
elements[key] = '';
}
};
this.remove = function (key) {
delete elements[key];
};
this.lookup = function (key) {
return elements[key];
};
this.keys = function () {
var keys = [];
for (var key in elements) {
if (key != undefined && key != null) keys.push(key);
}
return keys;
};
this.size = function () {
var i = 0;
for (key in elements) {
i++;
}
return i;
};
this.toString = function () {
var buff = new Simulator.Utils.StringBuffer();
var str;
for (key in elements) {
if (key != undefined && key != null) {
if (elements[key] instanceof Array) {
str = (elements[key]).join('  ');
} else str = elements[key];
buff.append('key = ').append(key).append(', value = ').append(str).append('\n');
}
}
return buff.toString();
};
this.toAssociativeArray = function() {
dbg().inspectArray(source, 'elements', elements);
return elements;
};
this.inspect = function (embedded, forced) {
buff = [];
var sep = '\n\n';
buff.push('Inspecting Dictionary'); buff.push(sep);
buff.push(this.toString()); buff.push(sep);
if (!embedded) (forced) ? debugf(buff.join('')) : debug(buff.join(''));
return buff.join('');
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Utils.StringBuffer = function () {
this.buffer = [];
this.append = function (string) {
this.buffer.push(string);
return this;
};
this.toString = function () {
return this.buffer.join('');
};
};

// FILE: Table2.js (48412901) 7/23/2014 4:30:37 PM

Simulator.Utils.Table = function (incompleteRows, tableName, sim) {
var source = 'Table';
var columns = [];
var typedElements = [];
var columnNames = [];
var contentsForInCompleteRows = false;
var name = tableName;
var maxRowNum = -1;
var dbg = function () { return sim.getDebug(); };
var simMgr = function () { return sim.getSimulationManager(); };
var scoringTable = function () { return sim.getScoringTable(); };
this.getName = function () {
return name;
};
if (incompleteRows) contentsForInCompleteRows = true;
this.setMaxRowNum = function (num) {
if (num) maxRowNum = num;
};
this.addElement = function (name, type) {
if (!(name in columns)) {
columns[name] = [];
columnNames.push(name);
if (type) {
if (!(type in typedElements)) {
var values = new Array();
typedElements[type] = values;
}
typedElements[type].push(name);
}
}
};
this.cloneInputsForOutputs = function () {
var outputs = typedElements['output'];
if (!outputs) {
var values = new Array();
typedElements['output'] = values;
outputs = typedElements['output'];
}
for (var p in columns) {
if (columns.hasOwnProperty(p)) {
if (!outputs.hasOwnProperty(p)) {
typedElements['output'].push(p);
}
}
}
};
this.clearTable = function (clearOutputs) {
for (var p in columns) {
if (columns.hasOwnProperty(p)) {
var col = columns[p];
for (var j = 0; j < col.length; j++) col[j] = '';
}
}
if (clearOutputs) {
var outputs = typedElements['output'];
if (outputs) {
for (var t in outputs) {
if (outputs.hasOwnProperty(t)) {
outputs[t] = '';
}
}
}
}
};
this.clearEntry = function (colName, rowNum) {
if (columns.hasOwnProperty(colName)) {
var col = columns[colName];
col[rowNum] = '';
}
};
this.clearRow = function (rowNum, clearOutputs, deleteRow) {
for (var p in columns) {
if (columns.hasOwnProperty(p)) {
var col = columns[p];
col[rowNum] = '';
}
}
if (clearOutputs) {
var outputs = typedElements['output'];
if (outputs) {
for (var t in outputs) {
if (outputs.hasOwnProperty(t)) {
outputs[rowNum] = '';
}
}
}
}
};
this.deleteEmptyRows = function () {
var numRows = getNumRows();
for (var row = 0; row < numRows; row++) {
if (rowIsEmpty(row)) deleteRow(row);
}
};
this.outputEntered = function () {
var outputs = typedElements['output'];
if (outputs) {
for (var i = 0; i < outputs.length; i++) {
if (!this.isColumnEmpty(outputs[i])) return true;
}
return false;
}
return false;
};
function deleteRow(num) {
size = Object.size(columns);
for (var col = 0; col < size; col++) {
aColName = columnNames[col];
columns[aColName].splice(num, 1);
}
}
this.isColumnEmpty = function (elementName) {
if (columns[elementName]) {
for (var i = 0; i < columns[elementName].length; i++) {
if (columns[elementName][i] != '') return false;
}
return true;
}
else return true;
};
this.deleteElement = function (elementName) {
if (elementName in columns) delete columns[elementName];
for (t in typedElements) {
for (var j = 0; j < typedElements[t].length; j++) {
if (typedElements[t][j] == elementName) typedElements[t].splice(j, 1);
}
}
};
this.setValue = function (colName, rowNum, value) {
var theValue = null;
if (value instanceof Array) {
theValue = value.join(', ');
}
else theValue = value;
if (rowNum == null || rowNum < 0) {
rowNum = simMgr().getTrialNum() - 1;
}
if (rowNum > -1) {
if (!columns[colName]) columns[colName] = [];
columns[colName][rowNum] = theValue;
} else {
dbg().logError(source, 'rowNum = ' + rowNum + ' in ' + name + '.setValue');
}
};
this.getElementsOfType = function (type) {
if (typedElements[type]) return typedElements[type];
else return null;
};
function getNumRows() {
var maxLen = 0;
var len = 0;
for (var p in columns) {
len = columns[p].length;
maxLen = Math.max(len, maxLen);
}
return maxLen;
}
this.getContents = function () {
var buff = [];
var colNames = [];
var maxLen = 0;
var len = 0;
var i = 0;
var aColName = null;
buff.push('<responseTable>');
buff.push('   <tr>');
for (var p in columns) {
buff.push('      <th id = "' + p + '">' + p + '</th>');
len = columns[p].length;
maxLen = Math.max(len, maxLen);
colNames[i++] = p;
}
if ((maxRowNum > 0) && (maxLen > maxRowNum)) {
maxLen = maxRowNum;
}
buff.push('   </tr>');
var size = colNames.length;
var value = null;
for (var row = 0; row < maxLen; row++) {
if (!contentsForInCompleteRows && !rowIsCompletlyFilledIn(row)) break;
else {
buff.push('   <tr>');
for (var col = 0; col < size; col++) {
aColName = colNames[col];
value = columns[aColName][row];
if (value == undefined || value == null) value = '';
if (value && value.indexOf && value.indexOf('<') != -1)
value = '<![CDATA[' + value + ']]>';
buff.push('      <td>' + value + '</td>');
}
buff.push('   </tr>');
}
}
buff.push('</responseTable>');
return buff.join('\n');
};
function rowIsCompletlyFilledIn(rowNum) {
var size = Object.size(columns);
for (var col = 0; col < size; col++) {
aColName = columnNames[col];
if (columns[aColName][rowNum] == '') return false;
}
return true;
}
function rowIsEmpty(rowNum) {
var size = Object.size(columns);
for (var col = 0; col < size; col++) {
aColName = columnNames[col];
if (columns[aColName][rowNum] == undefined) continue;
else if (columns[aColName][rowNum] != '') return false;
}
return true;
}
this.getNumNonEmptyRows = function () {
var maxLen = 0;
var numRows = 0;
for (var p in columns) {
numRows = 0;
len = columns[p].length;
for (var row = 0; row < len; row++) {
if (columns[p][row] != '') numRows++;
}
maxLen = Math.max(numRows, maxLen);
}
return maxLen;
};
this.restoreResponseTable = function (node) {
var child = null;
var attr = null;
var text = null;
var colNum = -1;
var rowNum = -2;
this.clearTable();
var children = node.childNodes;
for (var q = 0; q < children.length; q++) {
if (children[q].nodeName == 'tr') {
rowNum++;
colNum = -1;
child = children[q];
for (var m = 0; m < child.childNodes.length; m++) {
if (child.childNodes[m].nodeName == 'td') {
colNum++;
text = child.childNodes[m].textContent;
scoringTable().setValue(columnNames[colNum], rowNum, text);
} else if (child.childNodes[m].nodeName == 'th') {
attr = child.childNodes[m].attributes;
for (var j = 0; j < attr.length; j++) {
if (attr[j].nodeValue[0] != '#') {
columnNames.push(attr[j].nodeValue);
if (!attr[j].nodeValue in columns) dbg().logFatalError(source, 'response column name: ' + columnNames[j] + ' is not in ' + name + ' column names');
}
}
}
}
}
}
};
this.inspectElementTypes = function (embedded, force) {
var buff = [];
var aType = null;
buff.push('Inspecting typedElements:');
for (var e in typedElements) {
buff.push('  ' + e + ' type elements:');
aType = typedElements[e];
for (var j = 0; j < aType.length; j++) {
buff.push('    ' + aType[j]);
}
}
buff.push('End inspecting typeElements');
if (embedded) return buff.join('\n');
else (force === null) ? debug(buff.join('\n')) : debugf(buff.join('\n'));
};
this.inspect = function (embedded, force) {
var str = this.getContents();
var preface = name + 'Table output:\n';
if (embedded) return str;
else {
if (!force) debug(preface + str);
else debugf(preface + str);
}
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};

// FILE: PersistentVariableDataBase2.js (d79e17f2) 3/7/2014 11:24:14 AM

Simulator.Utils.PersistentVariableDataBase = function (sim) {
var source = 'PersistentVariableDB';
var store = [];
var dbg = function () {return sim.getDebug();};
this.updateElement = function (element, value, operation) {
if (element in store) {
if (!isNaN(value)) {
currentValue = store[element];
if (!operation) currentValue += parseFloat(value);
else switch (operation) {
case '+':
currentValue += parseFloat(value);
break;
case '*':
currentValue *= parseFloat(value);
break;
case '/':
currentValue /= parseFloat(value);
break;
case '-':
currentValue -= parseFloat(value);
break;
case 'overwrite':
currentValue = value;
break;
default:
dbg().logWarning(source, 'Invalid operator ' + operator + ' passed to PersistentVariableDataBase.updateElement. No update occurred');
break;
}
store[element] = currentValue;
} else store[element] = value;
}
else {
if (!isNaN(value)) store[element] = parseFloat(value);
else store[element] = value;
}
return this.getElementValue(element);
};
this.setElementTo = function (element, num) {
store[element] = num;
};
this.getElementValue = function (element) {
if (element in store) return store[element];
else return null;
};
this.getContents = function () {
return store;
};
this.inspect = function (embedded, force) {
var buff = [];
buff.push('Inspecting ' + source);
for (var p in store) {
buff.push('   ' + source + '[' + p + '] = ' + store[p]);
}
if (embedded) return buff.join('\n');
else force == true ? debugf(buff.join('\n')) : debug(buff.join('\n'));
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};

// FILE: SimItem2.js (06b0ebae) 3/7/2014 11:24:14 AM

Simulator.SimItem = function(sim) {
var source = 'SimItem';
var eName = 'SimItem';
var simId = null;
var IDNum = -1;
var dbg = function() {return sim.getDebug();};
var simDocument = function() { return sim.getSimDocument(); };
if(sim) {
simId = sim.getSimID();
}
this.getEname = function() {
return eName;
};
this.setEname = function(newEname) {
eName = newEname;
return this;
};
this.createItemID = function (reset, itemNum, aName) {
var name = (!aName) ? this.getName() : aName;
if (itemNum != null) {
if (itemNum > -1) return name + 'Item' + simId + itemNum;
else {
IDNum++;
return name + 'Element' + simId + IDNum;
}
}
else {
if (reset) IDNum = -1;
++IDNum;
return name + 'Item' + simId + IDNum;
}
};
this.getNodeID = function () {
return nodeID;
};
this.inspect = function(embedded, force) {
var buff = [];
var sep = '\n';
buff.push('Inspecting ' + source + sep);
for ( var i in this) {
if (i == 'items') {
buff.push(this.parent.inspect());
} else {
if (i.substr(0, 3) == 'get') {
buff.push(i.charAt(3).toLowerCase() + i.slice(4));
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
}
buff.push('End Inspecting ' + source + sep + sep);
if(!embedded) force == true ? dbg().debugf(source, buff.join('')) : dbg().debug(source, buff.join(''));
else return buff.join('');
};
this.setAttributes = function (attr) {
for (var i in attr) {
switch (i) {
case 'eName':
this.setEname(attr[i]);
break;
}
}
};
};

// FILE: KeyboardInput2.js (6de9896b) 5/2/2014 12:55:58 PM

Simulator.Input.KeyboardInput = function (sim) {
var KEY = 0;
var ELEMENT = 1;
var ITEM = 2;
var source = 'KeyboardInput';
var dbg = function () { return sim.getDebug(); };
var eventMgr = function () { return sim.getEventManager(); };
var simMgr = function () { return sim.getSimulationManager(); };
var elementSelected = false;
var focusableElements = [];
var inputIndex = 0;
var itemIndex = -1;
this.addFocusableElement = function (element, elementID, itemID) {
focusableElements.push([]);
focusableElements[focusableElements.length - 1][KEY] = elementID;
focusableElements[focusableElements.length - 1][ELEMENT] = element;
focusableElements[focusableElements.length - 1][ITEM] = [];
};
this.addFocusableElementItem = function (element, elementID, itemID, position) {
var index = elementInDB(elementID);
if (index == -1) {
this.addFocusableElement(element, elementID, itemID);
var items = [];
items.push(itemID);
focusableElements[focusableElements.length - 1][ITEM] = items;
}
else {
var items = focusableElements[index][ITEM];
if (items == null) {
items = [];
items.push(itemID);
}
else if ((items.length == 0) || (!position) || (items.length <= position))
items.push(itemID);
else
items.splice(position, 0, itemID);
}
};
this.inspect = function (force) {
var buff = [];
buff.push("Inspecting focusableElements:");
for (var i = 0; i < focusableElements.length; i++) {
buff.push("[" + i + "] = " + focusableElements[i][KEY] + ", " + focusableElements[i][ELEMENT].getName() + ", " + focusableElements[i][ITEM]);
}
buff.push("End inspecting focusableElements");
force == null ? debug(source, buff.join('\n')) : debugf(source, buff.join('\n'));
};
var advanceToNextElement = function () {
inputIndex++;
if (inputIndex >= focusableElements.length)
inputIndex = -1;
};
var advanceToNextItem = function () {
elementSelected = false;
itemIndex++;
if ((inputIndex == -1) || (focusableElements[inputIndex][ITEM].length <= itemIndex)) {
advanceToNextElement();
itemIndex = 0;
}
};
var advanceToPreviousElement = function () {
inputIndex--;
if (inputIndex < 0)
inputIndex = focusableElements.length - 1;
if (inputIndex >= 0) {
itemIndex = focusableElements[inputIndex][ITEM].length - 1;
if (itemIndex < 0)
itemIndex = 0;
}
};
var advanceToPreviousItem = function () {
if (itemIndex == 0)
advanceToPreviousElement();
else
itemIndex--;
};
var elementInDB = function (elementID) {
for (var i = 0; i < focusableElements.length; i++) {
if (focusableElements[i][KEY] == elementID) return i;
}
return -1;
};
var getInputObjectFromList = function (inputIndex, itemIndex) {
if ((inputIndex != -1) && (inputIndex < focusableElements.length)) {
var parts = [];
parts[KEY] = focusableElements[inputIndex][KEY];
parts[ELEMENT] = focusableElements[inputIndex][ELEMENT];
var items = [];
items = focusableElements[inputIndex][ITEM];
parts[ITEM] = items[itemIndex];
return parts;
}
};
shortcut = {
'all_shortcuts': {},
'add': function (shortcut_combination, callback, simDoc, opt) {
var default_options = {
'type': 'keydown',
'propagate': true,
'disable_in_input': false,
'target': simDoc,
'keycode': false
};
if (!opt) opt = default_options;
else {
for (var dfo in default_options) {
if (typeof opt[dfo] == 'undefined') opt[dfo] = default_options[dfo];
}
}
var ele = opt.target;
if (typeof opt.target == 'string') ele = document.getElementById(opt.target);
shortcut_combination = shortcut_combination.toLowerCase();
var func = function (e) {
e = e || window.event;
if (opt['disable_in_input']) {
var element = null;
if (e.target) element = e.target;
else if (e.srcElement) element = e.srcElement;
if (element.nodeType == 3) element = element.parentNode;
if (element.tagName == 'INPUT' || element.tagName == 'TEXTAREA') return;
}
if (e.keyCode) code = e.keyCode;
else if (e.which) code = e.which;
var character = String.fromCharCode(code).toLowerCase();
if (code == 188) character = ",";
if (code == 190) character = ".";
var keys = shortcut_combination.split("+");
var kp = 0;
var shift_nums = {
"`": "~",
"1": "!",
"2": "@",
"3": "#",
"4": "$",
"5": "%",
"6": "^",
"7": "&",
"8": "*",
"9": "(",
"0": ")",
"-": "_",
"=": "+",
";": ":",
"'": "\"",
",": "<",
".": ">",
"/": "?",
"\\": "|"
};
var special_keys = {
'esc': 27,
'escape': 27,
'tab': 9,
'space': 32,
'return': 13,
'enter': 13,
'backspace': 8,
'scrolllock': 145,
'scroll_lock': 145,
'scroll': 145,
'capslock': 20,
'caps_lock': 20,
'caps': 20,
'numlock': 144,
'num_lock': 144,
'num': 144,
'pause': 19,
'break': 19,
'insert': 45,
'home': 36,
'delete': 46,
'end': 35,
'pageup': 33,
'page_up': 33,
'pu': 33,
'pagedown': 34,
'page_down': 34,
'pd': 34,
'left': 37,
'up': 38,
'right': 39,
'down': 40,
'f1': 112,
'f2': 113,
'f3': 114,
'f4': 115,
'f5': 116,
'f6': 117,
'f7': 118,
'f8': 119,
'f9': 120,
'f10': 121,
'f11': 122,
'f12': 123
};
var modifiers = {
shift: { wanted: false, pressed: false },
ctrl: { wanted: false, pressed: false },
alt: { wanted: false, pressed: false },
meta: { wanted: false, pressed: false}
};
if (e.ctrlKey) modifiers.ctrl.pressed = true;
if (e.shiftKey) modifiers.shift.pressed = true;
if (e.altKey) modifiers.alt.pressed = true;
if (e.metaKey) modifiers.meta.pressed = true;
for (var i = 0; k = keys[i], i < keys.length; i++) {
if (k == 'ctrl' || k == 'control') {
kp++;
modifiers.ctrl.wanted = true;
} else if (k == 'shift') {
kp++;
modifiers.shift.wanted = true;
} else if (k == 'alt') {
kp++;
modifiers.alt.wanted = true;
} else if (k == 'meta') {
kp++;
modifiers.meta.wanted = true;
} else if (k.length > 1) {
if (special_keys[k] == code) kp++;
} else if (opt['keycode']) {
if (opt['keycode'] == code) kp++;
} else {
if (character == k) kp++;
else {
if (shift_nums[character] && e.shiftKey) {
character = shift_nums[character];
if (character == k) kp++;
}
}
}
}
if (kp == keys.length &&
modifiers.ctrl.pressed == modifiers.ctrl.wanted &&
modifiers.shift.pressed == modifiers.shift.wanted &&
modifiers.alt.pressed == modifiers.alt.wanted &&
modifiers.meta.pressed == modifiers.meta.wanted) {
callback(e);
if (!opt['propagate']) {
e.cancelBubble = true;
e.returnValue = false;
if (e.stopPropagation) {
e.stopPropagation();
e.preventDefault();
}
return false;
}
}
};
this.all_shortcuts[shortcut_combination] = {
'callback': func,
'target': ele,
'event': opt['type']
};
if (ele.addEventListener) ele.addEventListener(opt['type'], func, false);
else if (ele.attachEvent) ele.attachEvent('on' + opt['type'], func);
else ele['on' + opt['type']] = func;
},
'remove': function (shortcut_combination) {
shortcut_combination = shortcut_combination.toLowerCase();
var binding = this.all_shortcuts[shortcut_combination];
delete (this.all_shortcuts[shortcut_combination]);
if (!binding) return;
var type = binding['event'];
var ele = binding['target'];
var callback = binding['callback'];
if (ele.detachEvent) ele.detachEvent('on' + type, callback);
else if (ele.removeEventListener) ele.removeEventListener(type, callback, false);
else ele['on' + type] = false;
}
};
this.initializeKeyboardShortcuts = function () {
shortcut.add('tab', function () { handleKeyBoardInput('tab', '', ''); }, sim.getSimDocument());
shortcut.add('ctrl+tab', function () { handleKeyBoardInput('ctrl', 'tab', ''); }, sim.getSimDocument());
shortcut.add('shift+tab', function () { handleKeyBoardInput('shift', 'tab', ''); }, sim.getSimDocument());
shortcut.add('ctrl+shift+tab', function () { handleKeyBoardInput('ctrl', 'shift', 'tab'); }, sim.getSimDocument());
shortcut.add('enter', function () { handleKeyBoardInput('enter', '', ''); }, sim.getSimDocument());
};
this.removeKeyboardShortcuts = function () {
shortcut.remove('tab');
shortcut.remove('ctrl+tab');
shortcut.remove('shift+tab');
shortcut.remove('ctrl+shift+tab');
shortcut.remove('enter');
};
var prevInputObjectInfo = [];
var handleKeyBoardInput = function (firstKey, secondKey, thirdKey) {
if (simMgr().isPlaying()) return;
var parts = null;
if (prevInputObjectInfo[ELEMENT]) {
prevInputObjectInfo[ELEMENT].keyboardNavigateAwayFrom(prevInputObjectInfo[KEY], prevInputObjectInfo[ITEM], itemIndex);
}
switch (firstKey) {
case 'ctrl':
switch (secondKey) {
case 'tab':
if (elementSelected) advanceToNextElement();
else advanceToNextItem();
parts = getInputObjectFromList(inputIndex, itemIndex);
if (parts) {
parts[ELEMENT].keyboardNavigateTo(parts[KEY], parts[ITEM], itemIndex);
} else {
eventMgr().postEvent(new Simulator.Event(this, 'info', 'lastfocusableSimulatorElementReached', null, false));
inputIndex = -1;
}
break;
case 'shift':
switch (thirdKey) {
case 'tab':
if (elementSelected) advanceToPreviousElement();
else advanceToPreviousItem();
parts = getInputObjectFromList(inputIndex, itemIndex);
if (parts) {
parts[ELEMENT].keyboardNavigateTo(parts[KEY], parts[ITEM], itemIndex);
} else {
eventMgr().postEvent(new Simulator.Event(this, 'info', 'firstfocusableSimulatorElementReached', null, false));
inputIndex = -1;
}
break;
}
break;
}
break;
case 'shift':
switch (secondKey) {
case 'tab':
if (elementSelected) advanceToPreviousElement();
else advanceToPreviousItem();
parts = getInputObjectFromList(inputIndex, itemIndex);
if (parts) {
parts[ELEMENT].keyboardNavigateTo(parts[KEY], parts[ITEM], itemIndex);
} else {
eventMgr().postEvent(new Simulator.Event(this, 'info', 'firstfocusableSimulatorElementReached', null, false));
inputIndex = -1;
}
break;
}
break;
case 'tab':
break;
case 'enter':
parts = getInputObjectFromList(inputIndex, itemIndex);
if (parts) {
parts[ELEMENT].recordKeyboardSelection(parts[KEY], parts[ITEM], itemIndex);
if (parts[ELEMENT].getType() === 'dropList') {
itemIndex = focusableElements[inputIndex][ITEM].length - 1;
}
}
break;
}
if (parts) {
prevInputObjectInfo[KEY] = parts[KEY];
prevInputObjectInfo[ELEMENT] = parts[ELEMENT];
prevInputObjectInfo[ITEM] = parts[ITEM];
}
else {
prevInputObjectInfo[KEY] = null;
prevInputObjectInfo[ELEMENT] = null;
prevInputObjectInfo[ITEM] = null;
}
};
this.closeDropList = function () {
handleKeyBoardInput('enter');
}
var debug = function (str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
};
var debugf = function (str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
};
};

// FILE: SimElement2.js (75901a96) 7/23/2014 4:30:37 PM

Simulator.SimElement = function (sim) {
Simulator.SimItem.call(this, sim);
var source = 'SimElement';
var name = '';
var focusable = false;
var nodeID = null;
var type = null;
var label = '';
var scoreable = true;
var spaceAbove = 0;
var spaceBelow = 0;
var image = null;
var speechLabel = '';
var toEvents = new Simulator.EventDB(sim, 'toEvents');
var fromEvents = new Simulator.EventDB(sim, 'fromEvents');
var theSimulator = null;
var keyboardInput = function () { sim.getKeyboardInput(); };
var html2jsMap = function() { return sim.getHTML2JSMap(); };
if(sim) {
theSimulator = sim;
}
var eventMgr = function () { return theSimulator.getEventManager(); };
var dbg = function() {return theSimulator.getDebug();};
var simDocument = function() { return sim.getSimDocument(); };
this.getEname = function() {
return source;
};
this.addEvent = function (theEvent, dir) {
switch (dir) {
case 'to':
toEvents.addEvent(theEvent);
eventMgr().registerEvent(theEvent);
break;
case 'from':
fromEvents.addEvent(theEvent);
break;
default:
dbg().logError(source, 'Unknown event direction ' + dir + ' passed to ' + this.getName());
break;
}
return this;
};
this.setFocusable = function (flag, noRegister) {
if (flag == true) {
focusable = true;
}
else focusable = false;
};
this.isFocusable = function () {
return focusable;
};
this.nextEvent = function (reset) {
return fromEvents.nextEvent(reset);
};
this.getName = function () {
return name;
};
this.setName = function (newName) {
name = newName.trim();
nodeID = this.createItemID(true, -1);
return this;
};
this.getType = function () {
return type;
};
this.setType = function (newType) {
type = newType;
return this;
};
this.getLabel = function () {
return label;
};
this.setLabel = function (newLabel) {
label = newLabel;
return this;
};
this.getScoreable = function () {
return scoreable;
};
this.setSpaceAbove = function (newSpaceAbove) {
spaceAbove = parseInt(newSpaceAbove);
};
this.getSpaceAbove = function () {
return spaceAbove;
};
this.setSpaceBelow = function (newSpaceBelow) {
spaceBelow = parseInt(newSpaceBelow);
};
this.getSpaceBelow = function () {
return spaceBelow;
};
this.getImage = function () {
return image;
};
this.setImage = function (newImage) {
image = newImage;
return this;
};
this.getData = function () {
return '';
};
this.setSpeechLabel = function (newSpeechLabel) {
speechLabel = newSpeechLabel;
};
this.getSpeechLabel = function () {
return speechLabel;
};
this.formatEventData = function () {
return this.getData();
};
this.postOnChangeEnabled = function () {
var theEvent = this.nextEvent('true');
while (theEvent != null) {
if (theEvent.postOnChange == 'yes') {
return true;
}
theEvent = this.nextEvent();
}
return false;
};
this.postOnChangeEvents = function () {
var theEvent = this.nextEvent('true');
while (theEvent != null) {
if (theEvent.postOnChange == 'yes') {
theEvent.data = this.formatEventData();
eventMgr().postEvent(theEvent);
}
theEvent = this.nextEvent();
}
};
this.postStaticEvents = function () {
var theEvent = this.nextEvent('true');
while (theEvent != null) {
if (theEvent.postOnChange != 'yes') {
theEvent.data = this.formatEventData();
theEvent.postEvent();
}
theEvent = this.nextEvent();
}
};
this.getNodeID = function () {
return nodeID;
};
this.mapHTML2JS = function(htmlElement) {
html2jsMap().mapJSFromHTML(this, htmlElement);
};
this.inspect = function(embedded, force) {
var buff = [];
var sep = '\n';
buff.push('Inspecting ' + source + sep);
var str = Simulator.SimElement.prototype.inspect.call(this, true, force);
if (str) {
buff.push(str);
buff.push(fromEvents.inspect(true, force));
buff.push(toEvents.inspect(true, force));
return buff.join('');
}
else {
for ( var i in this) {
if (i.substr(0, 3) == 'get') {
buff.push(i.charAt(3).toLowerCase() + i.slice(4));
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
buff.push(fromEvents.inspect(true, force));
buff.push(toEvents.inspect(true, force));
buff.push('End Inspecting ' + source + sep + sep);
if(!embedded) force == true ? debugf(buff.join('')) : debug(buff.join(''));
else return buff.join('');
}
};
this.selectViaKeyboard = function (itemIndex) { Simulator.showAlert('Error','"selectViaKeyboard" must be inplemented by subclass'); };
if(sim) this.setEname('SimElement');
this.setAttributes = function (attr) {
Simulator.SimElement.prototype.setAttributes.call(this, attr);
for (var i in attr) {
switch (i) {
case 'name':
this.setName(attr[i]);
break;
case 'image':
this.setImage(attr[i]);
break;
case 'label':
this.setLabel(attr[i]);
break;
case 'type':
this.setType(attr[i]);
break;
case 'spaceAbove':
this.setSpaceAbove(attr[i]);
break;
case 'spaceBelow':
this.setSpaceBelow(attr[i]);
break;
case 'speechLabel':
this.setSpeechLabel(attr[i]);
break;
}
}
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.SimElement.prototype = new Simulator.SimItem();
Simulator.SimElement.prototype.constructor = Simulator.SimElement;

// FILE: DataDictionary2.js (12b8a1fc) 3/7/2014 11:24:14 AM

Simulator.DataDictionary = function (sim) {
Simulator.SimItem.call(this, sim);
var source = 'DataDictionary';
var dataDB = [];
var dbg = function () { return sim.getDebug(); };
this.createEntry = function(key) {
if(!dataDB.keyExists(key)) dataDB.addKey(key, '');
};
this.setEntryValue = function(key, value) {
dataDB.setValue(key, value);
};
this.getEntryValue = function(key) {
return dataDB.lookup(key);
};
this.contents = function() {
var buff = [];
buff.push('<Table>\n');
buff.push('<tr>');
var keys = dataDB.keys();
for(var i = 0; i < keys.length; i++) {
buff.push('<th id = "' + keys[i] + '">' + keys[i] + '</th>');
}
return buff.join('');
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
};
};
Simulator.DataDictionary.prototype = new Simulator.SimItem();
Simulator.DataDictionary.parent = Simulator.SimItem;
Simulator.DataDictionary.prototype.constructor = Simulator.DataDictionary;

// FILE: EventManager2.js (88ecb2ad) 3/7/2014 11:24:14 AM

Simulator.EventManager = function(sim) {
var source = 'EventManager';
var inputQueue = new Simulator.Utils.Queue(sim);
var subscriberDB = null;
var timer = null;
var dbg = function() {return sim.getDebug();};
var utils = function() {return sim.getUtils();};
var getSubscriberDB = function() {
if(!subscriberDB) subscriberDB = new Simulator.EventDB(sim, 'subscriberDB');
return subscriberDB;
};
this.registerEvent = function(event) {
getSubscriberDB().addEvent(event);
};
this.deRegisterEvent = function(event) {
getSubscriberDB().remove(event);
};
this.postEvent = function(event) {
inputQueue.add(event);
};
this.startEventProcessing = function() {
var closure = bind(processEvents);
timer = setInterval (closure, 500 );
};
this.getSourceName = function(obj) {
return utils().getJSObjName(obj);
};
this.stopEventProcessing = function() {
clearTimeout(timer);
};
function processEvents() {
while(!inputQueue.isEmpty()) {
var matches = [];
var event = inputQueue.remove();
matches = getSubscriberDB().getAllMatchingEvents(event);
for ( var i = 0; i < matches.length; i++) {
if((matches[i]).src.handleEvent != undefined) {
(matches[i]).src.handleEvent(event);
}
else if(typeof (matches[i]).src != 'object') {
(matches[i]).src.prototype.handleEvent(event);
}
}
}
}
function bind(method) {
var _this = this;
return(function() {
return(method.apply(_this.arguments));
});
}
function getEventSrcName(event) {
if (event.src.getSourceName === undefined) return 'object';
else return event.src.getSourceName();
}
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};

// FILE: EventDB2.js (5c4bdc27) 3/7/2014 11:24:14 AM

Simulator.EventDB = function(sim, theName) {
var source = 'EventDB';
var DB = [];
var currentIndex = 0;
var name = theName;
var dbg = function() {return sim.getDebug();};
this.getName = function() {
return name;
};
this.addEvent = function(event) {
DB.push(event);
};
this.removeEvent = function(event) {
var index = this.isInDB(event, true);
if(index > -1) DB.splice(index, 1);
};
this.isInDB = function(event, fullMatch) {
for(var i = 0; i < DB.length; i++) {
var theEvent = DB[i];
if(theEvent.type == event.type && theEvent.context == event.context) {
if (fullMatch) {
if(theEvent.src == event.src) return i;
} else return i;
}
}
return -1;
};
this.getAllMatchingEvents = function(event) {
var matches = [];
var k = 0;
for ( var i = 0; i < DB.length; i++) {
var theEvent = DB[i];
if(theEvent.type == event.type && (theEvent.context == event.context || theEvent.context == '*'|| event.context == '*')) {
if(event.data) theEvent.data = event.data;
theEvent.completeWithoutOutput = event.completeWithoutOutput;
theEvent.originatorName = event.originatorName;
matches[k++] = theEvent;
}
}
return matches;
};
this.nextEvent = function(reset) {
if(reset) currentIndex = 0;
if(currentIndex < DB.length) return DB[currentIndex++];
else return null;
};
this.inspect = function(embedded, forced) {
var buff = [];
var sep = '\n';
buff.push('Inspecting EventDB ' + name + sep);
buff.push('There are ' + DB.length + ' events in ' + name + sep);
for(var i = 0; i < DB.length; i++) {
(forced) ? buff.push(debugf(DB[i].inspect(embedded, true))) : buff.push(debug(DB[i].inspect(embedded, true)));
buff.push(sep);
};
buff.push('End of EventDB ' + name + ' Inspection' + sep + sep);
if(!embedded) (forced) ? debugf(buff.join('')) : debug(buff.join(''));
else return buff.join('');
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};

// FILE: Event2.js (3f33490d) 3/7/2014 11:24:14 AM

Simulator.Event = function(src, type, context, data, postOnChange, completeWithoutOutput) {
this.type = type;
this.src = src;
this.context = context;
this.data = data;
this.postOnChange = postOnChange;
this.completeWithoutOutput = (completeWithoutOutput === true) ? true : false;
this.inspect = function() {
var buff = [];
var sep = '\n\n';
buff.push('Inspecting event'); buff.push(sep);
if(this.src.getName) {
buff.push('event src = '); buff.push(this.src.getName()); buff.push(';'); buff.push(sep);
}
buff.push('event type = '); buff.push(this.type); buff.push(';'); buff.push(sep);
buff.push('event context = '); buff.push(this.context);  buff.push(';'); buff.push(sep);
buff.push('event data = '); buff.push(this.data);  buff.push(';'); buff.push(sep);;
buff.push('event postOnChange = '); buff.push(this.postOnChange);  buff.push(';'); buff.push(sep);;
buff.push('event completeWithoutOutput = '); buff.push(this.completeWithoutOutput);  buff.push(';'); buff.push(sep);;
return buff.join('');
};
function addHTMLEvent( obj, type, fn ) {
if( obj.attachEvent ) {
obj['e'+type+fn] = fn;
obj[type+fn] = function(){obj['e'+type+fn]( window.event );};
obj.attachEvent( 'on'+type, obj[type+fn] );
} else
obj.addEventListener( type, fn, false );
}
function removeHTMLEvent( obj, type, fn ) {
if( obj.detachEvent ) {
obj.detachEvent( 'on'+type, obj[type+fn] );
obj[type+fn] = null;
} else
obj.removeEventListener( type, fn, false );
}
};

// FILE: Layout2.js (84e0627a) 3/7/2014 11:24:14 AM

Simulator.Display.Layout = function (sim, container) {
var source = 'Layout';
var panelList = [];
var dbg = function () { return sim.getDebug(); };
var eventMgr = function () { return sim.getEventManager(); };
var simDocument = function () { return sim.getSimDocument(); };
var utils = function () { return sim.getUtils(); };
var simDocument = function () { return sim.getSimDocument(); };
this.specifyLayout = function (layout) {
var format = null;
var attr = layout[0].attributes;
var div = simDocument().createElement('div');
div.setAttribute('id', Simulator.Constants.SIM_CONTAINER_NAME + sim.getSimID());
if (utils().isInternetExplorer()) {
format = attr.getNamedItem('format').value;
}
else format = attr['format'].nodeValue;
if (format) {
div.setAttribute('class', format);
container.appendChild(div);
}
else dbg().logError(source, 'Could not get layout format attribute.');
};
this.createPanels = function (node) {
var aPanel;
var panelSpec;
var panelNum = 0;
for (var i = 0; i < node.length; i++) {
if (node[i].nodeName[0] != '#') {
aPanel = new Simulator.Display.Panel(sim, panelNum++);
for (var j = 0; j < node[i].childNodes.length; j++) {
if (node[i].childNodes[j].nodeName[0] != '#') {
panelSpec = node[i].childNodes[j];
aPanel.setAttributes(aPanel, utils().getAttributes(panelSpec));
}
}
var attr = node[i].attributes;
if (utils().isInternetExplorer()) aPanel.setAttributes(utils().getAttributes(node[i]));
else if (Object.size(attr) > 0) aPanel.setAttributes(utils().getAttributes(node[i]));
aPanel.setName(node[i].nodeName);
var id = aPanel.getNodeID();
if (!panelList[id]) panelList[id] = aPanel;
aPanel.render();
}
}
};
this.getPanelInstance = function (panelType) {
for (var panel in panelList)
if (panel.indexOf(panelType) > -1) return panelList[panel];
return null;
};
this.resizeAllPanels = function (zoom) {
debug(source, 'In Layout Panel Resize All Panels for simID=' + sim.getSimID());
var aPanel = null;
for (var name in panelList) {
aPanel = panelList[name];
if (aPanel.resize) {
aPanel.resize(zoom);
} else dbg().logError(source, 'unknown panel name: ' + name);
}
};
this.recordPanelSizes = function (zoom) {
debug(source, 'In Record Panel Sizes for simID=' + sim.getSimID());
var aPanel = null;
for (var name in panelList) {
aPanel = panelList[name];
if (aPanel.recordOriginalWidthAndHeight) {
aPanel.recordOriginalWidthAndHeight();
} else dbg().logError(source, 'unknown panel name: ' + name);
}
};
this.makeAllPanelsVisible = function () {
var aPanel = null;
for (var name in panelList) {
aPanel = panelList[name];
aPanel.setDisplay('visible');
var HTMLPanel = simDocument().getElementById(name);
if (HTMLPanel) {
HTMLPanel.style.visibility = 'visible';
debug(name + '.style.visibility = ' + HTMLPanel.style.visibility);
}
else dbg().logError(source, 'Could not get HTML ' + name + ' panel element. Could not make panel visible');
}
};
this.getContainerWidth = function () {
var width = 0;
var container = simDocument().getElementById(Simulator.Constants.SIM_CONTAINER_NAME + sim.getSimID());
if (container) {
width = container.offsetWidth;
if (width === 0) {
dbg().logError(source, 'Simulator container offsetWidth is 0');
}
return container.offsetWidth;
} else {
dbg().logError(source, 'Simulator\'s container with id = "' + id + '" is null');
return FAILURE;
}
};
this.getContainerHeight = function () {
var height = 0;
var container = simDocument().getElementById(Simulator.Constants.SIM_CONTAINER_NAME + sim.getSimID());
if (container) {
height = container.offsetHeight;
if (height === 0) {
dbg().logError(source, 'Simuator container offsetHeight is 0');
}
return container.offsetHeight;
} else {
dbg().logError(source, 'Simulator\'s container with id = "' + id + '" is null.');
return FAILURE;
}
};
this.handleEvent = function (event) {
switch (event.type) {
case 'info':
switch (event.context) {
case 'simulatorStateChange':
switch (event.data) {
case 'ReadOnly': this.disableAllInput();
break;
case 'Playing': this.disableAllInput();
break;
case 'Ready': this.enableAllInput();
break;
}
break;
}
}
};
this.enableAllInput = function () {
for (var panel in panelList) {
if (panel) {
var panelObj = panelList[panel];
if (panelObj.enableAllInput)
panelObj.enableAllInput();
}
}
};
this.disableAllInput = function () {
for (var panel in panelList) {
if (panel) {
var panelObj = panelList[panel];
if (panelObj.disableAllInput)
panelObj.disableAllInput();
}
}
};
this.saveInputs = function () {
for (var panel in panelList) {
if (panel) {
var panelObj = panelList[panel];
if (panelObj.saveInputs)
panelObj.saveInputs();
}
}
};
this.hasEmptyChoiceListSelection = function () {
for (var panel in panelList) {
if (panel) {
var panelObj = panelList[panel];
if (panelObj.hasEmptyChoiceListSelection) {
if (panelObj.hasEmptyChoiceListSelection()) {
return true;
}
}
}
}
return false;
};
this.getSourceName = function () {
return source;
};
if (sim) eventMgr().registerEvent(new Simulator.Event(this, 'info', 'simulatorStateChange'));
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};

// FILE: Simulator2.js (783ffe24) 5/2/2014 12:55:58 PM

Simulator.showAlertWarning = function (msg) {
if (window.TDS && TDS.Dialog) {
TDS.Dialog.showWarning(msg, function () {});
} else {
alert(msg);
}
};
Simulator.showAlert = function (headline,msg) {
if (window.TDS && TDS.Dialog) {
TDS.Dialog.showAlert(msg, function () {});
} else {
alert(msg);
}
};
Simulator.Simulator = function (container, assistiveMode, speechMode) {
var source = 'Simulator';
var simID = null;
var speechEnabled = speechMode;
var language = 'english';
var mode = 'operation';
var xmlns = '';
var simMgr = null;
var layout = null;
var animationSetObj = null;
var animationShellPath = null;
var animationExternalScriptsPath = null;
var animationPresent = true;
var accessibilityIFActive = assistiveMode;
var dataTable = null;
var instance = this;
var simDocument = null;
var visible = true;
var eventMgr = new Simulator.EventManager(this);
var whiteboard = new Simulator.Whiteboard(this);
var scoringTable = new Simulator.Utils.Table(true, 'ScoringTable', this);
var persistentVariableDB = new Simulator.Utils.PersistentVariableDataBase(this);
var utils = new Simulator.Utils.Utils(this);
var dbg = new Simulator.Utils.Debug(this);
var keyboardInput = new Simulator.Input.KeyboardInput(this);
var html2jsMap = new Simulator.HTML2JSMap(this);
var sliderPreRenderQueue = new Simulator.Utils.Queue();
var sliderIndex = 1;
var speechGrammarBldr = null;
var speechMgr = null;
this.getSpeechGrammarBldr = function () {
return speechGrammarBldr;
};
this.getVisibility = function () {
return visible;
};
this.setVisibilityAndAttachEvents = function (newValue) {
visible = newValue;
if (newValue) {
this.resize(this, false);
this.bindResize(simDocument.body, this);
}
};
this.getSourceName = function () {
return source;
};
this.getDataTable = function () {
return dataTable;
};
this.setAnimationShellPath = function (path) {
if (!animationShellPath)
animationShellPath = path;
};
this.getAnimationShellPath = function () {
return animationShellPath;
};
this.setAnimationExternalScriptsPath = function (path) {
if (!animationExternalScriptsPath)
animationExternalScriptsPath = path;
};
this.getAnimationExternalScriptsPath = function () {
return animationExternalScriptsPath;
};
this.getAnimationSet = function () {
return animationSetObj;
};
this.getSimulationManager = function () {
return simMgr;
};
this.getSimDocument = function () {
return simDocument;
};
this.getLayout = function () {
return layout;
};
this.getSimID = function () {
return simID;
};
this.getHTML2JSMap = function () {
return html2jsMap;
};
this.getParser = function () {
return parser;
};
this.getWhiteboard = function () {
return whiteboard;
};
this.getScoringTable = function () {
return scoringTable;
};
this.getPersistentVariableDB = function () {
return persistentVariableDB;
};
this.getEventManager = function () {
return eventMgr;
};
this.getDebug = function () {
return dbg;
};
this.getUtils = function () {
return utils;
};
this.getKeyboardInput = function () {
return keyboardInput;
};
debug('Instantiating SimulationManager');
simMgr = new Simulator.SimulationManager(this);
debug('Required services instantiated');
this.getSliderPreRenderQueue = function () {
return sliderPreRenderQueue;
};
this.getSliderIndex = function () {
return sliderIndex++;
};
this.getSpeechEnabled = function () {
return speechEnabled;
};
this.getLanguage = function () {
return language;
};
this.getMode = function () {
return mode;
};
this.getXmlns = function () {
return xmlns;
};
this.animationIsPresent = function () {
return animationPresent;
};
this.startSimulation = function (xmlFile) {
var xmlDoc = loadXMLDoc(xmlFile);
this.startSimulationXmlDom(xmlDoc);
sendStartEvent();
};
this.startSimulationXmlText = function (xmlText) {
var xmlDoc = loadXMLDocFromString(xmlText);
this.startSimulationXmlDom(xmlDoc);
sendStartEvent();
};
var onSliderContainerDone = function () {
var sliderElement = instance.getSliderPreRenderQueue().remove();
while (sliderElement) {
sliderElement.postContainerRender();
sliderElement = instance.getSliderPreRenderQueue().remove();
}
};
this.startSimulationXmlDom = function (xmlDoc) {
eventMgr.startEventProcessing();
debug('Simulator is loading');
if (container) {
var className = container.getAttribute('class');
if (className)
className += ' simV2';
else
className = 'simV2';
container.setAttribute('class', className);
}
var x = xmlDoc.childNodes[1];
if (!x) x = xmlDoc.childNodes[0];
if (!x) x = xmlDoc.getElementsByTagName('simulationItem');
if (x) {
recordItemAttributes(this, x);
simDocument = container.ownerDocument;
} else {
dbg.logFatalError(source, 'Missing "simulationItem" element in xml input file.');
return;
}
if (speechEnabled) {
if (speechGrammarBldr === null) speechGrammarBldr = new Simulator.Speech.SpeechGrammarBuilder(this);
speechGrammarBldr.setItemName(this.getItemName());
speechGrammarBldr.createHeader();
}
x = xmlDoc.getElementsByTagName('definition');
if (x.length > 0) {
debug('found definition spec');
var layOut = xmlDoc.getElementsByTagName('layout');
if (layOut.length > 0) {
debug('Found layout spec');
layout = new Simulator.Display.Layout(this, container);
layout.specifyLayout(layOut);
layout.createPanels(layOut[0].childNodes);
} else {
dbg.logFatalError(source, 'Missing "layout" element in xml input file.');
return;
}
} else {
dbg.logFatalError(source, 'Missing "definition" element in xml input file.');
}
var x = xmlDoc.getElementsByTagName('initialization');
if (x.length > 0) {
debug('Found initialization section');
recordInitializationSpecs(x);
}
simMgr.initManagerVariables();
var x = xmlDoc.getElementsByTagName('state');
if (x.length > 0) {
debug('Found state element');
}
x = xmlDoc.getElementsByTagName('input');
if (x.length > 0) {
debug('Found input section');
whiteboard.addCategory('dataInput');
whiteboard.addCategory('evaluationInput');
whiteboard.addCategory('animationInput');
whiteboard.addCategory('evaluationOutput');
whiteboard.addCategory('animationOutput');
var sections = xmlDoc.getElementsByTagName('section');
if (sections) {
for (var i = 0; i < sections.length; i++) {
createInputSection(this, sections[i]);
}
} else {
dbg.logFatalError(source, 'Missing "section" elements in xml input file.');
return;
}
} else {
dbg.logFatalError(source, 'Missing "input" element in xml input file.');
}
x = xmlDoc.getElementsByTagName('animation');
if (x.length > 0) {
animationPresent = true;
for (var k = 0; k < x.length; k++) {
debug('Found animation section');
createAnimationMembers(this, x[k]);
}
} else animationPresent = false;
x = xmlDoc.getElementsByTagName('display');
if (x.length > 0) {
for (var k = 0; k < x.length; k++) {
debug('Found display section');
createDisplayMembers(this, x[k]);
}
}
x = xmlDoc.getElementsByTagName('evaluation');
var parser = new SimParser.EvaluationUnit(this);
if (x.length > 0) {
debug('Found evaluation section');
try {
parser.load(xmlDoc);
} catch (err) {
dbg.logFatalError(source, 'Error loading evaluation element: ' + err);
return;
}
}
x = xmlDoc.getElementsByTagName('control');
if (x.length > 0) {
debug('Found control section');
}
onSliderContainerDone();
if (speechEnabled) {
speechGrammarBldr.finishItemSpeechGrammar();
if (speechMgr === null) speechMgr = new Simulator.Speech.SpeechManager(this);
}
simMgr.setStateFromName('Loaded');
if (!animationPresent) eventMgr.postEvent(new Simulator.Event(this, 'info', 'allMediaLoaded'));
};
this.bindResize = function (dom, scope) {
if (dom) {
var f = function () { scope.resize(scope, false); };
dom.onresize = f;
} else {
dbg.logError(source, 'Failed to bind a resize event.');
}
};
this.resize = function (scope, zoom) {
scope = scope || this;
if (scope.getVisibility())
layout.resizeAllPanels(zoom);
};
this.getDoc = function () { return simDocument; };
this.getWin = function () { return window; };
this.loadXml = function (itemXml, responseXml) {
this.startSimulationXmlText(itemXml);
if (responseXml != null && responseXml.length > 0) {
this.loadResponseXml(responseXml);
}
};
this.getResponseXml = function () {
var stateMgr = new Simulator.ResponseStateManager(this);
simMgr.setResponseStateVariables(stateMgr);
return stateMgr.saveState();
};
this.loadResponseXml = function (xmlText) {
var responseMgr = new Simulator.ResponseStateManager(this);
simMgr.clearSimulationState();
var xmlDoc = loadXMLDocFromString(xmlText);
responseMgr.restoreSimulation(xmlDoc);
simMgr.displaySimulatorState();
};
this.isValid = function () {
return scoringTable.outputEntered();
};
this.isPlaying = function () {
return simMgr.isPlaying();
};
this.setReadOnlyState = function (readOnlyState) {
simMgr.setReadOnlyState(readOnlyState);
};
this.getAccessibilityIFActive = function () {
return accessibilityIFActive;
};
this.zoom = function (factor) {
this.zoomFactor = factor;
this.resize(this, true);
};
this.show = function () {
};
this.hide = function () {
};
this.focus = function () {
keyboardInput.initializeKeyboardShortcuts();
};
this.blur = function () {
keyboardInput.removeKeyboardShortcuts();
};
this.subscribe = function (type, context, callback) {
var stateCallback =
{
handleEvent: callback
};
var event = new Simulator.Event(stateCallback, type, context);
eventMgr.registerEvent(event);
return event;
};
this.unsubscribe = function (event) {
eventMgr.deRegisterEvent(event);
};
this.inspect = function (embedded, forced) {
var buff = [];
buff.push('Inspecting ' + source);
buff.push('simID = ' + simID);
buff.push('End inspecting ' + source);
if (embedded) return buff.join('\n');
else forced ? debugf(buff.join('\n')) : debug(buff.join('\n'));
};
dbg.setDebug(true);
dbg.setErrorReportLevel('SimWarning');
simID = simIDgenerate();
debug('accessibilityIFActive = ' + accessibilityIFActive);
function startSimulator() {
simMgr.setStateFromName('Loaded');
}
function recordItemAttributes(sim, node) {
var attrArray = utils.getAttributes(node);
for (var attr in attrArray) {
switch (attr) {
case 'speechEnabled': speechEnabled = attrArray[attr] === 'yes' ? true : false;
break;
case 'language': language = attrArray[attr];
break;
case 'mode': mode = attrArray[attr];
break;
case 'itemName': itemName = attrArray[attr];
break;
case 'xmlns': xmlns = attrArray[attr];
break;
default: dbg.logWarning(source, 'Unrecognized Simulator attribute ' + attr + ' with value ' + attrArray[attr]);
break;
}
}
debug('Completed recording item attributes');
}
function loadXMLDoc(fileName) {
var xhttp = null;
if (window.XMLHttpRequest) {
xhttp = new XMLHttpRequest();
} else {
xhttp = new ActiveXObject('Microsoft.XMLHTTP');
}
xhttp.open('GET', fileName, false);
xhttp.send();
return xhttp.responseXML;
}
function loadXMLDocFromString(xmlStr) {
var xmlDoc = null;
if (window.DOMParser) {
var domParser = new DOMParser();
xmlDoc = domParser.parseFromString(xmlStr, 'application/xml');
} else
{
xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
xmlDoc.async = 'false';
xmlDoc.loadXML(xmlStr);
}
return xmlDoc;
}
function recordInitializationSpecs(initNode) {
var varName = null;
var value = null;
var isIE = utils.isInternetExplorer();
if (initNode.length > 0) {
var children = initNode[0].childNodes;
whiteboard.addCategory('initialization');
for (var i = 0; i < children.length; i++) {
if (children[i].nodeName[0] !== '#') {
varName = children[i].attributes[0].nodeValue;
value = children[i].attributes[1].nodeValue;
debug('Found initialization variable ' + varName + ' with value = ' + value);
if ((isIE && (children[i].attributes).getNamedItem('persistent') != undefined)
|| 'persistent' in children[i].attributes)
persistentVariableDB.updateElement(varName, value);
else {
key = whiteboard.addItem('initialization', varName);
whiteboard.setItem('initialization', varName, value, key);
}
}
}
debug('Completed recording initialization specs');
}
}
function createInputSection(sim, section) {
var panel = layout.getPanelInstance(Simulator.Constants.INPUT_PANEL_NAME);
var attr = utils.getAttributes(section);
var aSection = new Simulator.Input.Section(sim, panel);
aSection.setAttributes(attr);
aSection.render();
var sectionElements = section.childNodes;
var theElement;
for (var i = 0; i < sectionElements.length; i++) {
switch (sectionElements[i].nodeName) {
case 'inputElement':
var iElements = sectionElements[i].childNodes;
for (var j = 0; j < iElements.length; j++) {
switch (iElements[j].nodeName) {
case 'dropList':
theElement = new Simulator.Input.DropList(sim, iElements[j], panel, aSection);
break;
case 'optionList':
theElement = new Simulator.Input.OptionList(sim, iElements[j], panel, aSection);
break;
case 'choiceList':
theElement = new Simulator.Input.ChoiceList(sim, iElements[j], panel, aSection);
break;
case 'upDownCounter':
theElement = new Simulator.Input.UpDownCounter(sim, iElements[j], panel, aSection);
break;
case 'slider':
theElement = new Simulator.Input.SimSlider(sim, iElements[j], panel, aSection);
break;
case 'textField':
theElement = new Simulator.Input.TextField(sim, iElements[j], panel, aSection);
break;
default:
continue;
}
var attr = utils.getAttributes(iElements[j]);
theElement.setAttributes(attr, iElements[j]);
setEvents(theElement, iElements[j]);
theElement.render();
break;
}
break;
case 'commandElement':
var cElements = sectionElements[i].childNodes;
for (var c = 0; c < cElements.length; c++) {
switch (cElements[c].nodeName) {
case 'button':
theElement = new Simulator.Control.Button(sim, panel, aSection);
break;
default:
continue;
}
theElement.setAttributes(cElements[c].attributes, cElements[c]);
setEvents(theElement, cElements[c]);
theElement.render(panel.getNodeID());
break;
}
break;
case 'staticElement':
var sElements = sectionElements[i].childNodes;
for (var s = 0; s < sElements.length; s++) {
switch (sElements[s].nodeName) {
case 'imageElement':
theElement = new Simulator.Input.ImageElement(sim, panel, aSection);
break;
case 'horizontalLine':
theElement = new Simulator.Input.HorizontalLine(sim, panel, aSection);
break;
case 'sectionDivider':
theElement = new Simulator.Input.SectionDivider(sim, panel, aSection);
break;
case 'verticalSpace':
theElement = new Simulator.Input.VerticalSpace(sim, panel, aSection);
break;
case 'textConstant':
theElement = new Simulator.Input.TextConstant(sim, panel, aSection);
break;
default:
continue;
}
theElement.setAttributes(sElements[s].attributes, sElements[s]);
theElement.render(Simulator.Constants.INPUT_PANEL_NAME);
break;
}
break;
}
}
}
function createAnimationMembers(sim, animationNode) {
var attr;
var theElement;
var animationSet = null;
var panel = layout.getPanelInstance(Simulator.Constants.ANIMATION_PANEL_NAME);
panel.recordOriginalWidthAndHeight();
for (var i = 0; i < animationNode.childNodes.length; i++) {
if (animationNode.childNodes[i].nodeName[0] != '#') {
animationSet = animationNode.childNodes[i];
break;
}
}
if (!animationSet) {
dbg().logError(source, 'Could not initialize animationSet.');
return;
}
var theSet = new Simulator.Animation.AnimationSet(sim, panel);
animationSetObj = theSet;
theSet.setAttributes(animationSet.attributes, animationSet);
setEvents(theSet, animationSet);
var animationSetElements = animationSet.childNodes;
for (var j = 0; j < animationSetElements.length; j++) {
switch (animationSetElements[j].nodeName) {
case 'animationThread':
var animationThread = animationSetElements[j];
theElement = new Simulator.Animation.AnimationThread(sim, panel, null, theSet);
attr = animationThread.attributes;
theElement.setAttributes(attr, animationThread);
var threadElements = animationThread.childNodes;
for (var k = 0; k < threadElements.length; k++) {
if (threadElements[k].nodeName === 'animationThreadElement') {
var aThreadElement = new Simulator.Animation.AnimationThreadElement(sim, theElement);
aThreadElement.setAttributes(threadElements[k].attributes, threadElements[k]);
theElement.addAnimationThreadElement(aThreadElement);
}
}
setEvents(theElement, animationThread);
break;
case 'animationElement':
theElement = new Simulator.Animation.AnimationElement(sim, theSet, panel);
attr = animationSetElements[j].attributes;
theElement.setAttributes(attr, animationSetElements[j]);
theSet.addAnimationElement(theElement);
if (theElement.getSrc() === '') {
var inlineElement = getElementInlineData(animationSetElements[j], sim);
if (inlineElement) {
theElement.setSrc(inlineElement.getData());
theElement.setInlineDataID(inlineElement.getID());
}
}
if ((theElement.getType() == 'html5') && (utils.canPlayHtml5())) {
panel.addPanelClass('withHTML5');
} else {
panel.addPanelClass('withFlash');
}
break;
case 'poster':
attr = animationSetElements[j].attributes;
theSet.setPoster(attr);
break;
case 'commandElement':
var cElements = animationSetElements[j].childNodes;
for (var c = 0; c < cElements.length; c++) {
switch (cElements[c].nodeName) {
case 'button':
theElement = new Simulator.Control.Button(sim, panel);
break;
default:
continue;
}
theElement.setAttributes(cElements[c].attributes, cElements[c]);
setEvents(theElement, cElements[c]);
theElement.render('animationPanel');
break;
}
break;
}
}
}
function getElementInlineData(node, sim) {
var aNode = null;
var theElement = new Simulator.Animation.InlineData(sim);
var attr = node.attributes;
var nodes = node.childNodes;
var numChildren = nodes.length;
for (var i = 0; i < numChildren; i++) {
aNode = nodes[i];
if (aNode.nodeName === 'inlineData') {
theElement.setAttributes(attr, aNode);
var data = aNode.textContent;
theElement.setData(data);
return theElement;
}
}
dbg.logError(source, 'Missing CDATA section for inlineData element');
return '';
}
function createDisplayMembers(sim, displayNode) {
var theElement = null;
var displayElements = displayNode.childNodes;
var panel = layout.getPanelInstance(Simulator.Constants.DATA_DISPLAY_PANEL_NAME);
for (var i = 0; i < displayElements.length; i++) {
switch (displayElements[i].nodeName) {
case 'displayElement':
var dElements = displayElements[i].childNodes;
for (var j = 0; j < dElements.length; j++) {
switch (dElements[j].nodeName) {
case 'table':
theElement = new Simulator.Display.DataTable(sim, panel);
dataTable = theElement;
simMgr.setTableExists(true);
break;
case 'graph':
break;
default:
continue;
}
theElement.setAttributes(dElements[j].attributes, dElements[j]);
setEvents(theElement, dElements[j]);
theElement.render('dataOutputPanel');
}
break;
case 'commandElement':
var cElements = displayElements[i].childNodes;
for (var c = 0; c < cElements.length; c++) {
switch (cElements[c].nodeName) {
case 'button':
theElement = new Simulator.Control.Button(sim, panel);
break;
default:
continue;
}
theElement.setAttributes(cElements[c].attributes, cElements[c]);
setEvents(theElement, cElements[c]);
theElement.render('dataOutputPanel');
break;
}
break;
}
}
}
function createControlMembers(sim, controlNode) {
var theElement = null;
var controlElements = controlNode.childNodes;
var panel = layout.getPanelInstance(Simulator.Constants.CONTROL_PANEL_NAME);
for (var i = 0; i < controlElements.length; i++) {
switch (controlElements[i].nodeName) {
case 'commandElement':
var cElements = controlElements[i].childNodes;
for (var c = 0; c < cElements.length; c++) {
switch (cElements[c].nodeName) {
case 'button':
theElement = new Simulator.Control.Button(sim, panel);
break;
default:
continue;
}
theElement.setAttributes(cElements[c].attributes, cElements[c]);
setEvents(theElement, cElements[c]);
theElement.render('controlPanel');
break;
}
break;
}
}
}
function setEvents(element, node) {
var events = [];
var attributes;
var children = node.childNodes;
if (children != null && children != undefined) {
for (var j = 0; j < children.length; j++) {
var id = children[j].nodeName;
if (id === 'event') {
attributes = children[j].attributes;
var eventInfo = createEvent(element, attributes);
element.addEvent(eventInfo['theEvent'], eventInfo['direction']);
}
}
}
return events;
}
function createEvent(obj, attributes) {
var response = [];
var data = '';
var ctx = '';
var dir = '';
var type = '';
var postOnChange = 'no';
var completeWithoutOutput = false;
for (var k = 0; k < attributes.length; k++) {
switch (attributes[k].nodeName) {
case 'direction':
dir = attributes[k].nodeValue;
break;
case 'data':
data = attributes[k].nodeValue;
break;
case 'context':
ctx = attributes[k].nodeValue;
break;
case 'type':
type = attributes[k].nodeValue;
break;
case 'postOnChange':
postOnChange = attributes[k].nodeValue;
break;
case 'completeWithoutOutput':
completeWithoutOutput = attributes[k].nodeValue === 'yes' ? true : false;
break;
}
}
response['theEvent'] = new Simulator.Event(obj, type, ctx, data, postOnChange, completeWithoutOutput); response['direction'] = dir;
return response;
}
function sendStartEvent() {
eventMgr.postEvent(new Simulator.Event(simMgr, 'command', 'load'));
}
function simIDgenerate() {
var id = new Date().getTime();
debug('simID generated: ' + id);
return id;
}
function debug(str1, str2, trace) {
dbg.debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg.debugf(source, str1, str2, trace);
}
};

// FILE: SimulationManager2.js (37d29644) 7/23/2014 4:30:37 PM

Simulator.SimulationManager = function (sim) {
var source = 'SimulationManager';
var name = 'SimulationManager';
var instance = this;
this.zoomFactor = 1;
var maxTrials = 0;
var initialTrialNum = 0;
var currentTrial = initialTrialNum;
var isTrialLimitReached = false;
var noMoreTrialsString = 'Limit on the Number of Trials Reached.';
var simulatorHeight = 0;
var simulatorWidth = 0;
var originalSimulatorHeight = 0;
var originalSimulatorWidth = 0;
var animationFinished = false;
var tableUpdated = false;
var itemName = '';
var redoingTrial = false;
var tableExists = false;
var animationCompleteWithoutOutput = false;
var stateDB = {};
var stateName = null;
var restoreAnimationOnReload = null;
var clearScoreOnNewTrial = false;
var useTrialNumFromDeleteQueue = false;
var state =
{
SimError: -1,
Uninitialized: 0,
Initialized: 1,
Instantiated: 2,
Loading: 3,
Loaded: 4,
Ready: 5,
TrialLimitReached: 6,
Playing: 7,
ReadOnly: 8
};
var currentState = state.Uninitialized;
var eventMgr = function () { return sim.getEventManager(); };
var whiteboard = function () { return sim.getWhiteboard(); };
var scoringTable = function () { return sim.getScoringTable(); };
var persistentVariableDB = sim.getPersistentVariableDB();
var trialNumStack = new Simulator.Utils.Stack(sim);
var deleteQueue = new Simulator.Utils.OrderedQueue(sim);
var layout = function () { return sim.getLayout(); };
var simID = function () { return sim.getSimID(); };
var dbg = function () { return sim.getDebug(); };
var dataTable = function () { return sim.getDataTable(); };
var simDocument = function () { return sim.getSimDocument(); };
registerAllEvents = function (simMgr) {
eventMgr().registerEvent(new Simulator.Event(simMgr, 'command', 'startTrial'));
eventMgr().registerEvent(new Simulator.Event(simMgr, 'command', 'newTrial'));
eventMgr().registerEvent(new Simulator.Event(simMgr, 'command', 'startAnimation'));
eventMgr().registerEvent(new Simulator.Event(simMgr, 'command', 'resetTrials'));
eventMgr().registerEvent(new Simulator.Event(simMgr, 'info', 'errorOccurred'));
eventMgr().registerEvent(new Simulator.Event(simMgr, 'info', 'animationStarted'));
eventMgr().registerEvent(new Simulator.Event(simMgr, 'info', 'animationFinished'));
eventMgr().registerEvent(new Simulator.Event(simMgr, 'info', 'animationThreadFinished'));
eventMgr().registerEvent(new Simulator.Event(simMgr, 'info', 'simulatorStateChange'));
eventMgr().registerEvent(new Simulator.Event(simMgr, 'info', 'animationUnreachable'));
eventMgr().registerEvent(new Simulator.Event(simMgr, 'info', 'tableUpdated'));
eventMgr().registerEvent(new Simulator.Event(simMgr, 'info', 'allMediaLoaded'));
eventMgr().registerEvent(new Simulator.Event(simMgr, 'info', 'allTableRowsCleared'));
eventMgr().registerEvent(new Simulator.Event(simMgr, 'command', 'redoTrial'));
eventMgr().registerEvent(new Simulator.Event(simMgr, 'info', 'simulatorDimensionsAvaiable'));
debug('Registered all pre - required events');
};
this.getName = function () {
return name;
};
this.getSourceName = function () {
return source;
};
this.getRestoreAnimationOnReload = function () {
return restoreAnimationOnReload;
};
this.setSimulatorHeight = function (height) {
if (height) {
simulatorHeight = height;
} else {
simulatorHeight = layout().getContainerHeight();
}
};
this.setSimulatorWidth = function (width) {
if (width) {
simulatorWidth = width;
} else {
simulatorWidth = layout().getContainerWidth();
}
};
this.setOriginalSimulatorHeight = function (height) {
if (height) {
originalSimulatorHeight = height;
} else {
originalSimulatorHeight = layout().getContainerHeight();
}
};
this.setOriginalSimulatorWidth = function (width) {
if (width) {
originalSimulatorWidth = width;
} else {
originalSimulatorWidth = layout().getContainerWidth();
}
};
this.getItemName = function () {
return itemName;
};
this.getSimulatorHeight = function () {
simulatorHeight = layout().getContainerHeight();
return simulatorHeight;
};
this.getSimulatorWidth = function () {
simulatorWidth = layout().getContainerWidth();
return simulatorWidth;
};
this.getOriginalSimulatorHeight = function () {
return originalSimulatorHeight;
};
this.getOriginalSimulatorWidth = function () {
return originalSimulatorWidth;
};
this.setAnimationCompleteWithoutOutput = function (flag) {
animationCompleteWithoutOutput = (flag === 'yes' || flag == true) ? true : false;
};
this.getAnimationCompleteWithoutOutput = function () {
return animationCompleteWithoutOutput;
};
this.setState = function (theState) {
currentState = theState;
switch (theState) {
case state.SimError: stateName = 'SimError'; break;
case state.Uninitialized: stateName = 'Uninitialized'; break;
case state.Initialized: stateName = 'Initialized'; break;
case state.Instantiated: stateName = 'Instantiated'; break;
case state.Loading: stateName = 'Loading'; break;
case state.Loaded: stateName = 'Loaded'; break;
case state.Ready: stateName = 'Ready'; break;
case state.TrialLimitReached: stateName = 'TrialLimitReached'; break;
case state.Playing: stateName = 'Playing'; break;
case state.ReadOnly: stateName = 'ReadOnly'; break;
default:
dbg().logError(source, 'Unknown state passed to setState: ' + theState);
return;
}
debugf('Simulator state: ' + stateName);
eventMgr().postEvent(new Simulator.Event(this, 'info', 'simulatorStateChange', stateName));
};
this.getState = function () {
return currentState;
};
this.getStateName = function () {
return stateName;
};
this.verifyCheckListSelection = function () {
return layout().hasEmptyChoiceListSelection();
};
this.setStateFromName = function (theStateName) {
switch (theStateName) {
case 'SimError': this.setState(state.SimError); break;
case 'Uninitialized': this.setState(state.Uninitialized); break;
case 'Initialized': this.setState(state.Initialized); break;
case 'Instantiated': this.setState(state.Instantiated); break;
case 'Loading': this.setState(state.Loading); break;
case 'Loaded': this.setState(state.Loaded); break;
case 'Ready': this.setState(state.Ready); break;
case 'TrialLimitReached': this.setState(state.TrialLimitReached); break;
case 'Playing': this.setState(state.Playing); break;
case 'ReadOnly': this.setState(state.ReadOnly); break;
default:
dbg().logError(source, 'Unknown state name passed to setState: ' + stateName);
return;
}
};
this.handleEvent = function (event) {
switch (event.type) {
case 'command':
switch (event.context) {
case 'startTrial':
var redoingATrial = this.adjustForRedoTrials();
if (!this.checkTrialLimitReached(redoingATrial)) {
layout().saveInputs();
tableUpdated = false;
animationFinished = false;
this.setAnimationCompleteWithoutOutput(false);
if (!redoingATrial) this.nextTrialNum();
} else this.trialLimitReachedAction();
break;
case 'startAnimation':
this.adjustForRedoTrials();
layout().saveInputs();
tableUpdated = false;
animationFinished = false;
break;
case 'newTrial':
if (!this.checkTrialLimitReached()) {
this.adjustForRedoTrials();
} else this.trialLimitReachedAction();
break;
case 'resetTrials':
if (!this.isReadOnly()) {
this.resetTrialNum();
layout().enableAllInput();
}
break;
case 'redoTrial':
if (!this.isReadOnly()) {
this.redoTrialNum(event.data);
}
break;
}
break;
case 'info':
switch (event.context) {
case 'animationStarted':
this.setPlayingState();
break;
case 'animationThreadFinished':
animationFinished = true;
debug(source, "Received animationThreadFinished event from, animationCompleteWithoutOutput = " + this.getAnimationCompleteWithoutOutput());
if (!this.getAnimationCompleteWithoutOutput()) {
debug('this.getTableExists() = ' + this.getTableExists() + ', tableUpdated = ' + tableUpdated);
if (this.getTableExists() && tableUpdated) {
dataTable().saveScoreableInputs();
whiteboard().clearCategory('evaluationOutput');
this.setReadyState();
} else {
if (!this.getTableExists()) {
debug(source, 'Table does not exist. Setting simulator state to Ready');
this.setReadyState();
}
else {
debug(source, 'Table does exist but has not been updated');
this.setReadyState();
}
}
} else {
dataTable().saveScoreableInputs();
debug(source, "Received animationThreadFinished event with animationCompleteWithoutOutput = true. Table was not updated. Current trial number remains at " + this.getTrialNum());
this.setReadyState();
}
break;
case 'animationUnreachable':
dbg.logWarning('AnimationUnreachable.Setting Ready state in SimulationManager.handleEvent');
this.setReadyState();
break;
case 'tableUpdated':
tableUpdated = true;
debug('Received tableUpdated event');
if (animationFinished) {
this.setReadyState();
}
break;
case 'allTableRowsCleared':
layout().enableAllInput();
break;
case 'allMediaLoaded':
debug("SimulationManager received 'allMediaLoaded' event");
this.setReadyState();
break;
case 'fatalErrorOccurred':
this.setState(state.Error);
eventMgr().postEvent(new Simulator.Event({ source: this, type: 'error', context: 'FatalSimulationError', data: event.data }));
eventMgr().stopEventProcessing();
break;
}
break;
default: dbg().logWarning(source, 'Unrecognized event of type "' + event.type + '" and context: "' + event.context + '"');
break;
}
};
this.lastTrialReached = function () {
if (deleteQueue.length() > 0) return false;
else if (maxTrials === 0) return false;
else if (trialNumStack.peek() < parseInt(maxTrials)) return false;
else {
trialNumStack.push(parseInt(maxTrials));
return true;
}
};
this.checkTrialLimitReached = function (redoingATrial) {
if (deleteQueue.length() > 0) {
isTrialLimitReached = false;
return false;
} else if (maxTrials === 0) {
isTrialLimitReached = false;
return false;
} else {
if (redoingATrial) isTrialLimitReached = (currentTrial > parseInt(maxTrials));
else isTrialLimitReached = (currentTrial >= parseInt(maxTrials));
return isTrialLimitReached;
}
};
this.trialLimitReached = function () {
return isTrialLimitReached;
};
this.nextTrialNum = function () {
var val = trialNumStack.peek();
if (isNaN(val)) trialNumStack.push(initialTrialNum);
else trialNumStack.push(parseInt(trialNumStack.peek()) + 1);
currentTrial = trialNumStack.peek();
if (!this.trialLimitReached() && clearScoreOnNewTrial) {
scoringTable().clearTable();
}
trialNumStack.inspect();
deleteQueue.inspect();
debug('SimulationManager.NextTrialNum: Setting next trial number to ' + currentTrial);
};
this.adjustForRedoTrials = function () {
if (deleteQueue.length() > 0) {
currentTrial = deleteQueue.remove();
useTrialNumFromDeleteQueue = true;
redoingTrial = false;
return true;
} else if (useTrialNumFromDeleteQueue) {
useTrialNumFromDeleteQueue = false;
currentTrial = trialNumStack.peek();
if (isNaN(currentTrial)) currentTrial = initialTrialNum;
return false;
} else return false;
};
this.redoTrialNum = function (num) {
deleteQueue.add(num);
trialNumStack.inspect();
deleteQueue.inspect();
redoingTrial = true;
this.setReadyState();
};
this.getTrialRowNum = function (recordOnChange) {
if (recordOnChange) {
if (deleteQueue.length() == 0) {
var val = trialNumStack.peek();
if (isNaN(val)) return initialTrialNum;
else return parseInt(trialNumStack.peek());
} else {
return deleteQueue.peek() - 1;
}
} else {
if (useTrialNumFromDeleteQueue) {
return currentTrial - 1;
} else {
var val = trialNumStack.peek();
if (isNaN(val)) return initialTrialNum;
else return parseInt(trialNumStack.peek());
}
}
}
this.isRedoingTrial = function () {
return redoingTrial;
};
this.getTrialNum = function () {
return currentTrial;
};
this.getInitialTrialNum = function () {
return initialTrialNum;
};
this.setTrialNum = function (num) {
trialNumStack.push(num);
currentTrial = num;
debug('SimulationManager.SetTrialNum: Setting current trial number to ' + currentTrial);
};
this.resumeTrials = function () {
};
this.resetTrialNum = function () {
deleteQueue.clear();
trialNumStack.push(Simulator.Constants.DEFAULT_INITIAL_TRIAL_NUM);
currentTrial = trialNumStack.peek();
};
this.getDisabledAction = function () {
switch (this.getState()) {
case state.TrialLimitReached:
return trialLimitReachedAction;
default: return this.noAction;
}
};
this.trialLimitReachedAction = function () {
this.setTrialLimitReachedState();
Simulator.showAlertWarning(this.getNoMoreTrialString());
};
this.noAction = function () {
return;
};
this.getNoMoreTrialString = function () {
return noMoreTrialsString;
};
this.getBaseURL = function () {
return baseURL;
};
this.getName = function () {
return source;
};
this.isPlaying = function () {
return this.getStateName() === 'Playing';
};
this.isReadOnly = function () {
return this.getStateName() == 'ReadOnly';
};
this.isReady = function () {
return (this.getState() === state.Ready);
};
this.setReadOnlyState = function (newState) {
newState === true ? this.setState(state.ReadOnly) : this.setState(state.Ready);
};
this.setReadyState = function () {
this.setState(state.Ready);
debugf('Enabling all input and setting simulator state to "Ready"', null, 'notrace');
layout().enableAllInput();
};
this.setPlayingState = function () {
debugf('Disabling all input and setting simulator state to "Playing"', null, 'notrace');
this.setState(state.Playing);
layout().disableAllInput();
};
this.setTrialLimitReachedState = function () {
this.setState(state.TrialLimitReached);
layout().disableAllInput();
};
this.getNextItem = function () {
window.location.reload();
};
this.getResponse = function () {
var contents = dataDB.getContents();
return contents;
};
this.setTableExists = function (flag) {
flag == true ? tableExists = true : tableExists = false;
};
this.getTableExists = function () {
return tableExists;
};
this.displaySimulatorState = function (embedded) {
var buff = [];
var aState = null;
buff.push('Simulator State:');
buff.push('-----------------------');
buff.push(deleteQueue.inspect(false));
buff.push(trialNumStack.inspect(false));
buff.push('currentTrial = ' + currentTrial);
buff.push('redoingTrial = ' + redoingTrial);
buff.push('currentState = ' + this.getStateName());
buff.push('zoomFactor = ' + this.zoomFactor);
buff.push('speechEnabled = ' + sim.getSpeechEnabled());
buff.push('simulator height = ' + this.getSimulatorHeight());
buff.push('simulator width = ' + this.getSimulatorWidth());
if (sim.getAnimationSet() !== null) {
aState = sim.getAnimationSet().getCurrentAnimationState();
} else {
aState = [];
aState['animation state'] = 'none';
}
for (var p in aState) buff.push(p + ' = ' + aState[p]);
buff.push('End of Simulator State');
buff.push('-----------------------');
if (!embedded) debug(buff.join('\n'));
else return buff.join('\n');
};
this.initManagerVariables = function () {
var whtBrd = whiteboard();
this.setTrialNum(Simulator.Constants.DEFAULT_INITIAL_TRIAL_NUM);
currentTrial = this.getTrialNum();
if (whtBrd.itemExists('initialization', 'MaxTrials')) {
maxTrials = whtBrd.getItem('initialization', 'MaxTrials');
if ((maxTrials) && (maxTrials > 0)) {
scoringTable().setMaxRowNum(maxTrials);
}
}
if (whtBrd.itemExists('initialization', 'NoMoreTrialsString')) {
noMoreTrialsString = whtBrd.getItem('initialization', 'NoMoreTrialsString');
}
if (whtBrd.itemExists('initialization', 'ClearScoreOnNewTrial')) {
clearScoreOnNewTrial = whtBrd.getItem('initialization', 'ClearScoreOnNewTrial');
clearScoreOnNewTrial = clearScoreOnNewTrial === 'yes' ? true : false;
}
if (whtBrd.itemExists('initialization', 'RestoreAnimationOnReload')) {
restoreAnimationOnReload = whtBrd.getItem('initialization', 'RestoreAnimationOnReload');
restoreAnimationOnReload = restoreAnimationOnReload === 'yes' ? true : false;
}
};
this.setSimulatorHeight = function (height) {
simulatorHeight = height;
};
this.setSimulatorWidth = function (width) {
simulatorWidth = width;
};
this.setResponseStateVariables = function (stateMgr) {
stateMgr.setResponseStateVariableValue('deleteQueue', deleteQueue.entriesAsString());
stateMgr.setResponseStateVariableValue('trialNumStack', trialNumStack.entriesAsString());
stateMgr.setResponseStateVariableValue('currentTrial', currentTrial);
stateMgr.setResponseStateVariableValue('redoingTrial', redoingTrial);
if (this.getStateName() == 'ReadOnly') stateMgr.setResponseStateVariableValue('currentState', 'Ready');
else stateMgr.setResponseStateVariableValue('currentState', this.getStateName());
stateMgr.setResponseStateVariableValue('zoomFactor', this.zoomFactor);
stateMgr.setResponseStateVariableValue('speechEnabled', sim.getSpeechEnabled());
if (this.getStateName() == 'ReadOnly') stateMgr.setResponseStateVariableValue('simulatorHeight', this.getOriginalSimulatorHeight());
else stateMgr.setResponseStateVariableValue('simulatorHeight', this.getSimulatorHeight());
if (this.getStateName() == 'ReadOnly') stateMgr.setResponseStateVariableValue('simulatorWidth', this.getOriginalSimulatorWidth());
else stateMgr.setResponseStateVariableValue('simulatorWidth', this.getSimulatorWidth());
};
this.clearSimulationState = function () {
trialNumStack.clear();
deleteQueue.clear();
};
function recordStateSpecs(initNode) {
if (initNode.length > 0) {
var children = initNode[0].childNodes;
for (var i = 0; i < children.length; i++) {
spec = children[i];
if (children[i].nodeName[0] != '#') {
varName = children[i].attributes[0].nodeValue;
stateDB.varName = '';
}
}
}
}
this.restoreStateVariables = function (stateDB) {
var parts = null;
for (p in stateDB) {
switch (p) {
case 'deleteQueue':
deleteQueue.clear();
parts = stateDB['deleteQueue'].split(',');
for (var i = 0; i < parts.length; i++) {
if (parts[i]) {
if (parts[i] !== undefined && parts[i] !== '') deleteQueue.add(parseInt(parts[i]));
}
}
break;
case 'trialNumStack':
trialNumStack.clear();
parts = stateDB['trialNumStack'].split(',');
for (var i = parts.length - 1; i > -1; i--) {
if (parts[i]) {
if (parts[i] !== undefined && parts[i] !== '') trialNumStack.push(parseInt(parts[i]));
}
}
break;
case 'currentTrial':
if (stateDB[p] !== '') currentTrial = parseInt(stateDB[p]);
break;
case 'redoingTrial':
redoingTrial = stateDB[p] === 'true' ? true : false;
break;
case 'currentState':
this.setStateFromName(stateDB[p]);
break;
case 'zoomFactor':
this.zoomFactor = parseFloat(stateDB[p]);
break;
case 'simulatorHeight':
this.setSimulatorHeight(stateDB[p]);
this.setOriginalSimulatorHeight(stateDB[p]);
break;
case 'simulatorWidth':
this.setSimulatorWidth(stateDB[p]);
this.setOriginalSimulatorWidth(stateDB[p]);
break;
}
}
this.displaySimulatorState();
};
if (sim) registerAllEvents(instance);
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};

// FILE: ResponseStateManager2.js (a910fe9e) 3/7/2014 11:24:14 AM

Simulator.ResponseStateManager = function (sim) {
var stateDB = {};
var persistentVarDB = function () { return sim.getPersistentVariableDB(); };
var util = function () { return sim.getUtils(); };
var simMgr = function () { return sim.getSimulationManager(); };
var dbg = function () { return sim.getDebug(); };
var scoringTable = function () { return sim.getScoringTable(); };
var dataTable = function () { return sim.getDataTable(); };
var simDocument = function() { return sim.getSimDocument(); };
var setStateVarSpec = function (initNode) {
var attr = initNode.attributes;
if (attr.length > 0) {
var element = attr['element'].nodeValue;
var value = attr['value'].nodeValue;
if (attr['persistent']) {
if (attr['persistent'].nodeValue == 'yes') persistentVarDB().updateElement(element, value);
}
else stateDB[element] = value;
}
};
var setInputStateSpec = function (initNode, panel) {
var attr = initNode.attributes;
if (attr.length > 0) {
var element = attr['element' +
''].nodeValue;
var value = attr['value'].nodeValue;
panel.setElementSelectState(element, value);
}
};
var setAnimationStateSpec = function (initNode) {
var spec = null;
var attr = null;
var animationStateDB = [];
var children = initNode.childNodes;
for (var i = 0; i < children.length; i++) {
if (children[i].nodeName[0] != '#') {
spec = children[i];
attr = spec.attributes;
if (attr.length > 0) {
var element = attr['element'].nodeValue;
var value = attr['value'].nodeValue;
animationStateDB[element] = value;
}
}
}
if (Object.size(animationStateDB) > 0) sim.getAnimationSet().setCurrentAnimationState(animationStateDB);
};
function writeSimulationState(indent) {
var simStateStr = indent + '<state>\n';
var doubleIndent = indent + indent;
var tripleIndent = doubleIndent + indent;
for (var p in stateDB) {
simStateStr = simStateStr + doubleIndent + '<stateSpec element="' + p + '" value="' + stateDB[p] + '" /> \n';
}
var store = persistentVarDB().getContents();
for (var i in store) {
simStateStr = simStateStr + doubleIndent + '<stateSpec element="' + i + '" value="' + store[i] + '" persistent="yes" /> \n';
}
var inputState = sim.getLayout().getPanelInstance(Simulator.Constants.INPUT_PANEL_NAME).saveInputElementStates(indent, '<inputSpec ', 'element="', '" value="', '" />\n');
simStateStr = simStateStr + inputState;
var displayTable = dataTable();
if (displayTable) {
var tableStr = displayTable.getContents(tripleIndent);
if (tableStr) {
simStateStr = simStateStr + doubleIndent + '<stateTableSpec id="dataTable"> \n' +
tableStr + doubleIndent + '</stateTableSpec>';
}
}
if (simMgr().getRestoreAnimationOnReload()) {
var animationState = sim.getAnimationSet().getCurrentAnimationState();
if (animationState != undefined && animationState != null) {
simStateStr = simStateStr + doubleIndent + '<animationStateSpec> \n';
for (var k in animationState) {
simStateStr = simStateStr + tripleIndent + '<stateSpec element="' + k + '" value="' + animationState[k] + '" /> \n';
}
simStateStr = simStateStr + doubleIndent + '</animationStateSpec>';
}
}
simStateStr = simStateStr + indent + '\n</state>\n';
return simStateStr;
}
this.setResponseStateVariableValue = function (theVariable, theValue) {
stateDB[theVariable] = theValue;
};
this.getResponseStateVariableValue = function (theVariable) {
return stateDB[theVariable];
};
this.restoreSimulation = function (xmlDoc) {
var responseSpec = xmlDoc.getElementsByTagName('responseSpec')[0];
if (responseSpec) {
var simState = responseSpec.getElementsByTagName('state')[0];
var children = simState.childNodes;
for (var i = 0; i < children.length; i++) {
if (children[i].nodeName[0] != '#') {
switch (children[i].nodeName) {
case 'stateSpec':
setStateVarSpec(children[i]);
break;
case 'inputSpec':
setInputStateSpec(children[i], sim.getLayout().getPanelInstance(Simulator.Constants.INPUT_PANEL_NAME));
break;
case 'stateTableSpec':
var nextGen = children[i].childNodes;
for (var q = 0; q < nextGen.length; q++) {
if (nextGen[q].nodeName == 'stateTable') {
dataTable().loadFromResponse(nextGen[q]);
}
}
break;
case 'animationStateSpec':
setAnimationStateSpec(children[i]);
break;
}
}
}
simMgr().restoreStateVariables(stateDB);
scoringTable().restoreResponseTable(responseSpec.getElementsByTagName('responseTable')[0]);
}
};
this.saveState = function () {
var stateStr = '<responseSpec>\n';
var responseStr = scoringTable().getContents('  ');
stateStr += responseStr + '\n\n';
stateStr += writeSimulationState('  ');
stateStr += '\n</responseSpec>';
return stateStr;
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};

// FILE: Canvas2.js (958ad2a2) 3/7/2014 11:24:14 AM

Simulator.Display.Canvas = function(sim) {
Simulator.SimElement.call(this, sim);
var source = 'Canvas';
var instance = this;
var hTMLElement = '';
var top = 0;
var left = 0;
var height = 0;
var width = 0;
var backgroundColor = '';
var dbg = function() {return sim.getDebug();};
var simulationMgr = function() {return sim.getSimulationManager();};
var simDocument = function() { return sim.getSimDocument(); };
this.getHTMLElement = function() {
return hTMLElement;
};
this.setHTMLElement = function(newHTMLElement) {
hTMLElement = newHTMLElement;
return this;
};
this.getTop = function() {
return top;
};
this.setTop = function(newTop) {
top = newTop;
return this;
};
this.getLeft = function() {
return left;
};
this.setLeft = function(newLeft) {
left = newLeft;
return this;
};
this.getHeight = function() {
if(simulationMgr()) {
return (parseFloat(height)/100)*(simulationMgr().getSimulatorHeight());
}
else return 0;
};
this.getHeightPercentage = function() {
return height;
};
this.setHeight = function(newHeight) {
height = newHeight;
return this;
};
this.getWidth = function() {
if(simulationMgr()) {
return (parseFloat(width)/100)*(simulationMgr().getSimulatorWidth());
}
else return 0;
};
this.getWidthPercentage = function() {
return width;
};
this.setWidth = function(newWidth) {
width = newWidth;
return this;
};
this.getBackgroundColor = function() {
return backgroundColor;
};
this.setBackgroundColor = function(newBackgroundColor) {
backgroundColor = newBackgroundColor;
return this;
};
this.containsElement = function(elementID) {
var children = hTMLElement.childNodes;
for(var i = 0; i < children.length; i++) {
if(children[i].nodeName[0] != '#') {
if(children[i].nodeValue == elementID) return true;
}
}
return false;
};
this.containsElementWithAttribute = function(elementID, attributeName, attributeValue) {
var attributes = null;
var children = hTMLElement.childNodes;
for(var i = 0; i < children.length; i++) {
if(children[i].nodeName[0] != '#') {
if(children[i].nodeValue == elementID) {
attributes = children[i].attributes;
if(attributes) {
if(attributeName in attributes) {
if(attributeValue) return attributes[attributeName] == attributeValue;
else return true;
}
} else return false;
} else return false;
}
}
return false;
};
this.setEname('Canvas');
this.setAttributes = function(attr, node) {
Simulator.Display.Canvas.prototype.setAttributes.call(this, attr, node);
for (var i in attr) {
switch (i) {
case 'top':
this.setTop(attr[i]);
break;
case 'left':
this.setLeft(attr[i]);
break;
case 'height':
this.setHeight(attr[i]);
break;
case 'width':
this.setWidth(attr[i]);
break;
case 'backgroundColor':
this.setBackgroundColor(attr[i]);
break;
}
}
};
this.getSourceName = function() {
return source;
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Display.Canvas.prototype = new Simulator.SimElement();
Simulator.Display.Canvas.prototype.constructor = Simulator.Display.Canvas;

// FILE: Panel2.js (2a3b3e28) 5/2/2014 12:55:58 PM

Simulator.Display.Panel = function (sim, panelNum) {
Simulator.Display.Canvas.call(this, sim);
var source = 'Panel';
var instance = this;
var headerText = '';
var headerTextSize = '';
var float = '';
var initialFocus = false;
var display = 'hidden';
var borderColor = '';
var dialogAttr = [];
var panelNumber = panelNum;
var panelID = '';
var dialogPanel = null;
var ioElements = [];
var dialogButtonLabel = "";
var originalWidth = null;
var originalHeight = null;
var dbg = function () { return sim.getDebug(); };
var utils = function () { return sim.getUtils(); };
var simDocument = function () { return sim.getSimDocument(); };
this.registerIOElement = function (inputElement) {
ioElements.push(inputElement);
};
this.getOriginalHeight = function () {
return originalHeight;
}
this.getOriginalWidth = function () {
return originalWidth;
}
this.recordOriginalWidthAndHeight = function () {
if (this.getName() == 'animationPanel' && !(originalWidth > 0 && originalHeight > 0)) {
originalWidth = this.getWidth();
originalHeight = this.getHeight();
debugf(source, 'Recording Original Width =' + originalWidth + ' Original Heigth =' + originalHeight);
}
}
this.getHeaderText = function () {
return headerText;
};
this.setHeaderText = function (newHeaderText) {
headerText = newHeaderText;
return this;
};
this.getHeaderTextSize = function () {
return headerTextSize;
};
this.setHeaderTextSize = function (textSize) {
headerTextSize = textSize == 'small' || textSize == 'medium' | textSize == 'large' | textSize == 'x-Large' ? textSize : null;
if (!headerTextSize) {
dbg().logError(source, 'Invalid value for headerTextSize attribute: ' + textSize);
headerTextSize = '';
}
return this;
};
this.getFloat = function () {
return float;
};
this.setFloat = function (newFloat) {
float = newFloat == 'left' | newFloat == 'right' || newFloat == 'none' ? newFloat : null;
if (!float) {
dbg().logError(source, 'Invalid value for float attribute: ' + newFloat);
newFloat = '';
}
return this;
};
this.getInitialFocus = function () {
return initialFocus;
};
this.setInitialFocus = function (newInitialFocus) {
initialFocus = newInitialFocus == 'yes' ? true : false;
return this;
};
this.setDialogButtonLabel = function (newLabel) {
dialogButtonLabel = newLabel;
};
this.getDialogButtonLabel = function () {
return dialogButtonLabel;
};
this.getDisplay = function () {
return display;
};
this.setDisplay = function (newDisplay) {
display = (newDisplay == 'inline' || newDisplay == 'block' || newDisplay == 'none' || newDisplay == 'hidden' || newDisplay == 'visible') ? newDisplay : null;
if (!display) {
dbg().logError(source, 'Invalid value for display attribute: ' + newDisplay);
display = 'hidden';
}
return this;
};
this.resize = function (zoom) {
if (this.getName() == 'animationPanel') {
sim.getAnimationSet().getRenderer().resizeAnimationElements(this, zoom);
}
};
this.getBorderColor = function () {
return borderColor;
};
this.setBorderColor = function (newBorderColor) {
borderColor = newBorderColor;
return this;
};
this.appendStr = function (str) {
var hElement = this.getHTMLElement();
hElement.innerHTML = hElement.innerHTML + str;
};
this.setStr = function (str) {
var hElement = this.getHTMLElement();
hElement.innerHTML = str;
};
this.resetStr = function (str) {
var hElement = this.getHTMLElement();
hElement.innerHTML = this.getHeaderText() + str;
};
this.disableAllInput = function () {
for (var i = 0; i < ioElements.length; i++) {
ioElements[i].disableInput();
}
};
this.enableAllInput = function () {
for (var i = 0; i < ioElements.length; i++) {
ioElements[i].enableInput();
}
};
this.saveInputs = function () {
for (var i = 0; i < ioElements.length; i++) {
if (ioElements[i].recordInput)
ioElements[i].recordInput();
}
};
this.saveInputElementStates = function (indent, preface, nameStr, valStr, suffix) {
var stateStr = '';
for (var i = 0; i < ioElements.length; i++) {
if (ioElements[i].saveState) {
stateStr = stateStr + indent + ioElements[i].saveState(indent, preface, nameStr, valStr, suffix);
}
}
return stateStr;
};
this.setElementSelectState = function (elementID, contents) {
var iElement = null;
for (var i = 0; i < ioElements.length; i++) {
iElement = ioElements[i];
if (iElement.getName() == elementID) iElement.setElementSelectState('true', contents);
}
};
this.hasEmptyChoiceListSelection = function () {
var iElement = null;
for (var i = 0; i < ioElements.length; i++) {
iElement = ioElements[i];
if (iElement.getType() === 'choiceList') {
var choiceSelection = iElement.getData();
if (choiceSelection.length == 0) {
var sectionLabel = iElement.getSectionLabel();
if ((sectionLabel != null) && (sectionLabel != '')) {
dbg().logFatalError(iElement.getName(), 'you must make a selection for "' + sectionLabel + '"!');
} else {
dbg().logFatalError(iElement.getName(), 'you must make a selection for a choice element!');
}
return true;
}
}
}
return false;
};
this.getHTMLPanel = function () {
return simDocument().getElementById(this.getName());
};
this.setAttributes = function (panel, attr) {
Simulator.Display.Panel.prototype.setAttributes.call(this, attr);
for (var i in attr) {
switch (i) {
case 'headerText':
this.setHeaderText(attr[i]);
break;
case 'headerTextSize':
this.setHeaderTextSize(attr[i]);
break;
case 'float':
this.setFloat(attr[i]);
break;
case 'display':
this.setDisplay(attr[i]);
break;
case 'border':
this.setBorder(attr[i]);
break;
case 'initialFocus':
this.setInitialFocus(attr[i]);
break;
case 'instructions':
dialogAttr[i] = attr[i];
break;
case 'button':
this.setDialogButtonLabel(attr[i]);
break;
case 'borderColor':
this.setBorderColor(attr[i]);
break;
case 'title':
this.setTitle(attr[i]);
break;
}
}
if (!utils().assocArrayIsEmpty(dialogAttr)) dialogPanel = new Simulator.Display.DialogPanel(sim, instance, panelID, this.getDialogButtonLabel(), dialogAttr);
};
this.render = function () {
var div = simDocument().createElement('div');
if (this.getFloat()) {
div.style.display = this.getFloat();
}
if (this.getHeightPercentage()) {
div.style.height = this.getHeightPercentage();
}
if (this.getWidthPercentage()) {
div.style.width = this.getWidthPercentage();
}
if (this.getTop()) {
div.style.top = this.getTop();
}
if (this.getLeft()) {
div.style.left = this.getLeft();
}
div.id = this.getNodeID();
div.setAttribute('class', 'panel' + panelNumber + ' panelSingle ' + this.getName());
if (this.getHeaderText()) {
var div2 = simDocument().createElement('div');
div2.setAttribute('class', 'holderInfo');
div2.innerHTML = this.getHeaderText();
div.appendChild(div2);
}
var container = simDocument().getElementById(Simulator.Constants.SIM_CONTAINER_NAME + sim.getSimID());
container.appendChild(div);
this.setHTMLElement(div);
if ('instructions' in dialogAttr) {
if ('button' in dialogAttr) dialogPanel.render();
else div.innerHTML = this.getDialogAttr()['instructions'];
}
this.mapHTML2JS(div);
};
this.getSourceName = function () {
return source;
};
this.inspect = function (embedded, forced) {
var buff = [];
var sep = '\n';
if (!embedded)
buff.push('Inspecting ' + this.getName() + ' panel');
buff.push(sep);
for (var i in this) {
if (i.substr(0, 3) == 'get') {
buff.push(i);
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
if (!embedded) forced === null ? debug(buff.join('')) : debugf(buff.join(''));
else return buff.join('');
};
this.addPanelClass = function (className) {
var htmlPanel = simDocument().getElementById(this.getNodeID());
if (htmlPanel) {
var classNames = htmlPanel.getAttribute('class');
if (classNames.indexOf(className) != -1) {
return;
}
if (classNames != '') {
className = ' ' + className;
}
classNames = classNames + className;
htmlPanel.setAttribute('class', classNames);
}
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Display.Panel.prototype = new Simulator.Display.Canvas();
Simulator.Display.Panel.prototype.constructor = Simulator.Display.Panel;

// FILE: InlineData2.js (3bc75045) 3/7/2014 11:24:14 AM

Simulator.Animation.InlineData = function (sim) {
var source = 'InlineData';
var id = '';
var name = '';
var data = '';
var animationElementName = '';
var util = function () { return sim.getUtils(); };
var simDocument = function() { return sim.getSimDocument(); };
var dbg = function () { return sim.getDebug(); }
this.setID = function(newID) {
id = newID;
};
this.getID = function() {
return id;
};
this.setName = function(newName) {
name = newName;
return this;
};
this.getName = function() {
return name;
};
this.setData = function(newData) {
data = newData;
return this;
};
this.getData = function() {
return data;
};
this.setAnimationElement = function(newAnimationElementName) {
animationElementName = newAnimationElementName;
};
this.getAnimationElementName = function() {
return animationElementName;
};
this.getSourceName = function() {
return source;
};
this.inspect = function(embedded, force) {
var buff = [];
var sep = '\n\n';
buff.push('Inspecting InlineData element ' + this.getName());
if (i.substr(0, 3) == 'get') {
buff.push(i);
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
buff.push('End of inlineData element inspection');
buff.push(sep);
if(embedded) return buff.join('');
else force == null ? debug(buff.join('')) : debugf(buff.join(''));
};
Simulator.Animation.InlineData.prototype.setAttributes = function (attr, node) {
var attr = util().getAttributes(node);
for (var i in attr) {
switch (i) {
case 'id':
this.setID(attr[i]);
break;
case 'name':
this.setName(attr[i]);
break;
case 'animationElement':
this.setAnimationElement(attr[i]);
break;
}
}
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
}

// FILE: AnimationElement2.js (506d508b) 3/7/2014 11:24:14 AM

Simulator.Animation.AnimationElement = function (sim) {
Simulator.SimElement.call(this, sim);
var source = 'AnimationElement';
var controls = '';
var src = '';
var altSrc = '';
var altSrcType = '';
var altText = '';
var behavior = 'timeline';
var inlineDataID = '';
var interactive = false;
this.setEname(source);
var util = function () { return sim.getUtils(); };
var simDocument = function () { return sim.getSimDocument(); };
var dbg = function () { return sim.getDebug(); };
var simMgr = function () { return sim.getSimulationManager(); };
this.getControls = function () {
return controls;
};
this.setControls = function (newControls) {
controls = newControls == 'yes' ? 'controls' : '';
return this;
};
this.getSrc = function () {
return src;
};
this.setSrc = function (newSrc) {
var filename = util().getFileName(newSrc, true);
if (filename == 'inlineData') src = '';
else src = newSrc;
return this;
};
this.getAltSrc = function () {
return altSrc;
};
this.setAltSrc = function (newAltSrc) {
var filename = util().getFileName(newAltSrc, true);
if (filename == 'inlineData') altSrc = '';
else altSrc = newAltSrc;
return this;
};
this.getAltSrcType = function () {
return altSrcType;
};
this.setAltSrcType = function (newAltSrcType) {
altSrcType = newAltSrcType;
return this;
};
this.setAltText = function (newAltText) {
altText = newAltText;
return this;
};
this.getAltText = function () {
return altText;
};
this.setInteractive = function (newInteractive) {
interactive = (newInteractive == "yes") ? true : false;
if (interactive) behavior = Simulator.Constants.INTERACTIVE_ANIMATION;
return this;
};
this.getInteractive = function () {
return interactive;
};
this.getBehavior = function () {
return behavior;
};
this.setBehavior = function (newBehavior) {
behavior = newBehavior;
if (behavior === Simulator.Constants.INTERACTIVE_ANIMATION) interaction = true;
return this;
};
this.setInlineDataID = function (newInlineDataID) {
inlineDataID = newInlineDataID;
return this;
};
this.getInlineDataID = function () {
return inlineDataID;
};
this.setAttributes = function (attr, node) {
if (node) attr = util().getAttributes(node);
Simulator.Animation.AnimationElement.prototype.setAttributes.call(this, attr, node);
for (var i in attr) {
switch (i) {
case 'controls':
this.setControls(attr[i]);
break;
case 'src':
this.setSrc(attr[i]);
break;
case 'altSrc':
this.setAltSrc(attr[i]);
break;
case 'altSrcType':
this.setAltSrcType(attr[i]);
break;
case 'altText':
this.setAltText(attr[i]);
break;
case 'behavior':
this.setBehavior(attr[i]);
break;
case "interactive":
this.setInteractive(attr[i]);
break;
default:
continue;
}
}
};
this.getSourceName = function () {
return source;
};
this.inspect = function (embedded, force) {
var buff = [];
var sep = '\n\n';
buff.push('Inspecting ');
buff.push(this.getEname());
buff.push(': ');
buff.push(this.getName());
buff.push(sep);
for (var i in this) {
if (i.substr(0, 3) == 'get') {
buff.push(i);
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
if (embedded) return buff.join('');
else force == null ? debug(buff.join('')) : debugf(buff.join(''));
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Animation.AnimationElement.prototype = new Simulator.SimElement();
Simulator.Animation.AnimationElement.parent = Simulator.SimElement;
Simulator.Animation.AnimationElement.prototype.constructor = Simulator.Animation.AnimationElement;

// FILE: AnimationRenderer2.js (b613b00c) 3/7/2014 11:24:14 AM

Simulator.Animation.AnimationRenderer = function (sim, thePanel, animationSet) {
Simulator.SimItem.call(this, sim);
var source = 'AnimationRenderer';
var prevImageID = null;
var elementInfomediaType = null;
var elementInfoid = null;
var elementInfosrc = null;
var ID_SEPARATOR = '!';
var currenAnimationName = null;
var currentAnimationElement = null;
var tries = 0;
var maxTries = 10;
var animationInterval = 500;
var panel = thePanel;
var simID = null;
var iFrameID = null;
if (sim) {
simID = sim.getSimID();
}
var util = function () { return sim.getUtils(); };
var dbg = function () { return sim.getDebug(); };
var whiteboard = function () { return sim.getWhiteboard(); };
var eventMgr = function () { return sim.getEventManager(); };
var simMgr = function () { return sim.getSimulationManager(); };
var layout = function () { return sim.getLayout(); };
var simDocument = function () { return sim.getSimDocument(); };
function doImageRendering(element, img, panelName, div, span, renderMaxTime) {
debug('In doImageRendering - Image = ' + img.src + ', height = ' + img.height + ', width = ' + img.width);
var dimensions = util().setDimensions(panel.getHeight(), panel.getWidth(), img.height, img.width, 10              );
if (dimensions.height > 0 && dimensions.width > 0) {
img.height = dimensions.height;
img.width = dimensions.width;
debug('In doImageRendering - Image resize with padding to height = ' + img.height + ', width = ' + img.width);
}
span.appendChild(img);
elementInfomediaType = 'image';
elementInfoid = div.id;
elementInfosrc = img.src;
if (!renderMaxTime) remderMaxTime = 0;
if (renderMaxTime >= 0) setTimeout(function () { handleTimeout(element); }, renderMaxTime);
}
function handleTimeout(renderedElement) {
var anEvent = null;
if (renderedElement != undefined && renderedElement != null) {
var thread = animationSet.getCurrentThread();
if (thread != null && thread != undefined) {
var element = thread.renderNextThreadElement();
if (element == null) {
anEvent = new Simulator.Event(renderedElement, "info", "animationThreadFinished");
eventMgr().postEvent(anEvent);
}
}
else {
anEvent = new Simulator.Event(renderedElement, "info", "animationThreadFinished");
eventMgr().postEvent(anEvent);
}
}
else
dbg().logFatalError(source, "renderedElement is null in AnimationRenderer.handleTimeout");
};
function flashEmbedSuccessCallback(event) {
if (!event.success) {
animationSet.setCurrentAnimation(null);
dbg().logFatalError(source, 'Could not embed flash element ' + event.id);
} else {
animationSet.setCurrentAnimation(simDocument().getElementById(event.ref.id));
eventMgr().postEvent(new Simulator.Event(animationSet, 'info', 'animationEmbedded', event.ref));
sendDataToAnimationElement(false);
}
}
function sendDataToAnimationElement(element, update) {
var t = null;
var foundSource = false;
var interactive = false;
var data = '';
element = (!element) ? currentAnimationElement : element;
debug('In sendDataToAnimationElement - element = ' + element.getName());
if (util().elementInArray(animationSet.getInputSource(), 'evaluator')) {
data = whiteboard().getItem('evaluationOutput', 'output');
if (data == null || data == '') data = '';
else foundSource = true;
}
if (util().elementInArray(animationSet.getInputSource(), 'animation')) {
var animationData = whiteboard().getCategoryAsString('animationInput');
foundSource = true;
if (animationData != '' && animationData != null) {
if (data != '' && data != null) data += Simulator.Constants.PAIR_DELIMITTER + animationData;
else data = animationData;
}
}
if (foundSource == false) {
dbg().logFatalError(source, 'Unknown input source ' + animationSet.getInputSource() + ' in sendDataToAnimationElement. No data sent to animation element');
return;
}
if (tries == 0) util().markTime();
var movie = animationSet.getCurrentAnimation();
if (movie) {
if (!movie.animationInput) {
t = setTimeout(function () { sendDataToAnimationElement(element, false); }, animationInterval);
tries++;
if (tries > maxTries) {
clearTimeout(t);
tries = 0;
dbg().logFatalError(source, 'Could not establish interface with animation element ' + currenAnimationName + ' after ' + tries
+ ' attempts spanning ' + util().getElapsedTime() + ' ms');
}
return;
}
else {
clearTimeout(t);
tries = 0;
var simID = sim.getSimID();
if (element.getInteractive) interactive = element.getInteractive();
if (movie.animationInitialize) movie.animationInitialize(simID, interactive);
if (!update) {
if ((data != null) && (data != '')) {
movie.animationInput(simID, 'input', data);
debugf('Sending "' + data + '" to animation "' + currenAnimationName + '"');
}
else {
movie.animationInput(simID, 'input', 'input');
debugf('Sending "input" to animation "' + currenAnimationName + '"');
}
debugf('Sending "play" to current animation after ' + util().getElapsedTime() + ' ms');
eventMgr().postEvent(new Simulator.Event(animationSet, 'info', 'animationStarted'));
movie.animationInput(simID, 'command', 'play');
}
else {
if (movie.animationInput) {
debugf('Sending "update" to animation "' + currenAnimationName + '" with data: "' + data + '" after ' + util().getElapsedTime() + ' ms');
eventMgr().postEvent(new Simulator.Event(animationSet, 'info', 'animationStarted'));
if ((data != null) && (data != '')) movie.animationInput(simID, 'update', data);
else movie.animationInput(simID, 'update', 'input');
}
else dbg().logFatalError(source, 'Could not re-establish previously established interface with animation element ' + currenAnimationName);
}
}
}
}
function removeFlash(flashObj) {
swfobject.removeSWF(flashObj);
animationSet.setCurrentAnimation(null);
}
function formatAnimationInput(data) {
}
this.sendDataToAnimation = function (element) {
sendDataToAnimationElement(element, false);
};
this.renderImage = function (element, panelName, imageSrc, currentElementName, renderMaxTime, thread) {
var img = null;
var span = null;
var HTMLAnimation = null;
var HTMLPanel = panel.getHTMLElement();
span = simDocument().getElementById('holdingSpan' + simID);
if (span)
HTMLAnimation = span.getElementsByTagName('img')[0];
if (!HTMLAnimation)
HTMLAnimation = simDocument().getElementById(prevImageID);
if (HTMLAnimation) {
HTMLAnimation.src = imageSrc;
HTMLAnimation.id = element.getName();
if (!renderMaxTime) remderMaxTime = 0;
if (renderMaxTime >= 0) setTimeout(function () { handleTimeout(element); }, renderMaxTime);
}
else {
var div = simDocument().getElementById('holderAnimation' + simID);
if (div && div.media != 'imageAnimation') {
var parent = div.parentNode;
if (parent.id == 'outerDiv')
HTMLPanel.removeChild(parent);
else
HTMLPanel.removeChild(div);
}
div = simDocument().createElement('div');
div.id = 'holderAnimation' + simID;
div.elementName = currentElementName;
div.setAttribute('class', 'holderAnimation');
div.media = 'imageAnimation';
HTMLPanel.appendChild(div);
span = simDocument().createElement('span');
span.setAttribute('class', 'holderCell');
span.id = 'holdingSpan' + simID;
div.appendChild(span);
img = simDocument().createElement('img');
img.id = currentElementName;
prevImageID = img.id;
var imageLoaded = false, wait;
util().bindEvent(img, 'load', function () { imageLoaded = true; });
img.src = imageSrc;
wait = setInterval(function () {
if (imageLoaded) {
clearInterval(wait);
eventMgr().postEvent(new Simulator.Event(element, 'info', 'imageEmbedded', img));
eventMgr().postEvent(new Simulator.Event(element, "info", "allMediaLoaded"));
doImageRendering(element, img, panelName, div, span, renderMaxTime);
}
}, 1);
}
};
this.renderAnimation = function (element, panelName, animationSrc, animationName, animationControls, currentElementName, renderMaxTime, thread) {
var holderDiv = null;
var hsize = panel.getHeight();
var wsize = panel.getWidth();
var HTMLPanel = panel.getHTMLElement();
var result = null;
var initialRender = false;
if (elementInfomediaType != 'animation' || elementInfosrc != animationSrc) {
holderDiv = simDocument().getElementById('holderAnimation' + simID);
if (holderDiv && holderDiv.media != 'animation') {
var parent = holderDiv.parentNode;
if (parent.id == 'outerDiv') HTMLPanel.removeChild(parent);
else HTMLPanel.removeChild(holderDiv);
initialRender = true;
}
holderDiv = simDocument().createElement('div');
holderDiv.id = 'holderAnimation' + simID;
holderDiv.name = 'holderAnimation' + simID;
holderDiv.elementName = animationName;
holderDiv.setAttribute('class', 'holderAnimation');
HTMLPanel.appendChild(holderDiv);
elementInfomediaType = 'animation';
elementInfoid = holderDiv.id;
initialRender = true;
} else holderDiv = simDocument().getElementById('holderAnimation' + simID);
elementInfosrc = animationSrc;
currentAnimationElement = element;
if(sim.getAccessibilityIFActive()) {
var altText = element.getAltText();
var altTextSpan = simDocument().createElement('span');
altTextSpan.style.position='absolute';
altTextSpan.style.top = '50%';
holderDiv.style.verticalAlign='middle';
holderDiv.style.horizontalAlign='center';
altTextSpan.style.fontSize = 'xx-large';
altTextSpan.innerHTML = altText;
holderDiv.innerHTML = '';
holderDiv.appendChild(altTextSpan);
debug('renderAnimation simulating time of animation execution since accessibilityIF is true');
setTimeout(simulateAnimationExecutionTime, 5000);
return;
}
if (!iFrameID) iFrameID = this.createItemID(true, -1, 'html5iFrame');
var iFrame = simDocument().getElementById(iFrameID);
if (!iFrame) {
iFrame = simDocument().createElement('iframe');
iFrame.id = iFrameID;
iFrame.width = wsize - 5;
iFrame.height = hsize - 5;
debug('iFrame.height = ' + iFrame.height + ', iFrame.width = ' + iFrame.width);
iFrame.border = 0;
iFrame.scrolling = 'no';
iFrame.src = appendExternalScriptURLParameter(animationSrc, sim.getAnimationExternalScriptsPath());
iFrame.setAttribute('style', 'height:' + iFrame.height + 'px !important');
iFrame.setAttribute('class', 'centeredAnimation');
if (initialRender) holderDiv.appendChild(iFrame);
iFrame.onload = function () {
debug("iFrame is loaded");
createHTML5AnimationInterface(element, iFrame, animationName);
};
}
else {
if (renderMaxTime != undefined && renderMaxTime != null && renderMaxTime >= 0) {
setTimeout(function () { handleTimeout(element); }, renderMaxTime);
}
sendDataToAnimationElement();
}
};
function appendExternalScriptURLParameter(animationUrl, scriptUrl) {
if (scriptUrl)
scriptUrl = encodeURIComponent(scriptUrl);
if (animationUrl) {
if (animationUrl.indexOf('?') != -1)
animationUrl = animationUrl.replace('?', '?scriptUrl=' + scriptUrl + '&');
else
animationUrl = animationUrl + '?scriptUrl=' + scriptUrl;
}
return animationUrl;
}
function createHTML5AnimationInterface(element, iFrame, animationName, renderMaxTime) {
var html5Shell = new Simulator.Animation.HTML5Shell(sim, simID);
if (!html5Shell) {
dbg().logFatalError(source, 'Could not instantiate HTML5Shell');
} else {
var parameters = {
callback: animationSet.animationMediaOutput,
behavior: element.getBehavior(),
inlineData: null,
containerID: iFrame.id,
outputOnReq: animationSet.getOutputOnRequest()
};
animationSet.setCurrentAnimation(html5Shell);
result = html5Shell.initialize(simID, parameters);
if (result !== Simulator.Constants.ANIMATION_LOADED) dbg().logFatalError(source, 'Could not initialize HTML5Shell');
currenAnimationName = animationName;
}
if (renderMaxTime != undefined && renderMaxTime != null && renderMaxTime >= 0) {
setTimeout(function () { handleTimeout(element); }, renderMaxTime);
}
sendDataToAnimationElement(element, false);
};
this.renderHotText = function (element, panelName, animationSrc, animationName, animationControls, currentElementName, renderMaxTime, thread) {
var HTMLPanel = panel.getHTMLElement();
var holderDiv = null;
var hsize = panel.getHeight();
var wsize = panel.getWidth();
if (elementInfomediaType != 'hotText' || elementInfosrc != animationSrc) {
holderDiv = simDocument().getElementById('holderAnimation' + simID);
if (holderDiv && holderDiv.media != 'hotText') {
var parent = holderDiv.parentNode;
if (parent.id == 'outerDiv') HTMLPanel.removeChild(parent);
else HTMLPanel.removeChild(holderDiv);
}
holderDiv = simDocument().createElement('div');
holderDiv.id = 'holderAnimation' + simID;
holderDiv.style.textAlign = 'left';
holderDiv.name = 'holderAnimation' + simID;
holderDiv.elementName = animationName;
holderDiv.setAttribute('class', 'holderAnimation');
var contentDiv = simDocument().createElement('div');
contentDiv.id = 'hotTextContentDiv';
contentDiv.style.textAlign = 'left';
contentDiv.style.padding = '0px';
holderDiv.appendChild(contentDiv);
HTMLPanel.appendChild(holderDiv);
elementInfomediaType = 'animation';
elementInfoid = holderDiv.id;
}
elementInfosrc = animationSrc;
contentDiv.innerHTML = animationSrc;
if (renderMaxTime != undefined && renderMaxTime != null && renderMaxTime >= 0) {
setTimeout(function () { handleTimeout(element); }, renderMaxTime);
}
currenAnimationName = animationName;
var hotText = new Simulator.Animation.HotTextShell(sim);
animationSet.setCurrentAnimation(hotText);
debug('AnimationSet.CurrentAnimation = ' + animationSet.getCurrentAnimation());
debug('Initializing the HotTextShell: inlinDataID = ' + element.getInlineDataID() + ', holderDiv.id = ' + holderDiv.id + ', outputOnRequest = ' + animationSet.getOutputOnRequest());
var parameters = {
callback: animationSet.animationMediaOutput,
inlineDataID: element.getInlineDataID(),
containerID: holderDiv.id,
behavior: element.getBehavior(),
outputOnReq: animationSet.getOutputOnRequest()
};
hotText.initialize(simID, parameters);
sendDataToAnimationElement(element, false);
};
this.resizeAnimationElements = function (panel, zoom) {
var HTMLPanel = panel.getHTMLElement();
if (zoom) {
var flashObjectArray = HTMLPanel.getElementsByTagName('object');
if (flashObjectArray && flashObjectArray.length == 1) {
var flashObj = flashObjectArray[0];
flashObj.animationResize(parseInt(flashObj.style.width), parseInt(flashObj.style.height));
}
}
else {
var hsize = panel.getHeight();
var wsize = panel.getWidth();
var flashObjectArray = HTMLPanel.getElementsByTagName('object');
if (flashObjectArray && flashObjectArray.length == 1) {
var flashObj = flashObjectArray[0];
var dimensions = util().setDimensions(hsize, wsize, parseInt(panel.getOriginalHeight()), parseInt(panel.getOriginalWidth()), 10              );
if (dimensions.height > 0 && dimensions.width > 0) {
hsize = dimensions.height;
wsize = dimensions.width;
}
flashObj.width = wsize;
flashObj.height = hsize;
flashObj.setAttribute('originalwidth', wsize);
flashObj.setAttribute('originalheight', hsize);
flashObj.style.width = wsize + 'px';
flashObj.style.height = hsize + 'px';
flashObj.animationResize(wsize, hsize);
}
var imgArray = HTMLPanel.getElementsByTagName('img');
if (imgArray && imgArray.length == 1) {
var image = imgArray[0];
debug('Image height = ' + image.height + ', width = ' + image.width);
var dimensions = util().setDimensions(hsize, wsize, image.height, image.width, 10              );
if (dimensions.height > 0 && dimensions.width > 0) {
image.height = dimensions.height;
image.width = dimensions.width;
debug('Image resize with padding to height = ' + image.height + ', width = ' + image.width);
}
}
}
};
this.renderFlash = function (element, panelName, flashSrc, flashName, flashControls, currentElementName, renderMaxTime, thread) {
var HTMLPanel = panel.getHTMLElement();
if (elementInfomediaType != 'flash' || elementInfosrc != flashSrc) {
var expressFlashInstall = false;
var animationSet = thread.getAnimationSet();
var flashvars = {
simID: simID,
simURL: escape(flashSrc),
simCallback: (window.document == simDocument()) ? Simulator.Constants.SIM_CALLBACK : 'window.parent.' + Simulator.Constants.SIM_CALLBACK,
simBehavior: element.getBehavior()
};
debug("flashvars.simBehavior = " + flashvars.simBehavior);
var params = {
wmode: 'opaque',
allowscriptaccess: 'always',
swliveconnect: 'true'
};
var attributes = {};
attributes.name = flashName;
attributes.media = 'flashAnimation';
attributes.styleclass = 'centeredAnimation';
var flashVersion = '9';
var hsize, wsize;
if ((panel.getOriginalHeight() == null) || (panel.getOriginalHeight() <= 0)) {
hsize = panel.getHeight() - 10;
} else {
hsize = panel.getOriginalHeight() - 10;
}
if ((panel.getOriginalWidth() == null) || (panel.getOriginalWidth() <= 0)) {
wsize = panel.getWidth() - 10;
} else {
wsize = panel.getOriginalWidth() - 10;
}
var holderDiv = simDocument().getElementById('holderAnimation' + simID);
if (holderDiv && holderDiv.media != 'flashAnimation') {
var parent = holderDiv.parentNode;
if (parent.id == 'outerDiv') HTMLPanel.removeChild(parent);
else HTMLPanel.removeChild(holderDiv);
}
holderDiv = simDocument().createElement('div');
holderDiv.id = 'holderAnimation' + simID;
holderDiv.name = 'holderAnimation' + simID;
holderDiv.elementName = flashName;
holderDiv.setAttribute('class', 'holderAnimation');
holderDiv.innerHTML = '<h1>Alternative content</h1>';
HTMLPanel.appendChild(holderDiv);
if(sim.getAccessibilityIFActive()) {
var altText = element.getAltText();
var altTextSpan = simDocument().createElement('span');
altTextSpan.style.position='absolute';
altTextSpan.style.top = '50%';
holderDiv.style.verticalAlign='middle';
holderDiv.style.horizontalAlign='center';
altTextSpan.style.fontSize = 'xx-large';
altTextSpan.innerHTML = altText;
holderDiv.innerHTML = '';
holderDiv.appendChild(altTextSpan);
debug('renderFlash simulating time of animation execution since accessibilityIF is true');
setTimeout(simulateAnimationExecutionTime, 5000);
return;
}
elementInfomediaType = 'flash';
elementInfoid = holderDiv.id;
elementInfosrc = flashSrc;
currentAnimationElement = element;
currenAnimationName = flashName;
swfobject.switchOffAutoHideShow();
swfobject.embedSWF(sim.getAnimationShellPath(), holderDiv.id, wsize, hsize, flashVersion, expressFlashInstall, flashvars, params, attributes, simDocument(), flashEmbedSuccessCallback);
if (renderMaxTime != undefined && renderMaxTime != null && renderMaxTime >= 0) {
setTimeout(function () { handleTimeout(element); }, renderMaxTime);
}
}
else
sendDataToAnimationElement(element, false);
};
this.renderVideo = function (element, panelName, videoSrc, currentElementName, renderMaxTime, thread) {
var HTMLAnimation = simDocument().getElementById(currentElementName);
var vid = simDocument().createElement('video');
vid.setAttribute('type', 'application/x-shockwave-flash');
vid.setAttribute('width', panel.getWidth(true) - 2);
vid.controls = 'true';
vid.setAttribute('src', videoSrc);
vid.object = simDocument().createElement('object');
vid.object.data = 'flvplayer.swf';
vid.object.media = 'videoAnimation';
vid.object.type = 'application/x-shockwave-flash';
vid.object.param = simDocument().createElement('param');
vid.object.param.value = 'flvplayer.swf';
vid.object.param.name = 'movie';
var div = simDocument().createElement('div');
div.setAttribute('class', 'holderAnimation');
var span = simDocument().createElement('span');
span.appendChild(vid);
div.appendChild(span);
panel.replaceChild(div, HTMLAnimation);
};
function simulateAnimationExecutionTime(renderer) {
debug('Posting animationThreadFinished event since accessibilityIF is true');
eventMgr().postEvent(new Simulator.Event(this, 'info', 'animationThreadFinished'));
}
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Animation.AnimationRenderer.prototype = new Simulator.SimItem();
Simulator.Animation.AnimationRenderer.prototype.constructor = Simulator.Animation.AnimationRenderer;

// FILE: HTML5Shell.js (dee9b115) 7/23/2014 4:30:37 PM

Simulator.Animation.HTML5Shell = function(sim, theSimID) {
var source = 'HTML5Shell';
var simURL = null;
var iFrameID = null;
var iFrame = null;
var behavior = null;
var simCallback = null;
var simHeight = null;
var simWidth = null;
var simID = theSimID;
var outputOnReq = null;
var maxSRTimeouts = 2;
var statusReqTimer = null;
var statusReturnTimer = null;
var statusReportInterval = 10 * 1000;
var statusReturnInterval = 1 * 1000;
var animationFinishedDelay = 1000;
var dbg = function() {
return sim.getDebug();
};
var utils = function() {
return sim.getUtils();
};
var simDocument = function() {
return sim.getSimDocument();
};
this.initialize = function(theSimID, parameters) {
if (!simIDIsValid(theSimID)) {
dbg().logError(source,
'initialize message with simID = ' + simulationID
+ ' sent to HTML5Shell with simID = ' + simID);
return Simulator.Constants.FAILURE;
} else {
iFrameID = parameters.containerID;
iFrame = simDocument().getElementById(iFrameID);
if (!iFrame) {
dbg().logError(source, 'Could not get iFrame from id ' + iframeID);
return Simulator.Constants.FAILURE;
} else {
simURL = iFrame.src;
behavior = parameters.behavior;
simWidth = iFrame.width;
simHeight = iFrame.height;
simCallback = parameters.callback;
outputOnReq = parameters.outputOnReq;
debug('In initialize');
simWidth1 = simWidth;
if (simID === "" && simURL === "") {
dbg().logError(source, "Simulation does not exist");
return Simulator.Constants.FAILURE;
} else {
var animationParams = {
behavior : behavior,
callback : this.fromAnimationInterface,
simHeight: simHeight,
simWidth: simWidth
};
debug('animationParams.behavior = '+ animationParams.behavior);
debug('animationParams.simHeight = '+ animationParams.simHeight);
debug('animationParams.simWidth = '+ animationParams.simWidth);
debug('Calling init in the animation interface');
var status = iFrame.contentWindow.init(this, animationParams);
if (status === Simulator.Constants.SUCCESS) {
debug('Received SUCCESS from init function in animation. Link with HTML Animation established');
status = Simulator.Constants.ANIMATION_LOADED;
if (behavior !== Simulator.Constants.INTERACTIVE_ANIMATION) startStatusTimer();
} else {
dbg().logFatalError(source,
'animation interface returned failure. Link with HTML Animation NOT established');
return Simulator.Constants.FAILURE;
}
}
return Simulator.Constants.ANIMATION_LOADED;
}
}
};
this.fromAnimationInterface = function(type, data) {
debug("HTML5Shell.fromAnimationInterface(), type = " + type);
var formattedOutput = null;
resetStatusTimer();
switch (type) {
case Simulator.Constants.ANIMATION_PROPERTIES:
formattedOutput = formatOutput(data);
sendOutputToSimulator(type, formattedOutput);
break;
case Simulator.Constants.ANIMATION_REPORTING:
if(data === Simulator.Constants.ANIMATION_ALIVE) debug('Received "I am alive" message from animation at ' + utils().getElapsedTime());
else debug('Received "' + data + '" message from animation at ' + utils().getElapsedTime());
break;
case Simulator.Constants.PARAM_OUTPUT:
formattedOutput = formatOutput(data);
sendOutputToSimulator(type, formattedOutput);
break;
case Simulator.Constants.PARAM_ERROR:
case Simulator.Constants.PARAM_INFO:
if ((data === Simulator.Constants.ANIMATION_FINISHED) && (behavior != Simulator.Constants.INTERACTIVE_ANIMATION)) {
processCommand(simID, Simulator.Constants.OUTPUT_REQ_CMD);
}
sendOutputToSimulator(type, data);
break;
default:
debug("ERROR - Unrecognized type, '" + type + "' of messsage received from animationInterface.");
}
};
this.animationInput = function(simulationID, type, input) {
debug("HTML5Shell.animationInput(): type = " + type + ", input = "
+ input);
var inputs = null;
if (!simIDIsValid(theSimID)) {
return Simulator.Constants.FAILURE;
} else {
debug("Received message from simulator: simID = " + simID
+ ", type = " + type + ", input = " + input);
switch (type) {
case Simulator.Constants.PARAM_COMMAND:
processCommand(simulationID, input);
break;
case Simulator.Constants.PARAM_INFO:
break;
case Simulator.Constants.PARAM_INPUT:
if (input === null || input === "") {
debug("Inputs not provided");
sendInfo(Simulator.Constants.ANIMATION_UNABLE_TO_START);
} else {
inputs = parseInputs(input);
if (iFrame.contentWindow) {
iFrame.contentWindow.updateInputs(inputs);
}
}
break;
case Simulator.Constants.PARAM_UPDATE:
if (!checkID(simulationID)) {
dbg().logError(source, 'simID does not match!');
return;
} else if (input === null || input === "") {
debug("Inputs not provided");
sendInfo(Simulator.Constants.ANIMATION_UNABLE_TO_START);
} else {
inputs = parseInputs(input);
iFrame.contentWindow.updateInputs(inputs);
iFrame.contentWindow.playAnimation();
if (behavior === Simulator.Constants.INTERACTIVE_ANIMATION) {
setTimeout(function() {
sendInfo(Simulator.Constants.ANIMATION_FINISHED);
}, animationFinishedDelay);
}
startStatusTimer();
}
break;
default:
debug("Inputs not provided");
}
}
};
var processCommand = function(simulationID, cmd) {
debug("Received command from simulator: " + cmd);
switch (cmd) {
case Simulator.Constants.GET_ANIMATION_PROPERTIES:
var properties = iFrame.contentWindow.getProperties();
var output = formatOutput(properties);
sendOutputToSimulator(Simulator.Constants.ANIMATION_PROPERTIES, output);
break;
case Simulator.Constants.PLAY_CMD:
if (iFrame.contentWindow) {
iFrame.contentWindow.playAnimation();
if (behavior === Simulator.Constants.INTERACTIVE_ANIMATION) {
setTimeout(function () {
sendInfo(Simulator.Constants.ANIMATION_FINISHED);
}, animationFinishedDelay);
}
startStatusTimer();
}
break;
case Simulator.Constants.STOP_CMD:
break;
case Simulator.Constants.REWIND_CMD:
rewind();
break;
case Simulator.Constants.SET_ID_CMD:
this.simID = simulationID;
break;
case Simulator.Constants.RESTART_CMD:
reStart();
break;
case Simulator.Constants.OUTPUT_REQ_CMD:
var outputs = iFrame.contentWindow.getOutputs();
debug("HTML5Shell.processCommand() with Simulator.Constants.OUTPUT_REQ_CMD, outputs = "
+ outputs);
var data = formatOutput(outputs);
debug("Received data from formatOutput: " + data);
sendOutputToSimulator(Simulator.Constants.PARAM_OUTPUT, data);
break;
case Simulator.Constants.ANIMATION_REPORT_STATUS:
sendStatusRequest();
break;
default:
dbg().logError(source, "Unknown command passed to animation");
}
};
var parseInputs = function(input) {
console.log("parseInputs(): " + input);
inputArray = [];
input = removeBrackets(input);
input = removeSemi(input);
var elements = input.split(Simulator.Constants.ITERATION_DELIMITTER);
for ( var j = 0; j < elements.length; j++) {
var pairs = String(elements[j]).split(
Simulator.Constants.PAIR_DELIMITTER);
for ( var i = 0; i < pairs.length; i++) {
parts = String(pairs[i]).split(
Simulator.Constants.KEY_VALUE_DELIMITTER);
parts[Simulator.Constants.INPUT_NAME_PART] = removeQuotes(String(
parts[Simulator.Constants.INPUT_NAME_PART]).trim());
parts[Simulator.Constants.INPUT_VALUE_PART] = removeQuotes(String(
parts[Simulator.Constants.INPUT_VALUE_PART]).trim());
var values = String(parts[Simulator.Constants.INPUT_VALUE_PART])
.split(Simulator.Constants.MULTIPLE_VALUE_DELIMITTER);
parts[Simulator.Constants.INPUT_VALUE_PART] = values;
debug("Input #" + (j + 1) + ", '"
+ parts[Simulator.Constants.INPUT_NAME_PART] + "' = "
+ parts[Simulator.Constants.INPUT_VALUE_PART] + ";");
inputArray[parts[Simulator.Constants.INPUT_NAME_PART]] = parts[Simulator.Constants.INPUT_VALUE_PART];
}
}
return inputArray;
};
var rewind = function() {
iFrame.contentWindow.gotoAndStop(Simulator.Constants.START_FRAME);
};
var reStart = function() {
iFrame.contentWindow.gotoAndStop(Simulator.Constants.START_FRAME);
iFrame.contentWindow.playAnimation();
};
var formatOutput = function(dataArray) {
var str = "";
for (key in dataArray) {
if (str)
str += Simulator.Constants.PAIR_DELIMITTER;
str += key + Simulator.Constants.KEY_VALUE_DELIMITTER + dataArray[key];
}
return str;
};
var sendOutput = function() {
var data = formatOutput();
sendOutputToSimulator(Simulator.Constants.PARAM_OUTPUT, data);
};
var sendInfo = function(info) {
sendOutputToSimulator(Simulator.Constants.PARAM_INFO, info);
};
var sendError = function(info) {
sendOutputToSimulator(Simulator.Constants.PARAM_ERROR, info);
};
var sendOutputToSimulator = function(type, output) {
debug("Sending simulator " + type + " message with data =  " + output.toString());
simCallback(this.simID, type, output);
};
var simIDIsValid = function(simulationID) {
if (simID === simulationID)
return true;
else
return false;
};
var removeBrackets = function(str) {
var rex = /[\[\]]*/gim;
return str.replace(rex, '');
};
var removeSemi = function(str) {
var rex = /[;]$/im;
return str.replace(rex, '');
};
var removeQuotes = function(str) {
var rex = /["]*/gim;
return str.replace(rex, '');
};
var startStatusTimer = function() {
if (statusReqTimer)
clearTimeout(statusReqTimer);
statusReqTimer = setTimeout(sendStatusRequest, statusReportInterval);
utils().markTime();
if (!statusReqTimer) dbg().logError(source,
'Could not start statusReqTimer. No "alive" messages will be sent to the animation.');
};
var resetStatusTimer = function() {
debug('Status timers reset at ' + utils().getElapsedTime());
if (statusReturnTimer)
clearTimeout(statusReturnTimer);
if (statusReqTimer)
clearTimeout(statusReqTimer);
startStatusTimer();
};
var sendStatusRequest = function() {
utils().markTime();
srTimeouts++;
statusReturnTimer = setTimeout(statusReportTimeout,
statusReturnInterval);
debug('Sending number ' + srTimeouts + ' status request to animation.');
if (iFrame.contentWindow) {
var result = iFrame.contentWindow.statusRequest();
if (result === Simulator.Constants.ANIMATION_ALIVE) {
resetStatusTimer();
}
}
};
var srTimeouts = 0;
statusReportTimeout = function() {
debug('Status report waiting period ' + srTimeouts + ' timed out at ' + utils().getElapsedTime());
if (srTimeouts === maxSRTimeouts) {
debug('Sending "animationUnresponsive" message to simulator');
sendOutputToSimulator(Simulator.Constants.PARAM_ERROR,
Simulator.Constants.ANIMATION_UNRESPONSIVE);
srTimeouts = 0;
}
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};

// FILE: HotTextShell2.js (eb5e34f2) 3/7/2014 11:24:14 AM

Simulator.Animation.HotTextShell = function (sim) {
var interactions = [];
var dictionary = new Object();
var source = 'HotTextShell';
var inlineDataID = null;
var dbg = function () {
return sim.getDebug();
};
var utils = function () {
return sim.getUtils();
};
var simDocument = function () {
return sim.getSimDocument();
};
function generateOutputStr(simID) {
var output = '';
var semicolon = '\\0x1D\\'; //to separate iterations
var comma = '\\0x1E\\'; //to separate data groups
var colon = '\\0x1F\\'; //to separate a key and value in a key-value group
var formattedResponse = '';
var rawResponse = '';
var responseText = '';
var interactionType = '';
var itemId = inlineDataID;
var responseXMLString, interaction, returnString;
if (interactions.length > 0) {
for (var j = 0; j < interactions.length; j++) {
interaction = interactions[j];
rawResponse = interaction.getResponse();
if (interaction instanceof TDS.DDInteraction) {
if (interactionType)
interactionType += '|' + 'draggable';
else
interactionType += 'draggable';
}
else if (interaction instanceof TDS.SelectInteraction) {
if (interactionType)
interactionType += '|' + 'selectable';
else
interactionType += 'selectable';
var selectionChoices = interaction.getSelectedChoices();
var selectedChoicesLength = 0;
if (selectionChoices)
selectedChoicesLength = selectionChoices.length;
for (var i = 0; i < selectedChoicesLength; i++) {
if (i == 0) {
formattedResponse = selectionChoices[i].getIdentifier();
responseText = selectionChoices[i].getElement().innerHTML.replace(/<[^>]*>/gi, '').replace(/&.{4};/gi, '');
}
else {
formattedResponse += '|' + selectionChoices[i].getIdentifier();
responseText += '|' + selectionChoices[i].getElement().innerHTML.replace(/<[^>]*>/gi, '').replace(/&.{4};/gi, '');
}
}
}
}
var xml = [];
xml.push('<interactions>');
xml.push(rawResponse);
xml.push('</interactions>');
rawResponse = xml.join('');
output += 'itemId' + colon + inlineDataID + comma;
output += 'interactionType' + colon + interactionType + comma;
output += 'formattedResponse' + colon + formattedResponse + comma;
output += 'rawHTResponseRC' + colon + rawResponse + comma;
output += 'responseText' + colon + responseText;
}
return output;
}
this.initialize = function (simID, parameters) {
inlineDataID = parameters.inlineDataID;
var itemContainer = simDocument().getElementById(parameters.containerID);
var id_postfix = '-interaction-' + simID;
var ddInteraction = new TDS.DDInteraction('dd' + id_postfix);
ddInteraction.load(itemContainer);
if (ddInteraction.getDraggables().length > 0) {
interactions.push(ddInteraction);
}
var selectInteraction = new TDS.SelectInteraction('select' + id_postfix);
selectInteraction.load(itemContainer);
var numChoices = selectInteraction.getChoices().length;
if (numChoices > 0) {
interactions.push(selectInteraction);
if (!parameters.outputOnReq)
for (var i = 0; i < numChoices; i++) {
selectInteraction.getChoices()[i].subscribe('selectEvent', function () { sim.getAnimationSet().animationMediaOutput(simID, 'output', generateOutputStr(simID)) });
selectInteraction.getChoices()[i].subscribe('deselectEvent', function () { sim.getAnimationSet().animationMediaOutput(simID, 'output', generateOutputStr(simID)) });
}
}
if (interactions.length) {
sim.getAnimationSet().animationMediaOutput(simID, 'info', 'animationLoaded');
}
else {
sim.getAnimationSet().animationMediaOutput(simID, 'info', 'animationError');
}
}
this.animationInput = function (simID, type, content) {
if (type == 'command') {
switch (content) {
case 'outputRequest':
{
var output = generateOutputStr(simID);
sim.getAnimationSet().animationMediaOutput(simID, 'output', output);
break;
}
case 'play':
{
sim.getAnimationSet().animationMediaOutput(simID, 'info', 'animationStarted');
sim.getAnimationSet().animationMediaOutput(simID, 'info', 'animationFinished');
break;
}
default:
break;
}
}
}
this.animationIONames = function () {
return 'output' + Simulator.Constants.KEY_VALUE_DELIMITTER + 'itemId' + Simulator.Constants.MULTIPLE_VALUE_DELIMITTER + 'interactionType' + Simulator.Constants.MULTIPLE_VALUE_DELIMITTER + 'formattedResponse' + Simulator.Constants.MULTIPLE_VALUE_DELIMITTER + 'rawHTResponseRC' + Simulator.Constants.MULTIPLE_VALUE_DELIMITTER + 'responseText' + Simulator.Constants.PAIR_DELIMITTER;
}
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
}

// FILE: AnimationSet2.js (ed489da9) 3/7/2014 11:24:14 AM

Simulator.Animation.AnimationSet = function (sim, panel) {
Simulator.SimElement.call(this, sim);
this.setEname('AnimationSet');
var source = 'AnimationSet';
var instance = this;
var setElements = [];
var setThreads = [];
var poster = [];
var inputSource = [];
var outputs = [];
var outputOnRequest = false;
var prevInputs = [];
var currentInputs = [];
var lastThreadExecuted = null;
var currentThread = null;
var currentAnimation = null;
var currentAnimationState = [];
var scoreable = true;
var key = null;
var renderer = null;
var animationBehavior = 'timeBased';
var instance = this;
var animationLoaded = false;
var util = function () { return sim.getUtils(); };
var dbg = function () { return sim.getDebug(); };
var whiteboard = function () { return sim.getWhiteboard(); };
var eventMgr = function () { return sim.getEventManager(); };
var scoringTable = function () { return sim.getScoringTable(); };
var simMgr = function () { return sim.getSimulationManager(); };
var simDocument = function() { return sim.getSimDocument(); };
function registerEvents(instance) {
eventMgr().registerEvent(new Simulator.Event(instance, 'info', 'animationThreadFinished'));
eventMgr().registerEvent(new Simulator.Event(instance, 'info', 'animationFinished'));
eventMgr().registerEvent(new Simulator.Event(instance, 'info', 'animationStarted'));
eventMgr().registerEvent(new Simulator.Event(instance, 'info', 'animationError'));
}
this.getRenderer = function () {
return renderer;
};
this.getKey = function () {
return key;
};
this.getPrevInputs = function () {
return prevInputs;
};
var inputSource = [];
inputSource[0] = 'evaluator';
this.getInputSource = function () {
return inputSource;
};
this.setInputSource = function (newInputSource) {
var parts = [];
inputSource.splice(0, 1);
parts = newInputSource.split(',');
for (var i = 0; i < parts.length; i++) {
parts[i] = parts[i].trim();
if (parts[i] == "evaluator" || parts[i] == "animation") {
if (!util().elementInArray(inputSource, parts[i])) inputSource.push(parts[i]);
}
else dgb().logFatalError(source, 'Unknow input source "' + parts[i] + '" passed to AnimationSet.setInputSource');
}
};
this.getCurrentAnimation = function () {
return currentAnimation;
};
this.setCurrentAnimation = function (animation) {
currentAnimation = animation;
};
this.getCurrentInputs = function() {
return currentInputs;
};
this.getAnimationBehavior = function () {
return animationBehavior;
};
this.setAnimationBehavior = function (newBehavior) {
animationBehavior = newBehavior;
return this;
};
this.addAnimationElement = function (element) {
setElements.push(element);
return this;
};
this.getAnimationElement = function (id) {
for (var i = 0; i < setElements.length; i++) {
if (setElements[i].getName() == id)
return setElements[i];
}
return null;
};
this.addThread = function (aThread) {
setThreads.push(aThread);
};
this.getThreadFromName = function (name) {
for (var i = 0; i < setThreads.length; i++) {
if (setThreads[i].getName() == name) return setThreads[i];
}
return null;
};
this.getFirstAnimationThread = function() {
return setThreads[0];
};
this.getPosterName = function () {
return poster['name'] + sim.getSimID();
};
this.getPosterSrc = function () {
return poster['image'];
};
this.getPosterShow = function () {
return poster['show'];
};
this.getInputSource = function () {
return inputSource;
};
this.setOutputs = function (newOutputs) {
outputs = newOutputs.split(",");
if(outputs == "inputs") scoringTable().cloneInputsForOutputs();
else if(scoreable) {
for(var i = 0; i < outputs.length; i++) {
if(outputs[i] != "none") scoringTable().addElement(outputs[i], "output");
}
}
};
this.getOutputs = function () {
return outputs;
};
this.setScoreable = function (newScoreable) {
scoreable = newScoreable == 'yes' ? true : false;
return this;
};
this.getScoreable = function () {
return scoreable;
};
this.setPoster = function (posterAttributes) {
for (var i = 0; i < posterAttributes.length; i++) {
if (posterAttributes[i].nodeName == 'image') {
poster[posterAttributes[i].nodeName] = posterAttributes[i].nodeValue;
}
else poster[posterAttributes[i].nodeName] = posterAttributes[i].nodeValue;
}
};
this.setOutputOnRequest = function (newOutputOnRequest) {
outputOnRequest = newOutputOnRequest == 'yes' ? true : false;
return this;
};
this.getOutputOnRequest = function () {
return outputOnRequest;
};
this.recordOutputs = function () {
var parts = [];
var data = whiteboard().getCategory('animationOutput')['output'];
if (data != null) {
data = data.split(Simulator.Constants.PAIR_DELIMITTER);
if (data != undefined && data != null && data != '') for (var i = 0; i < outputs.length; i++) {
if (outputs[i] == 'none') break;
else if (scoreable) {
for (var j = 0; j < data.length; j++) {
parts = data[j].split(Simulator.Constants.KEY_VALUE_DELIMITTER);
parts[0] = parts[0].trim();
if (parts[1]) parts[1] = parts[1].trim();
if (parts[0] == outputs[i]) scoringTable().setValue(parts[0], simMgr().getTrialNum() - 1, parts[1]);
}
}
}
}
};
this.selectThread = function (noStart) {
this.setCurrentThread(null);
for (var i = 0; i < setThreads.length; i++) {
if (setThreads[i].isSelected()) {
this.setCurrentThread(setThreads[i]);
if (!noStart) setThreads[i].startSimulation();
return true;
}
}
return false;
};
this.handleEvent = function (event) {
var newEvent = undefined;
switch (event.type) {
case 'info':
switch (event.context) {
case 'animationThreadFinished':
case 'animationFinished':
lastThreadExecuted = this.getCurrentThread();
if (poster['show'] == 'after' || poster['show'] == 'both') renderer.renderImage(this, 'animationPanel', this.getPosterSrc(), this.getPosterName(), -1, null);
break;
case 'animationStarted':
break;
case 'inputAvailable':
var result = this.storeInputs(true);
if (result != false) {
simMgr().setAnimationCompleteWithoutOutput(event.completeWithoutOutput);
this.sendDataToAnimation();
}
break;
case 'animationError':
dbg().logError(source, event.data);
break;
case 'outputAvailable':
if (!simMgr().trialLimitReached()) {
var result = this.storeInputs(true);
if (result != false) {
if (this.getCurrentThread() == null) {
this.selectThread();
} else {
var nextElement = this.getCurrentThread().renderNextThreadElement(false);
if (!nextElement) this.selectThread();
}
}
}
break;
default:
dbg().logFatalError(source, 'AnimationSet - Unknown command name: ' + event.context + ' received by ' + this.getName());
break;
}
break;
case 'command':
switch (event.context) {
case 'load':
if(!animationLoaded) {
if (poster['show'] == 'before' || poster['show'] == 'both')
renderer.renderImage(this, 'animationPanel', this.getPosterSrc(), this.getPosterName(), -1, null);
else if (util().assocArrayIsEmpty(poster)) eventMgr().postEvent(new Simulator.Event(instance, "info", "allMediaLoaded"));
animationLoaded = true;
}
break;
case 'startAnimation':
this.storeInputs(true);
if (this.getCurrentThread() == null) {
this.selectThread();
} else {
var nextElement = this.getCurrentThread().renderNextThreadElement(true);
if (nextElement) this.selectThread();
}
break;
case 'outputReq':
if (currentAnimation) {
currentAnimation.animationInput(sim.getSimID(), 'command', 'outputRequest');
}
break;
case 'startTrial':
if (!simMgr().trialLimitReached()) {
this.storeInputs(true);
simMgr().setAnimationCompleteWithoutOutput(event.completeWithoutOutput);
if (this.getCurrentThread() == null) {
this.selectThread();
} else {
var nextElement = this.getCurrentThread().renderNextThreadElement(false);
if (!nextElement) this.selectThread();
}
}
break;
default:
dbg().logFatalError(source, 'AnimationSet - Unknown command name: ' + event.context + ' received by ' + this.getName());
break;
}
break;
default:
dbg().logFatalError(source, 'AnimationSet ' + this.getName() + ': Unhandled event type received: ' + event.inspect());
return;
}
if (newEvent != undefined && newEvent != null) {
newEvent.postEvent();
}
};
this.sendDataToAnimation = function () {
debug('in sendDataToAnimation of AnimationSet');
var thread = this.getCurrentThread();
if (!thread) {
thread = lastThreadExecuted;
if (!thread) {
if (!this.selectThread()) dbg().logFatalError(source, 'Could not select a thread in sendDataToAnimation of AnimationSet.');
return;
} else return;
}
var element = thread.getCurrentElement();
if (!element) element = thread.getLastExecutedAnimationElement();
debug('In sendDataToAnimation - element = ' + (element === null) ? 'null' : element.getName());
if (element) {
renderer.sendDataToAnimation(element);
} else dbg().logFatalError(source, 'Could not find CurrentElement or LastExecutedAnimationElement in sendDataToAnimation of AnimationThread');
};
this.getSourceName = function() {
return source;
};
this.inspect = function (embedded, force) {
var buff = [];
var sep = '\n\n';
if (!embedded)
buff.push('Inspecting AnimationSet');
buff.push(sep);
for (var i = 0; i < setElements.length; i++) {
buff.push('[');
buff.push(i);
buff.push('] = ');
buff.push(setElements[i].inspect(true));
buff.push(sep);
}
if (!embedded)
buff.push('End of AnimationSet inspection');
buff.push(sep);
if (!embedded) (force == null) ? debug(buff.join('')) : debugf(buff.join(''));
else return buff.join('');
};
this.getCurrentAnimationState = function () {
if (lastThreadExecuted) {
currentAnimationState['lastThreadExecutedName'] = lastThreadExecuted.getName();
currentAnimationState['currentThreadElementIndex'] = lastThreadExecuted.getCurrentThreadElementIndex();
currentAnimationState['animationInputs'] = currentInputs.join(',');
currentAnimationState['animationOutputs'] = this.getOutputs().join(',');
return currentAnimationState;
} else return [];
};
this.setCurrentAnimationState = function (stateArray) {
lastThreadExecuted = this.getThreadFromName(stateArray['lastThreadExecutedName']);
lastThreadExecuted.setCurrentThreadElementIndex(stateArray['currentThreadElementIndex']);
var parts = stateArray['animationInputs'].split(',');
for (var p in parts) currentInputs[p] = parts[p];
this.setOutputs(stateArray['animationOutputs']);
if (simMgr().getRestoreAnimationOnReload()) lastThreadExecuted.startSimulation();
};
this.storeInputs = function (backupInputs) {
var inputs = whiteboard().getCategory('animationInput');
if (inputs != null) {
if (Object.size(inputs) > 0) {
if (backupInputs) this.setPrevInputs();
for (var s in inputs) {
currentInputs[s] = inputs[s];
}
}
}
};
this.setPrevInputs = function () {
for (var p in currentInputs) {
prevInputs[p] = currentInputs[p];
}
};
this.setCurrentThread = function (thread) {
lastThreadExecuted = currentThread;
currentThread = thread;
if (currentThread !== null) {
debug('In setCurrentThread - currentThread = "' + currentThread.getName() + '", so setting currentElement to null');
currentThread.setCurrentElement(null);
} else dbg().logWarning(source, 'In setCurrentThread - currentThread = null');
};
this.getCurrentThread = function (thread) {
return currentThread;
};
function renderNextElement(instance) {
var anEvent = null;
if (currentThread != null && currentThread != undefined) {
var element = currentThread.renderNextThreadElement();
if (element == null) {
anEvent = new Simulator.Event(instance, "info", "animationThreadFinished");
eventMgr().postEvent(anEvent);
}
} else {
anEvent = new Simulator.Event(instance, "info", "animationThreadFinished");
eventMgr().postEvent(anEvent);
}
}
this.animationMediaOutput = function (theSimID, type, data) {
if (sim.getSimID() != theSimID) {
dbg().logWarning(source, 'SimID from animation: ' + theSimID + ' does not match this simulator\'s ID: ' + sim.getSimID());
}
var set = null;
if (type != 'debug' && type != Simulator.Constants.PARAM_DEBUG_OUTPUT)
debug('Received ' + type + ' output from the animation with data "' + data + '"');
switch (type) {
case 'info':
switch (data) {
case Simulator.Constants.ANIMATION_THREAD_FINISHED:
case Simulator.Constants.ANIMATION_FINISHED:
var currentElement = currentThread.getCurrentElement();
debug('In animationMediaOutput - currentElement = ' + ((currentElement === null) ? 'null' : currentElement.getName()));
if(currentElement.getBehavior() != Simulator.Constants.INTERACTIVE_ANIMATION) {
if (instance.getOutputs() != '') instance.recordOutputs();
}
renderNextElement(instance);
break;
case Simulator.Constants.ANIMATION_STARTED:
break;
case Simulator.Constants.ANIMATION_ABORTED:
case Simulator.Constants.ANIMATION_UNABLE_TO_START:
case 'newTrial':
eventMgr().postEvent(new Simulator.Event(set, 'command', 'newTrial'));
break;
default:
}
break;
case Simulator.Constants.PARAM_OUTPUT:
case Simulator.Constants.PARAM_DATA:
whiteboard().setItem('animationOutput', 'output', data, key);
instance.recordOutputs();
eventMgr().postEvent(new Simulator.Event(instance, 'info', 'animationOutputAvailable'));
break;
case Simulator.Constants.PARAM_DEBUG_OUTPUT:
break;
case Simulator.Constants.ANIMATION_ERROR:
eventMgr().postEvent(new Simulator.Event(set, 'animationError', data));
break;
default:
}
};
this.setAttributes = function (attr, node) {
var attr = util().getAttributes(node);
Simulator.Animation.AnimationSet.prototype.setAttributes.call(this, attr, node);
for (var i in attr) {
switch (i) {
case 'poster':
this.setPoster(attr[i]);
break;
case 'scoreable':
this.setScoreable(attr[i]);
break;
case 'outputs':
this.setOutputs(attr[i]);
break;
case 'inputSource':
this.setInputSource(attr[i]);
break;
case 'outputOnRequest':
this.setOutputOnRequest(attr[i]);
break;
}
}
};
if (sim) {
key = whiteboard().addItem('animationOutput', 'output');
inputSource[0] = 'evaluator';
registerEvents(instance);
renderer = new Simulator.Animation.AnimationRenderer(sim, panel, this);
}
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Animation.AnimationSet.prototype = new Simulator.SimElement();
Simulator.Animation.AnimationSet.parent = Simulator.Simulator;
Simulator.Animation.AnimationSet.prototype.constructor = Simulator.Animation.AnimationSet;

// FILE: AnimationThread2.js (7e76a405) 3/7/2014 11:24:14 AM

Simulator.Animation.AnimationThread = function (sim, panel, section, animationSet) {
Simulator.SimElement.call(this);
var source = 'AnimationThread';
var theSet = animationSet;
var threadElements = [];
var currentThreadElementIndex = 0;
var selectionCriteria = [];
var requiresInput = 'no';
var currentElement = null;
var currentThread = null;
var lastExecutedAnimationElement = null;
this.setEname(source);
if (animationSet)
animationSet.addThread(this);
var util = function () { return sim.getUtils(); };
var dbg = function () { return sim.getDebug(); };
var eventMgr = function () { return sim.getEventManager(); };
var renderer = function () { return animationSet.getRenderer(); };
var simDocument = function () { return sim.getSimDocument(); };
function onChangeToSpecified(criteria) {
if (criteria['onChangeTo']) {
if (criteria['onChangeTo'] == 'yes') return true;
else return false;
} else return false;
}
function changeOccurred(criteria) {
var val = criteria['variable'];
var prevVal = animationSet.getPrevInputs()[val];
var curVarName = criteria['variable'];
var currentVal = animationSet.getCurrentInputs()[curVarName];
if (currentVal != prevVal) {
if (criteria['value'] == '*') return true;
else return (currentVal == criteria['value']);
} else return false;
}
function inspectSelectionCriteria(sc, embedded, force) {
var buff = [];
var sep = '\n';
for (var l in sc) {
buff.push('selectionCriteria[');
buff.push(l);
buff.push('] = ');
buff.push(sc[l]);
buff.push(sep);
}
if (embedded) return buff.join('');
else force == null ? debug(buff.join('')) : debugf(buff.join(''));
}
this.getAnimationSet = function () {
return animationSet;
};
this.addAnimationThreadElement = function (element) {
threadElements.push(element);
return this;
};
this.getAnimationElement = function (id) {
return animationSet.getAnimationElement(id);
};
this.getFirstAnimationThreadElement = function () {
return threadElements[0];
};
this.nextAnimationThreadElement = function (reset) {
if (reset)
this.resetCurrentThreadElementIndex();
else this.incrementCurrentThreadElementIndex();
if (this.getCurrentThreadElementIndex() >= threadElements.length) return null;
else {
var nextElement = threadElements[this.getCurrentThreadElementIndex()];
return nextElement;
}
};
this.getCurrentThreadElementIndex = function () {
return currentThreadElementIndex;
};
this.setCurrentThreadElementIndex = function (num) {
currentThreadElementIndex = Math.min(Math.max(0, num), threadElements.length);
};
this.incrementCurrentThreadElementIndex = function () {
currentThreadElementIndex++;
};
this.resetCurrentThreadElementIndex = function () {
currentThreadElementIndex = 0;
};
this.getRequiresInput = function () {
return requiresInput;
};
this.setRequiresInput = function (newRequiresInput) {
requiresInput = newRequiresInput;
};
this.addSelectionCriteria = function (attributes) {
var criteriaAttr = [];
for (var i = 0; i < attributes.length; i++) {
criteriaAttr[attributes[i].nodeName] = attributes[i].nodeValue;
}
selectionCriteria.push(criteriaAttr);
};
this.getSelectionCriteria = function () {
return selectionCriteria;
};
this.isSelected = function () {
var result = true;
var sc = this.getSelectionCriteria();
if (Object.size(sc) == 0) result = true;
else {
for (var i = 0; i < sc.length; i++) {
var criterium = sc[i];
if (onChangeToSpecified(criterium)) {
if (changeOccurred(criterium)) {
if (!(criterium['variable'] in animationSet.getCurrentInputs()) || criterium['value'] != animationSet.getCurrentInputs()[criterium['variable']]) {
result = false;
break;
}
} else {
result = false;
break;
}
}
else {
if (!(criterium['variable'] in animationSet.getCurrentInputs()) || criterium['value'] != animationSet.getCurrentInputs()[criterium['variable']]) {
result = false;
break;
} else result = true;
}
}
}
return result;
};
this.startSimulation = function () {
theSet.setCurrentThread(this);
this.resetCurrentThreadElementIndex();
this.renderNextThreadElement(true);
};
this.getSourceName = function () {
return source;
};
this.renderNextThreadElement = function (startAtBeginning) {
debug('In renderNextThreadElement -startAtBeginning = ' + startAtBeginning);
if (startAtBeginning) currentThreadElement = this.getFirstAnimationThreadElement();
else {
currentThreadElement = this.nextAnimationThreadElement(false);
if (!currentThreadElement) {
dbg().logError(source, 'Could not get next AnimationThreadElement for currentThread = ' + this.getName());
return null;
}
}
debug('In renderNextThreadElement - currentThreadElement = ' + currentThreadElement.getName());
currentElement = animationSet.getAnimationElement(currentThreadElement.getName());
if (!currentElement) {
dbg().logError(source, 'Could not get new current AnimationElement for currentThreadElement = ' + currentThreadElement.getName());
return null;
}
else {
debug('In renderNextThreadElement - currentElement = ' + currentElement.getName());
currentElementName = currentElement.getName();
if (!currentElementName) dbg().logWarning(source, 'Name is null for current AnimationElement in AnimationThread = ' + this.getName());
switch (currentElement.getType()) {
case Simulator.Constants.IMAGE_ANIMATION:
debug('In renderNextThreadElement - rendering image ' + currentElement.getSrc());
renderer().renderImage(currentElement, 'animationPanel', currentElement.getSrc(),
currentElementName, currentThreadElement.getMaxTime(), this);
break;
case 'animation':
case Simulator.Constants.HTML5_ANIMATION:
if (util().canPlayHtml5()) {
renderer().renderAnimation(currentElement, 'animationPanel', currentElement.getSrc(),
util().getFileName(currentElement.getSrc()), currentThreadElement.getMaxTime(), this);
}
else if (currentElement.getAltSrcType() == Simulator.Constants.FLASH_ANIMATION) {
renderer().renderFlash(currentElement, 'animationPanel', currentElement.getAltSrc(),
util().getFileName(currentElement.getAltSrc()), currentElement.getControls(),
currentElementName, currentThreadElement.getMaxTime(), this);
}
break;
case Simulator.Constants.FLASH_ANIMATION:
renderer().renderFlash(currentElement, 'animationPanel', currentElement.getSrc(),
util().getFileName(currentElement.getSrc()), currentElement.getControls(),
currentElementName, currentThreadElement.getMaxTime(), this);
break;
case Simulator.Constants.HOTTEXT_ANIMATION:
renderer().renderHotText(currentElement, 'animationPanel', currentElement.getSrc(),
'', currentElement.getControls(),
currentElementName, currentThreadElement.getMaxTime(), this);
break;
}
}
debug('In renderNextThreadElement - returning currentElement = ' + currentElement.getName());
return currentElement;
};
this.inspect = function (embedded, force) {
var buff = [];
var sep = '\n\n';
buff.push('Inspecting AnimationThread "'); buff.push(this.getName()); buff.push('"');
buff.push(sep);
for (var i in this) {
if (i.substr(0, 3) == 'get') {
buff.push(i);
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
buff.push(inspectSelectionCriteria(this.getSelectionCriteria(), true, force));
buff.push('End of selectionCriteria');
buff.push(sep);
for (var i = 0; i < threadElements.length; i++) {
switch (getConstructorName(threadElements[i].constructor.toString())) {
case 'AnimationThreadElement':
buff.push(threadElements[i].inspect(true)); buff.push(sep);
break;
}
}
buff.push('End of AnimationThread inspection');
buff.push(sep);
if (embedded) return buff.join('');
else force == null ? debug(buff.join('')) : debugf(buff.join(''));
};
this.getCurrentElement = function () {
debug('In getCurrentElement - returning ' + ((currentElement === null) ? null : currentElement.getName()));
return currentElement;
};
this.setCurrentElement = function (element) {
debug('In setCurrentElement - setting lastExecutedAnimationElement to currentElement: ' + ((currentElement === null) ? 'null' : currentElement.getName()));
lastExecutedAnimationElement = currentElement;
debug('In setCurrentElement - setting currentElement to ' + ((element === null) ? 'null' : element.getName()));
currentElement = element;
};
this.getLastExecutedAnimationElement = function () {
return lastExecutedAnimationElement;
};
this.setAttributes = function (attr, node) {
if (node) attr = util().getAttributes(node);
Simulator.Animation.AnimationThread.prototype.setAttributes.call(this, attr, node);
for (var i in attr) {
switch (i) {
case 'maxTime':
this.setmaxTime(attr[i]);
break;
case 'requiresInput':
this.setRequiresInput(attr[i]);
break;
case 'completionPendingOnOutput':
this.setCompletionPendingOnOutput(attr[i]);
break;
}
}
var threadElements = node.childNodes;
for (var i = 0; i < threadElements.length; i++) {
switch (threadElements[i].nodeName) {
case 'selectionClause':
var clauseElements = threadElements[i].childNodes;
for (var j = 0; j < clauseElements.length; j++) {
if (clauseElements[j].nodeName[0] != '#') this.addSelectionCriteria(clauseElements[j].attributes);
}
break;
}
}
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Animation.AnimationThread.prototype = new Simulator.SimElement();
Simulator.Animation.AnimationThread.parent = Simulator.SimElement;
Simulator.Animation.AnimationThread.prototype.constructor = Simulator.Animation.AnimationThread;

// FILE: AnimationThreadElement2.js (81aeeb51) 3/7/2014 11:24:14 AM

Simulator.Animation.AnimationThreadElement = function (sim, panel, section, animationSet, animationThread) {
Simulator.SimElement.call(this, sim);
var source = 'AnimationThreadElement';
var selectionCriteria = [];
var prevInputs = [];
var currentInputs = [];
var maxTime = -1;
this.setEname(source);
var util = function () { return sim.getUtils(); };
var whiteboard = function() { sim.getWhiteboard(); };
var dbg = function () { return sim.getDebug(); };
var simDocument = function() { return sim.getSimDocument(); };
function storeInputs(backupInputs) {
var inputs = whiteboard.getCategory('dataInputs');
setPrevInputs();
if (Object.size(inputs) > 0) {
setPrevInputs();
for (var r in inputs) {
currentInputs[r] = inputs[r];
}
}
}
function setPrevInputs() {
for (var p in currentInputs) {
prevInputs[p] = currentInputs[p];
}
}
function onChangeToSpecified(criteria) {
if (criteria['onChangeTo']) {
if (criteria['onChangeTo'] == 'yes') return true;
else return false;
} else return false;
}
function changeOccurred(criteria) {
var prevVal = animationSet.getPrevInputs()[criteria['variable']];
var curVarName = criteria['variable'];
var currentVal = animationSet.getCurrentInputs()[curVarName];
if (currentVal != prevVal) {
if (criteria['value'] == '*') return true;
else return (currentVal == criteria['value']);
} else return false;
}
function inspectSelectionCriteria (criteria, embedded, force) {
var buff = [];
var sep = '\n\n';
buff.push('Inspecting Selection Criteria:');
buff.push(sep);
for (var l in criteria) {
buff.push('selectionCriteria[');
buff.push(l);
buff.push(']: '); buff.push(sep);
for (var p in criteria[l]) {
buff.push('['); buff.push(p); buff.push('] = '); buff.push(criteria[l][p]); buff.push(sep);
}
}
buff.push('End of selectionCriteria');
buff.push(sep);
if (!embedded)
(force == null) ? debug(buff.join('')) : debugf(buff.join(''));
return buff.join('');
};
this.getMaxTime = function () {
return maxTime;
};
this.setMaxTime = function (newMaxTime) {
maxTime = newMaxTime;
};
this.getAnimationThread = function () {
return animationThread;
};
this.getAnimationSet = function () {
return animationSet;
};
this.addSelectionCriteria = function (attributes) {
var criteriaAttr = [];
for (var i = 0; i < attributes.length; i++) {
criteriaAttr[attributes[i].nodeName] = attributes[i].nodeValue;
}
selectionCriteria.push(criteriaAttr);
};
this.getSelectionCriteria = function () {
return selectionCriteria;
};
this.isSelected = function () {
var result = true;
var sc = this.getSelectionCriteria();
var scSize = Object.size(sc);
var inputSize = Object.size(animationSet.getCurrentInputs());
if (scSize == 0) result = true;
else if (scSize != inputSize) result = false;
else {
for (var i = 0; i < inputSize; i++) {
var criterium = sc[i];
if (onChangeToSpecified(criterium)) {
if (changeOccurred(criterium)) {
if (!(criterium['variable'] in animationSet.getCurrentInputs()) || criterium['value'] != animationSet.getCurrentInputs()[criterium['variable']]) {
result = false;
break;
}
} else {
result = false;
break;
}
}
else {
if (!(criterium['variable'] in animationSet.getCurrentInputs()) || criterium['value'] != animationSet.getCurrentInputs()[criterium['variable']]) {
result = false;
break;
}
}
}
}
return result;
};
this.getSourceName = function() {
return source;
};
this.inspect = function (embedded, force) {
var buff = [];
var sep = '\n\n';
buff.push('Inspecting ');
buff.push(this.getEname());
buff.push(': ');
buff.push(this.getName());
buff.push(sep);
for (var i in this) {
if (i.substr(0, 3) == 'get') {
buff.push(i);
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
buff.push(inspectSelectionCriteria(selectionCriteria, true));
buff.push(sep);
buff.push('end of AnimationThreadElement Inspection'); buff.push(sep);
if (!embedded)
(force == null) ? debug(buff.join('')) : debugf(buff.join(''));
return buff.join('');
};
this.setAttributes = function (attr, node) {
if (node) attr = util().getAttributes(node);
Simulator.Animation.AnimationThreadElement.prototype.setAttributes.call(this, attr, node);
for (var i in attr) {
switch (i) {
case 'maxTime':
this.setMaxTime(attr[i]);
break;
default:
continue;
}
}
var threadElements = node.childNodes;
for (var i = 0; i < threadElements.length; i++) {
if (threadElements[i].nodeName[0] != '#') {
switch (threadElements[i].nodeName) {
case 'selectionClause':
var clauseElements = threadElements[i].childNodes;
for (var j = 0; j < clauseElements.length; j++) {
if (clauseElements[j].nodeName[0] != '#') this.addSelectionCriteria(clauseElements[j].attributes);
}
break;
}
}
}
};
this.render = function (panelName, currentElementName, maxTime, thread) {
var aThread = this.getAnimationThread();
var element = aThread.getAnimationElement(this.getName());
debug('In render - Attempting to render element "' + (element === null) ? null : element.getName() + '"');
element.render(panelName, currentElementName, maxTime, thread);
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Animation.AnimationThreadElement.prototype = new Simulator.SimElement();
Simulator.Animation.AnimationThreadElement.parent = Simulator.SimElement;
Simulator.Animation.AnimationThreadElement.prototype.constructor = Simulator.Animation.AnimationThreadElement;

// FILE: FlashAnimationInterface2.js (25f48b66) 3/7/2014 11:24:14 AM

Simulator.Animation.FlashAnimationInterface = {};
Simulator.Animation.FlashAnimationInterface.ObjectMapper = [];
Simulator.Animation.FlashAnimationInterface.GetInstance = function (simID) {
return Simulator.Animation.FlashAnimationInterface.ObjectMapper[simID];
}
Simulator.Animation.FlashAnimationInterface.MapInstance = function (simObject) {
Simulator.Animation.FlashAnimationInterface.ObjectMapper[simObject.getSimID()] = simObject;
}
Simulator.Animation.FlashAnimationInterface.AnimationMediaOutput = function (simID, type, data) {
var simulator = Simulator.Animation.FlashAnimationInterface.GetInstance(simID);
if(simulator)
simulator.getAnimationSet().animationMediaOutput(simID, type, data);
}

// FILE: Section2.js (6b08baee) 3/7/2014 11:24:14 AM

Simulator.Input.Section = function (sim, thePanel) {
Simulator.SimElement.call(this, sim);
var source = 'Section';
var instance = this;
var sectionNumber = 1;
var divider = 'no';
var sectionLabel = '';
var panel = thePanel;
var simID = null;
var dbg = function () { return sim.getDebug(); };
var utils = function () { return sim.getUtils(); };
var simMgr = function () { return sim.getSimulationManager(); };
var simDocument = function () { return sim.getSimDocument(); };
if (sim) {
simID = sim.getSimID();
}
this.setDivider = function (newDivider) {
divider = newDivider;
};
this.getDivider = function () {
return divider;
};
this.setLabel = function (newLabel) {
sectionLabel = newLabel;
return this;
};
this.getLabel = function () {
return sectionLabel;
};
this.render = function () {
var inputPanel = panel;
var label = this.getLabel();
var HTMLPanel = simDocument().getElementById(panel.getNodeID());
var space = this.getSpaceAbove();
if (space > 0) utils().appendBlankVertcalSpace(HTMLPanel, space);
if (label) {
var h2Element = simDocument().createElement('h2');
h2Element.innerHTML = label;
HTMLPanel.appendChild(h2Element);
}
var image = this.getImage();
if (image) {
div = simDocument().createElement('div');
div.id = 'imageHolder' + simID;
HTMLPanel.appendChild(div);
var span = simDocument().createElement('span');
span.id = 'holdingSpan' + simID;
div.appendChild(span);
var img = simDocument().createElement('img');
img.id = this.getEname() + SimItem.NextForNumber();
img.src = image;
span.appendChild(img);
}
if (this.getDivider() == 'yes') HTMLPanel.appendChild(simDocument().createElement('hr'));
space = this.getSpaceBelow();
if (space > 0) utils().appendBlankVertcalSpace(HTMLPanel, space);
};
this.setAttributes = function (attr, node) {
Simulator.Input.Section.prototype.setAttributes.call(this, attr, node);
for (var i in attr) {
switch (i) {
case 'divider':
instance.setDivider(attr[i]);
break;
}
}
};
function debug(str1, str2, trace) {
dbg().debug(source + ': ' + str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source + ': ' + str1, str2, trace);
}
};
Simulator.Input.Section.prototype = new Simulator.SimElement();
Simulator.Input.Section.prototype.constructor = Simulator.Input.Section;

// FILE: InputElement2.js (b2d99add) 7/23/2014 4:30:37 PM

Simulator.Input.InputElement = function (sim) {
Simulator.SimElement.call(this, sim);
var source = 'InputElement';
var prevValue = null;
var data = 0;
var availableinputScopes = ['dataInput', 'animationInput', 'evaluationInput'];
var inputScope = [];
var saveOnChange = true;
var key = undefined;
var scoreable = true;
var state = 'enabled';
var eventsRegistered = false;
var panel = null;
var section = null;
var dbg = function () { return sim.getDebug(); };
var eventMgr = function () { return sim.getEventManager(); };
var simulationMgr = function () { return sim.getSimulationManager(); };
var whiteboard = function () { return sim.getWhiteboard(); };
var scoringTable = function () { return sim.getScoringTable(); };
var simDocument = function () { return sim.getSimDocument(); };
this.getPanel = function () {
return panel;
};
this.setPanel = function (newPanel) {
panel = newPanel;
panel.registerIOElement(this);
return this;
};
this.setSection = function (theSection) {
section = theSection;
};
this.getSectionLabel = function () {
return section.getLabel();
};
this.getPrevValue = function () {
return prevValue;
};
this.setPrevValue = function (newPrevValue) {
prevValue = newPrevValue;
return this;
};
this.getData = function () {
var dataArray = [];
if (dataArray[0]) prevValue = dataArray[0];
dataArray[0] = data;
return dataArray;
};
this.setData = function (newData) {
if (data) prevValue = data;
data = newData;
return this;
};
this.getInputScope = function () {
return inputScope;
};
this.setInputScope = function (newinputScope) {
if (newinputScope == 'globalInput') {
for (var i = 0; i < availableinputScopes.length; i++) inputScope[i] = availableinputScopes[i];
} else inputScope = newinputScope.split(',');
for (var j = 0; j < inputScope.length; j++) inputScope[j] = inputScope[j].trim();
};
this.getSaveOnChange = function () {
return saveOnChange;
};
this.setSaveOnChange = function (newSaveOnChange) {
saveOnChange = newSaveOnChange == 'no' ? false : true;
};
this.onChange = function (id) {
if (!id) id = this.getNodeID();
var jsObj = this.getHTMLElement(id);
this.recordInput(jsObj, false, true);
this.postOnChangeEvents();
};
this.recordInput = function (obj, setDefault, recordOnChange) {
var value = null;
for (var i = 0; i < inputScope.length; i++) {
if (key == undefined) key = whiteboard().addItem(inputScope[i], this.getName());
value = this.getData(inputScope[i]);
if (value) {
if (inputScope[i] == 'animationInput' && this instanceof Simulator.Input.InputElement) value = this.formatForAnimationInput(value);
else if (inputScope[i] == 'dataInput' && this instanceof Simulator.Input.InputElement) value = this.formatForTableInput(value);
whiteboard().setItem(inputScope[i], this.getName(), value, key);
}
}
if (value && this.getScoreable() && !setDefault && this.postOnChangeEnabled()) {
scoringTable().setValue(this.getName(), simulationMgr().getTrialRowNum(recordOnChange), value);
}
};
this.getScoreable = function () {
return scoreable;
};
this.formatForAnimationInput = function (value) {
return value;
};
this.formatForTableInput = function (value) {
return value;
};
this.setScoreable = function (newScoreable) {
if (newScoreable == 'yes') scoreable = true;
else scoreable = false;
};
this.getState = function () {
return state;
};
this.setState = function (newState) {
if (newState == 'disabled') state = 'disabled';
else state = 'enabled';
};
this.disableInput = function () {
var element = simDocument().getElementById(this.getNodeID());
element.disabled = true;
this.setState('disabled');
};
this.enableInput = function () {
var element = simDocument().getElementById(this.getNodeID());
element.disabled = false;
this.setState('enabled');
};
this.getHTMLElement = function (id) {
if (id) return simDocument().getElementById(id);
else return simDocument().getElementById(this.getNodeID());
};
this.registerEvents = function () {
if (!eventsRegistered) {
eventMgr().registerEvent(new Simulator.Event(this, 'info', 'simulatorStateChange'), 'to');
eventsRegistered = true;
}
};
this.setAttributes = function (attr) {
Simulator.Input.InputElement.prototype.setAttributes.call(this, attr);
for (var i in attr) {
switch (i) {
case 'inputScope':
this.setInputScope(attr[i]);
break;
case 'state':
this.setState(attr[i]);
break;
case 'scoreable':
this.setScoreable(attr[i]);
break;
case 'saveOnChange':
this.setSaveOnChange(attr[i]);
break;
}
}
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Input.InputElement.prototype = new Simulator.SimElement();
Simulator.Input.InputElement.parent = Simulator.SimElement;
Simulator.Input.InputElement.prototype.constructor = Simulator.Input.InputElement;

// FILE: GroupList2.js (ff4ad670) 3/7/2014 11:24:14 AM

Simulator.Input.GroupList = function(sim) {
Simulator.Input.InputElement.call(this, sim);
var items = [];
var dbg = function() { return sim.getDebug(); };
var eventMgr = function() { return sim.getEventManager(); };
var utils = function() { return sim.getUtils(); };
var simulationMgr = function() { return sim.getSimulationManager(); };
var simDocument = function() { return sim.getSimDocument(); };
this.getItems = function() {
return items;
};
this.setItems = function(node) {
var id;
var ruleName = null;
var elementName = '';
try {
if(utils().isInternetExplorer()) elementName = node.attributes.getNamedItem('name').value;
else elementName = node.attributes['name'].nodeValue;
} catch(err) {
dbg().logError(source, 'Error occurred getting element name: ' + err.message);
elementName = '';
}
var attr = [];
var theItem;
var itemID = null;
var itemNum = 0;
if (node.childNodes != null) {
for ( var j = 0; j < node.childNodes.length; j++) {
id = node.childNodes[j].nodeName;
if (id[0] != '#') {
if (id == 'item') {
theItem = node.childNodes[j];
attr = theItem.attributes;
var attributes = new Simulator.Utils.Dictionary(sim);
items[itemNum] = attributes;
for ( var i = 0; i < attr.length; i++) {
var attribute = attr[i];
var nodeName = attribute.nodeName;
if(attribute.nodeName == 'image') {
attributes.setValue(nodeName, attribute.nodeValue);
}
else attributes.setValue(nodeName, attribute.nodeValue);
}
itemID = j == 0 ? this.createItemID(true, itemNum) : this.createItemID(false, itemNum);
attributes.setValue('itemID', itemID);
itemNum++;
}
}
}
}
};
this.disableItems = function() {
for(var i = 0; i < items.length; i++) {
var element = simDocument().getElementById(items[i].itemID);
element.disabled = true;
}
};
this.enableItems = function() {
for(var i = 0; i < items.length; i++) {
var element = simDocument().getElementById(items[i].itemID);
element.disabled = false;
}
};
this.getDefaultSelection = function() {
var defaults = [];
for(var i = 0; i < items.length; i++) {
if(items[i].keyExists('default')) {
if(items[i].lookup('default') == 'yes') {
defaults.push(items[i].lookup('val'));
}
}
}
return defaults;
};
this.setDefaultSelections = function() {
var defaults = this.getDefaultSelection();
if(defaults.length > 0) {
selectedItem = defaults;
this.setData(defaults);
}
};
this.getDataProxy = function(itemNum) {
if(itemNum != undefined && itemNum != null) return  items[itemNum].lookup('dataProxy');
else return null;
};
this.getAnimationProxy = function(itemNum) {
if(itemNum != undefined && itemNum != null) return  items[itemNum].lookup('animationProxy');
else return null;
};
this.getEvaluationProxy = function(itemNum) {
if(itemNum != undefined && itemNum != null) return  items[itemNum].lookup('evaluationProxy');
else return null;
};
this.extractItemValue = function(itemIndex) {
var value = null;
var inputScope = this.getInputScope();
if(isNaN(itemIndex)) {
for(var i = 0; i < items.length; i++) {
if(items[i].itemID == itemIndex) {
itemIndex = i;
break;
}
}
}
if(itemIndex >= 0) {
if(inputScope == 'dataInput') value = this.getDataProxy(itemIndex);
else if(inputScope == 'evaluationInput') value = this.getEvaluationProxy(itemIndex);
else if(inputScope == 'animationInput') value = this.getAnimationProxy(itemIndex);
if(value == undefined || value == null) value = items[itemIndex].lookup('val');
return value;
} else {
dbg().logError(source, 'itemIndex = "' + itemIndex + '". Could not extract item value');
return null;
}
};
this.saveState = function(indent, preface, nameStr, valStr, suffix) {
var checkedItems = '';
for(var i = 0; i < items.length; i++) {
var id = items[i].itemID;
var value = items[i].lookup('val');
if(value == undefined || value == null || value == '') value = items[i].lookup('dataProxy');
var htmlElement = simDocument().getElementById(id);
if(htmlElement.checked != undefined) {
if(htmlElement.checked) {
if(checkedItems == '') checkedItems = checkedItems + value;
else checkedItems = checkedItems + ', ' + value;
}
} else if(htmlElement.selected != undefined) {
if(htmlElement.selected) {
this.selectedIndex = value;
checkedItems = value;
}
}
}
if(checkedItems != '') return indent + preface + nameStr + this.getName() + valStr + checkedItems + suffix;
else return '';
};
this.setSelectStateViaKeyboard = function(elementID, itemID) {
var HTMLItem = null;
if(itemID) HTMLItem = simDocument().getElementById(itemID);
else HTMLItem = simDocument().getElementById(elementID);
if(HTMLItem) {
if(this.getType() == 'dropList') {
if(HTMLItem.selected) HTMLItem.removeAttribute('selected');
else {
HTMLItem.selected = 'selected';
}
} else {
if(HTMLItem.checked) HTMLItem.removeAttribute('checked');
else {
HTMLItem.checked = 'checked';
this.recordInput(this);
}
}
}
};
this.setSelectStateViaSpeech = function(elementID, itemID) {
this.recordKeyboardSelection(elementID, itemID);
};
this.recordKeyboardSelection = function(elementID, itemID, itemIndex) {
var element = null;
var item = null;
if(itemID) {
item = simDocument().getElementById(itemID);
if(!item) {
element = simDocument().getElementById(elementID);
if(element) item = element.getElementsByClassName(itemID)[0];
}
if(item) {
item.isSelected = true;
this.setSelectStateViaKeyboard(elementID, itemID);
this.onChange(elementID);
}
}
};
this.inspect = function(embedded, forced) {
buff = [];
if (!embedded)
buff.push('Inspecting GroupList');
var items = this.getItems();
for ( var i in items) {
buff.push(i);
buff.push(' = ');
buff.push(items[i]);
buff.push('\n\n');
}
if(!embedded) forced == true ? dbg().debugf(buff.join('')) : dbg().debug(buff.join());
else return buff.join('');
};
this.setAttributes = function(attr) {
Simulator.Input.GroupList.prototype.setAttributes.call(this, attr);
for ( var i in attr) {
switch (i) {
case 'items':
this.setItems(attr[i]);
break;
}
}
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Input.GroupList.prototype = new Simulator.Input.InputElement();
Simulator.Input.GroupList.prototype.constructor = Simulator.Input.GroupList;

// FILE: ChoiceList2.js (74f8086b) 5/2/2014 12:55:58 PM

Simulator.Input.ChoiceList = function(sim, node, panel, theSection) {
Simulator.Input.GroupList.call(this, sim);
var that = this;
var source = 'ChoiceList';
var dbg = function() { return sim.getDebug(); };
var utils = function() { return sim.getUtils(); };
var simMgr = function() { return sim.getSimulationManager(); };
var keyboardInput = function () { return sim.getKeyboardInput(); };
var scoringTable = function () { return sim.getScoringTable(); };
var simDocument = function() { return sim.getSimDocument(); };
if(sim) {
this.setPanel(panel);
this.setSection(theSection);
}
this.formatEventData = function() {
var buff = [];
var data = this.getData();
for(var i = 0; i < data.length; i++) {
if(data[i]) {
buff.push(data[i]);
if(i < data.length - 1) buff.push(',');
}
}
return buff.join('');
};
this.formatForAnimationInput = function(value) {
var output = [];
output[0] = value.join(Simulator.Constants.MULTIPLE_VALUE_DELIMITTER);
return output;
};
this.formatForTableInput = function(value) {
var output = [];
output[0] = value.join(Simulator.Constants.MULTIPLE_VALUE_DELIMITTER + ' ');
return output;
};
this.getData = function(inputScope) {
var checkedItems = [];
var k = 0;
var item = null;
var proxy = null;
var items = this.getItems();
for(var i = 0; i < items.length; i++) {
var labelFor = simDocument().getElementById(items[i].lookup('labelForID'));
item = simDocument().getElementById(items[i]['itemID']);
if(item.checked) {
if(inputScope == 'dataInput') proxy = this.getDataProxy(i);
else if(inputScope == 'evaluationInput') proxy = this.getEvaluationProxy(i);
else if(inputScope == 'animationInput') proxy = this.getAnimationProxy(i);
if(proxy != undefined && proxy != null) checkedItems[k] = proxy;
else checkedItems[k] = items[i].lookup('val');
labelFor.setAttribute('class', 'inputChecked');
k++;
}
else labelFor.removeAttribute('class');
}
this.setData(checkedItems);
return checkedItems;
};
this.handleEvent = function(event) {
switch (event.type) {
case 'inputReq':
this.recordInput(this);
break;
case 'info':
switch(event.context) {
case 'simulatorStateChange':
break;
}
break;
default:
dbg().logWarning(sourde, 'Unhandled event type received: ' + event.toString());
return;
}
};
this.setElementSelectState = function (state, contents) {
var htmlElement = null;
selectedItem = -1;
var items = this.getItems();
var parts = contents.split(',');
for (var i = 0; i < parts.length; i++) {
if (parts[i] != null) parts[i] = parts[i].trim();
}
var proxy = null;
var value = null;
for (var i = 0; i < items.length; i++) {
var labelFor = simDocument().getElementById(items[i].lookup('labelForID'));
proxy = items[i].lookup('dataProxy');
if (proxy) value = proxy;
else value = items[i].lookup('val');
if (state == 'true') {
if (utils().elementInArray(parts, value)) {
items[i].setValue('selected', 'checked');
if (selectedItem == '') selectedItem = value;
else selectedItem = ', ' + value;
htmlElement = simDocument().getElementById(items[i].itemID);
htmlElement.checked = 'checked';
labelFor.setAttribute('class', 'inputChecked');
this.recordInput(this, true);
}
else if ((items[i].lookup('selected')) || (items[i].lookup('default') == 'yes')) {
htmlElement = simDocument().getElementById(items[i].itemID);
if(htmlElement) htmlElement.checked = false;
labelFor.removeAttribute('class');
items[i].remove('selected');
}
} else {
if (value == contents && items[i].lookup('selected')) {
htmlElement = simDocument().getElementById(items[i].itemID);
if(htmlElement) htmlElement.checked = false;
labelFor.removeAttribute('class');
items[i].remove('selected');
}
}
}
};
this.keyboardNavigateTo = function(elementID, itemID, index) {
var element = simDocument().getElementById(elementID);
var nodes = element.getElementsByTagName('li');
var item = nodes[index];
if(element) element.selectedIndex = index;
if(item) item.setAttribute('class', 'simAreaFocus');
};
this.keyboardNavigateAwayFrom = function(elementID, itemID, index) {
var element = simDocument().getElementById(elementID);
var nodes = element.getElementsByTagName('li');
var item = nodes[index];
item.removeAttribute('class');
};
this.disableInput = function() {
this.disableItems();
};
this.enableInput = function() {
this.enableItems();
};
this.setAttributes = function(attr, node) {
Simulator.Input.ChoiceList.prototype.setAttributes.call(this, attr);
if(this.getScoreable()) scoringTable().addElement(this.getName(), 'input');
this.setItems(node);
};
this.doOnClick = function(id) {
this.onChange(id);
};
this.render = function() {
var nodeID = this.getNodeID();
var itemID = null;
var items = this.getItems();
var nextNum = utils().getNextSequenceNumber();
var image = null;
var panelHtml = panel.getHTMLElement();
this.setFocusable(true, true);
if(this.getLabel()) {
var textLabelEl = simDocument().createTextNode(this.getLabel());
panelHtml.appendChild(textLabelEl);
var brElement = simDocument().createElement('br');
panelHtml.appendChild(brElement);
}
for ( var x = 0; x < items.length; x++) {
var itemIDReset = x == 0 ? true : false;
itemID = this.createItemID(itemIDReset);
items[x]['itemID'] = itemID;
image = (items[x]).lookup('image');
if(x == 0) {
if (image != null && image != undefined) {
var ulElement = simDocument().createElement('ul');
ulElement.id = nodeID;
ulElement.setAttribute('class', 'multiSelect withImages');
} else {
ulElement = simDocument().createElement('ul');
ulElement.id = nodeID;
ulElement.setAttribute('class', 'multiSelect');
}
panelHtml.appendChild(ulElement);
}
var labelForID = 'labelFor' + itemID;
items[x].setValue('labelForID', labelForID);
if ((items[x]).lookup('val') != undefined) {
var listElement = simDocument().createElement('li');
var inputEl = simDocument().createElement('input');
inputEl.id = itemID;
inputEl.setAttribute('type', 'checkbox');
inputEl.setAttribute('name', 'ChoiceButtonGroup' + nodeID + nextNum);
inputEl.setAttribute('value', (items[x]).lookup('val'));
if(this.getSaveOnChange()) {
utils().bindEvent(inputEl, 'click', function () {
that.doOnClick(nodeID);
});
}
if(items[x].lookup('default') == 'yes') {
inputEl.setAttribute('checked', '');
}
listElement.appendChild(inputEl);
var labelForID = 'labelFor' + itemID;
items[x].setValue('labelForID', labelForID);
var labelEl = simDocument().createElement('label');
labelEl.id = labelForID;
labelEl.setAttribute('for', itemID);
if(items[x].lookup('default') == 'yes') {
labelEl.setAttribute('class', 'inputChecked');
}
if (image != null && image != undefined) {
var imageSpanEl = simDocument().createElement('span');
imageSpanEl.setAttribute('class', 'holderImage');
var imageEl = simDocument().createElement('img');
imageEl.setAttribute('src', image);
imageEl.setAttribute('alt', (items[x]).lookup('val'));
imageSpanEl.appendChild(imageEl);
labelEl.appendChild(imageSpanEl);
}
var listLabelSpanEl = simDocument().createElement('span');
listLabelSpanEl.setAttribute('class', 'listLabel');
listLabelSpanEl.innerHTML = (items[x]).lookup('val');
labelEl.appendChild(listLabelSpanEl);
listElement.appendChild(labelEl);
ulElement.appendChild(listElement);
}
if (this.isFocusable()) {
keyboardInput().addFocusableElementItem(this, this.getNodeID(), itemID);
}
}
this.setDefaultSelections();
this.mapHTML2JS(ulElement);
};
this.getSourceName = function() {
return source;
};
this.inspect = function(embedded, forced) {
var buff = [];
var sep = '\n\n';
buff.push('Inspecting ');
buff.push(this.getName());
buff.push(sep);
for ( var i in this) {
if (i == 'items') {
buff.push(this.parent.inspect());
} else {
if (i.substr(0, 3) == 'get') {
buff.push(i);
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
}
if(!embedded) forced == true ? dbg().debugf(buff.join('')) : dbg().debug(buff.join(''));
else return buff.join('');
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Input.ChoiceList.prototype = new Simulator.Input.GroupList();
Simulator.Input.ChoiceList.prototype.constructor = Simulator.Input.ChoiceList;

// FILE: DropList2.js (b5bdbdde) 3/7/2014 11:24:14 AM

Simulator.Input.DropList = function(sim, node, panel, theSection) {
Simulator.Input.GroupList.call(this, sim);
var dbg = function() { return sim.getDebug(); };
var utils = function() { return sim.getUtils(); };
var keyboardInput = function () { return sim.getKeyboardInput(); };
var scoringTable = function () { return sim.getScoringTable(); };
var simMgr = function () { return sim.getSimulationManager(); };
var simDocument = function() { return sim.getSimDocument(); };
var instance = this;
var selectType = 'single';
var listExpanded = false;
if(sim) {
this.setPanel(panel);
this.setSection(theSection);
}
this.getSelectType = function() {
return selectType;
};
this.getElementData = function(id) {
};
this.getKeyboardInput = function() {
return keyboardInput();
};
this.setSelectType = function(newSelectType) {
selectType = newSelectType;
return this;
};
this.getListExpanded = function() {
return listExpanded;
};
this.getData = function(inputScope) {
var data = [];
var proxy = null;
var select = simDocument().getElementById(this.getNodeID());
var value = select.value;
this.setData(value);
if(inputScope == 'dataInput') proxy = this.getDataProxy(select.selectedIndex);
else if(inputScope == 'animationInput') proxy = this.getAnimationProxy(select.selectedIndex);
else if(inputScope == 'evaluationInput') proxy = this.getEvaluationProxy(select.selectedIndex);
if(proxy != undefined && proxy != null) data[0] = proxy;
else data[0] = value;
return data;
};
this.handleEvent = function(event) {
switch (event.type) {
case 'inputReq':
this.recordInput(this);
break;
case 'info':
switch(event.context) {
case 'simulatorStateChange':
break;
}
break;
default:
dbg().logWarning(source, 'Unhandled event type received: ' + event.toString());
return;
}
};
this.setElementSelectState = function(state, contents) {
var items = this.getItems();
var proxy = null;
var value = null;
for(var i = 0; i < items.length; i++) {
proxy = items[i].lookup('dataProxy');
if(proxy) value = proxy;
else value = items[i].lookup('val');
var htmlElement = simDocument().getElementById(items[i].itemID);
if(state == 'true') {
if(value == contents) {
items[i].setValue('selected', 'selected');
selectedItem = value;
htmlElement.selected = true;
this.recordInput(this, true);
}
else if(items[i].lookup('selected') == 'selected') htmlElement.removeAttribute('selected');
} else {
if(value == contents && items[i].lookup('selected') == 'selected') htmlElement.removeAttribute('selected');
}
}
};
this.receivedSpeechFocus = function() {
debug(this.getName() + ' received speech focus');
var element = simDocument().getElementById(this.getNodeID());
var node = simDocument().getElementById(Simulator.Constants.INPUT_PANEL_NAME);
var outline = simDocument().getElementById('dropHolder' + this.getName());
if(outline) outline.setAttribute('class', 'dropHolder simAreaFocus');
outline.size = this.getItems().length;
element.size = this.getItems().length;
node = simDocument().getElementById(this.getName());
node.style.border='thin solid #ff0000';
};
this.speechActivated = function(value) {
this.setSelectStateViaSpeech(this.getNodeID(), value);
InputElement.onChange(this.getNodeID());
};
this.removeSpeechFocus = function() {
debug(this.getName() + ' lost speech focus');
var element = simDocument().getElementById(this.getNodeID());
element.size = 1;
var node = simDocument().getElementById(Simulator.Constants.INPUT_PANEL_NAME);
var element = getElementsByClassName('dropHolder', node)[0];
node = simDocument().getElementById(this.getName());
node.style.border='none';
if(element) element.setAttribute('class', 'dropHolder');
};
this.keyboardNavigateTo = function(elementID, itemID, index) {
var element = simDocument().getElementById(elementID);
var outline = element.getParentNode;
if(outline) outline.setAttribute("class", "dropHolder simAreaFocus");
var item = null;
item = simDocument().getElementById(itemID);
if (item) {
item.setAttribute("focused", "focused");
}
if (!listExpanded) {
this.expandList();
listExpanded = true;
}
};
this.keyboardNavigateAwayFrom = function(elementID, itemID, index) {
var element = simDocument().getElementById(elementID);
var outline = element.getParentNode;
if(outline) outline.setAttribute("class", "dropHolder");
var item = null;
item = simDocument().getElementById(itemID);
if (item) {
item.setAttribute("focused", "");
}
if (listExpanded) {
this.closeList();
listExpanded = false;
}
};
this.disableInput = function() {
this.disableItems();
};
this.enableInput = function() {
this.enableItems();
};
this.expandList = function() {
var dlist = simDocument().getElementById(this.getNodeID());
var newspan = simDocument().createElement('span');
newspan.setAttribute('id', "selectholderspan");
newspan.setAttribute('class', "selectHolder selectOpened");
dlist.parentNode.parentNode.appendChild(newspan);
newspan.appendChild(dlist.parentNode);
dlist.setAttribute('size', this.getItems().length);
var visibleHeight = 1.2 * this.getItems().length;
dlist.style.height = visibleHeight.toString() + 'em';
var container = simDocument().getElementById(Simulator.Constants.SIM_CONTAINER_NAME + sim.getSimID());
if (container) {
utils().bindEvent(container, 'click', function () {
if ((instance) && (instance.getListExpanded())) {
instance.getKeyboardInput().closeDropList();
}
});
}
};
this.closeList = function() {
var dlist = simDocument().getElementById(this.getNodeID());
dlist.style.height = "";
dlist.setAttribute('size', 0);
var spanRemoved = dlist.parentNode.parentNode;
spanRemoved.parentNode.appendChild(dlist.parentNode);
spanRemoved.parentNode.removeChild(spanRemoved);
};
this.recordKeyboardSelection = function(elementID, itemID, itemIndex) {
var element = null;
var item = null;
if((itemID) && (elementID)) {
item = simDocument().getElementById(itemID);
element = simDocument().getElementById(elementID);
if(!item) {
if(element) item = element.getElementsByClassName(itemID)[0];
}
if(item) {
if ((element.selectedIndex != null) && (element.selectedIndex >= 0))
element.options[element.selectedIndex].setAttribute("selected", "");
item.selected = true;
item.setAttribute("selected", "selected");
if (element)
element.selectedIndex = itemIndex;
this.setSelectStateViaKeyboard(elementID, itemID);
this.onChange(elementID);
}
}
if (listExpanded) {
this.closeList();
listExpanded = false;
}
};
this.setAttributes = function(attr, node) {
Simulator.Input.DropList.prototype.setAttributes.call(this, attr);
for ( var i in attr) {
switch (i) {
case 'selectType':
this.setSelectType(attr[i]);
break;
}
}
if(instance.getScoreable()) scoringTable().addElement(instance.getName(), 'input');
this.setItems(node);
};
this.doOnChange = function() {
instance.onChange(instance.getNodeID());
};
this.render = function() {
var items = this.getItems();
var itemID = null;
this.setFocusable(true, true);
var image = this.getImage();
if (image != undefined && image != null) {
var dropDiv = simDocument().createElement('div');
dropDiv.setAttribute('class', 'dropDown withImages');
dropDiv.id = this.getName();
var holderSpan = simDocument().createElement('span');
holderSpan.setAttribute('class', 'holderImage');
dropDiv.appendChild(holderSpan);
var img = simDocument().createElement('img');
img.src = image;
img.alt = this.getName() + ' image';
holderSpan.appendChild(img);
dropDiv.appendChild(holderSpan);
}
else {
var dropDiv = simDocument().createElement('div');
dropDiv.setAttribute('class', 'dropDown');
dropDiv.id = this.getName();
}
var form = simDocument().createElement('form');
dropDiv.appendChild(form);
form.name = this.getName();
var formSpan = simDocument().createElement('span');
formSpan.setAttribute('class', 'dropHolder');
formSpan.id = 'dropHolder' + this.getName();
form.appendChild(formSpan);
if(this.getLabel()) {
var labelSpan = simDocument().createElement('span');
labelSpan.style.padding.top = '15px';
labelSpan.style.padding.top = '15px';
labelSpan.innerHTML = this.getLabel();
formSpan.appendChild(labelSpan);
}
var select = simDocument().createElement('select');
select.id = this.getNodeID();
select.innerHTML =  + this.getName();
var item = null;
for ( var x = 0; x < items.length; x++) {
var itemIDReset = x == 0 ? true : false;
itemID = this.createItemID(itemIDReset);
items[x]['itemID'] = itemID;
if ((items[x]).lookup('val') != undefined) {
item = simDocument().createElement('option');
item.id = itemID;
item.value = (items[x]).lookup('val');
}
if(items[x].lookup('default') == 'yes') item.selected = 'selected';
item.innerHTML = (items[x]).lookup('val');
select.appendChild(item);
if(this.isFocusable()) {
keyboardInput().addFocusableElementItem(this, this.getNodeID(), itemID);
}
}
formSpan.appendChild(select);
var arrowSpan = simDocument().createElement('span');
arrowSpan.setAttribute('class', 'dropArrow');
formSpan.appendChild(arrowSpan);
htmlPanel = panel.getHTMLElement();
htmlPanel.appendChild(dropDiv);
var dropList = simDocument().getElementById(this.getNodeID());
if(instance.getSaveOnChange())
utils().bindEvent(dropList, 'change', function() {
instance.doOnChange();
});
utils().appendBlankVertcalSpace(simDocument().getElementById(panel.getNodeID()), 2);
this.setDefaultSelections();
this.mapHTML2JS(dropList);
};
this.getSourceName = function() {
return source;
};
this.inspect = function(embedded, forced) {
var buff = [];
var sep = '\n\n';
if(!embedded) {
buff.push('Inspecting ');
buff.push(this.getName());
buff.push(sep);
}
for ( var i in this) {
if (i == 'items') {
buff.push(this.parent.inspect());
} else {
if (i.substr(0, 3) == 'get') {
buff.push(i);
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
}
if(!embedded) forced === true ? dbg().debugf(buff.join('')) : dbg().debug(buff.join(''));
else return buff.join('');
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Input.DropList.prototype = new Simulator.Input.GroupList();
Simulator.Input.DropList.prototype.constructor = Simulator.Input.DropList;

// FILE: OptionList2.js (a282b555) 3/7/2014 11:24:14 AM

Simulator.Input.OptionList = function(sim, node, panel, theSection) {
Simulator.Input.GroupList.call(this, sim);
var that = this;
var source = 'OptionList';
var dbg = function() { return sim.getDebug(); };
var utils = function() { return sim.getUtils(); };
var scoringTable = function () { return sim.getScoringTable(); };
var keyboardInput = function () { return sim.getKeyboardInput(); };
var simMgr = function() { sim.getSimulationManager(); };
var simDocument = function() { return sim.getSimDocument(); };
if(sim) {
this.setPanel(panel);
this.setSection(theSection);
}
this.getData = function(inputScope) {
var data = [];
var proxy = null;
var items = this.getItems();
for(var i = 0;  i < items.length; i++) {
var HTMLItem = simDocument().getElementById(items[i].lookup('itemID'));
var labelFor = simDocument().getElementById(items[i].lookup('labelForID'));
if(inputScope == 'dataInput') proxy = this.getDataProxy(i);
else if(inputScope == 'evaluationInput') proxy = this.getEvaluationProxy(i);
else if(inputScope == 'animationInput') proxy = this.getAnimationProxy(i);
if(HTMLItem.checked) {
if(proxy != undefined && proxy != null) data[0] = proxy;
else data[0] = items[i].lookup('val');
this.setData(data[0]);
labelFor.setAttribute('class', 'inputChecked');
items[i].setValue('checked','true');
selectedItem = data[0];
}
else {
labelFor.removeAttribute('class');
items[i].setValue('checked', 'false');
}
}
if(data.length == 0) this.setData('');
return data;
};
this.handleEvent = function(event) {
switch (event.type) {
case 'inputReq':
this.recordInput(this);
break;
case 'info':
switch(event.context) {
case 'simulatorStateChange':
break;
}
break;
default:
dbg().logWarning(source, 'Unhandled event type received: ' + event.toString());
return;
}
};
this.setElementSelectState = function(state, contents) {
var items = this.getItems();
var proxy = null;
var value = null;
for(var i = 0; i < items.length; i++) {
proxy = items[i].lookup('dataProxy');
if(proxy) value = proxy;
else value = items[i].lookup('val');
var itemID = items[i].lookup('itemID');
var labelFor = simDocument().getElementById('labelFor' + itemID);
var htmlElement = simDocument().getElementById(itemID);
if(value == contents) {
items[i].setValue('checked','true');
selectedItem = value;
htmlElement.checked = 'checked';
labelFor.setAttribute('class', 'inputChecked');
this.recordInput(this, true);
}
else if(items[i].lookup('checked')) {
items[i].setValue('checked', 'false');
htmlElement.removeAttribute('checked');
labelFor.removeAttribute('class');
}
}
};
this.keyboardNavigateTo = function(elementID, itemID, index) {
var element = simDocument().getElementById(elementID);
var nodes = element.getElementsByTagName('li');
var item = nodes[index];
if(element) element.selectedIndex = index;
if(item) item.setAttribute('class', 'simAreaFocus');
};
this.receivedSpeechFocus = function() {
debug(this.getName() + ' received speech focus');
var element = simDocument().getElementById(this.getNodeID());
var nodes = element.getElementsByTagName('li');
var item = nodes[0];
if(element) element.selectedIndex = 0;
element.style.border='thin solid #ff0000';
if(item) item.setAttribute('class', 'simAreaFocus');
};
this.keyboardNavigateAwayFrom = function(elementID, itemID, index) {
var element = simDocument().getElementById(elementID);
var nodes = element.getElementsByTagName('li');
var item = nodes[index];
item.removeAttribute('class');
};
this.removeSpeechFocus = function() {
debug(this.getName() + ' lost speech focus');
var element = simDocument().getElementById(this.getNodeID());
var nodes = element.getElementsByTagName('li');
var item = nodes[0];
item.removeAttribute('class');
element.style.border='none';
};
this.disableInput = function() {
this.disableItems();
};
this.enableInput = function() {
this.enableItems();
};
this.speechActivated = function(value) {
this.setSelectStateViaSpeech(this.getNodeID(), value);
this.onChange(this.getNodeID());
};
this.setAttributes = function(attr, node) {
Simulator.Input.OptionList.prototype.setAttributes.call(this, attr, node);
if(this.getScoreable()) scoringTable().addElement(this.getName(), 'input');
this.setItems(node);
};
this.doOnClick = function(id) {
this.onChange(id);
};
this.render = function() {
var nodeID = this.getNodeID();
var itemID = null;
var items = this.getItems();
var nextNum = utils().getNextSequenceNumber();
var image = null;
var panelHtml = panel.getHTMLElement();
this.setFocusable(true, true);
if(this.getLabel()) {
var textLabelEl = simDocument().createTextNode(this.getLabel());
panelHtml.appendChild(textLabelEl);
var brElement = simDocument().createElement('br');
panelHtml.appendChild(brElement);
}
var ulElement = null;
for ( var x = 0; x < items.length; x++) {
var itemIDReset = x == 0 ? true : false;
itemID = this.createItemID(itemIDReset);
items[x]['itemID'] = itemID;
image = (items[x]).lookup('image');
if(x == 0) {
if (image != undefined && image != null) {
ulElement = simDocument().createElement('ul');
ulElement.id = nodeID;
ulElement.setAttribute('class', 'singleSelect withImages');
} else {
ulElement = simDocument().createElement('ul');
ulElement.id = nodeID;
ulElement.setAttribute('class', 'singleSelect');
}
panelHtml.appendChild(ulElement);
}
if ((items[x]).lookup('val') != undefined) {
var listElement = simDocument().createElement('li');
var inputEl = simDocument().createElement('input');
inputEl.id = itemID;
inputEl.setAttribute('type', 'radio');
inputEl.setAttribute('name', 'RadioButtonGroup' + nodeID + nextNum);
inputEl.setAttribute('value', (items[x]).lookup('val'));
if (this.getSaveOnChange()) {
utils().bindEvent(inputEl, 'click', function () {
that.doOnClick(nodeID);
});
}
if(items[x].lookup('default') == 'yes') {
inputEl.setAttribute('checked', '');
}
listElement.appendChild(inputEl);
var labelForID = 'labelFor' + itemID;
items[x].setValue('labelForID', labelForID);
var elementLabel = simDocument().createElement('label');
elementLabel.id = labelForID;
elementLabel.setAttribute('for', itemID);
if(items[x].lookup('default') == 'yes') {
elementLabel.setAttribute('class', 'inputChecked');
}
if (image != undefined && image != null) {
var imageSpanEl = simDocument().createElement('span');
imageSpanEl.setAttribute('class', 'holderImage');
var imageEl = simDocument().createElement('img');
imageEl.setAttribute('src', image);
imageEl.setAttribute('alt', (items[x]).lookup('val'));
imageSpanEl.appendChild(imageEl);
elementLabel.appendChild(imageSpanEl);
}
var listLabelSpanEl = simDocument().createElement('span');
listLabelSpanEl.setAttribute('class', 'listLabel');
listLabelSpanEl.innerHTML = (items[x]).lookup('val');
elementLabel.appendChild(listLabelSpanEl);
listElement.appendChild(elementLabel);
ulElement.appendChild(listElement);
}
if(this.isFocusable()) {
keyboardInput().addFocusableElementItem(this, nodeID, itemID);
}
}
this.setDefaultSelections();
this.mapHTML2JS(ulElement);
};
this.getSourceName = function() {
return source;
};
this.inspect = function(embedded, forced) {
var buff = [];
var sep = '\n\n';
if(!embedded) {
buff.push('Inspecting ');
buff.push(this.getName());
buff.push(sep);
}
for ( var i in this) {
if (i == 'items') {
buff.push(this.parent.inspect());
} else {
if (i.substr(0, 3) == 'get') {
buff.push(i);
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
}
if(!embedded) forced === true ? dbg().debug(buff.join('')) : dbg().debug(buff.join(''));
else return buff.join('');
};
var debug = function(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
};
var debugf = function(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
};
};
Simulator.Input.OptionList.prototype = new Simulator.Input.GroupList();
Simulator.Input.OptionList.parent = Simulator.Input.GroupList;
Simulator.Input.OptionList.prototype.constructor = Simulator.Input.OptionList;

// FILE: FieldSet2.js (3ec40e14) 3/7/2014 11:24:14 AM

Simulator.Input.FieldSet = function(sim) {
Simulator.Input.InputElement.call(this, sim);
var dbg = function() { return sim.getDebug(); };
var persistentVarDB = function() { return sim.getPersistentVariableDataBase(); };
var simDocument = function() { return sim.getSimDocument(); };
var defaultValue = 0;
var minValue = 0;
var increment = 0;
var units = '';
var data = '';
var valueModifier = null;
var valueChanged = false;
var selectedValue = -1;
var valueModifierOp = 'add';
var maxValue = 0;
this.getMinValue = function() {
return minValue;
};
this.setMinValue = function(newMinValue) {
minValue = newMinValue;
return this;
};
this.getMaxValue = function() {
return maxValue;
};
this.setMaxValue = function(newMaxValue) {
maxValue = newMaxValue;
return this;
};
this.getDefaultValue = function() {
this.setData(defaultValue);
return defaultValue;
};
this.setDefaultValue = function(newDefaultValue) {
defaultValue = newDefaultValue;
selectedValue = newDefaultValue;
this.setPrevValue(newDefaultValue);
return this;
};
this.recordKeyboardSelection = function(elementID, itemID, itemIndex) {
var element = null;
var item = null;
if(itemID) {
item = simDocument().getElementById(itemID);
if(!item) {
element = simDocument().getElementById(elementID);
if(element) item = element.getElementsByClassName(itemID)[0];
}
if(item) {
item.isSelected = true;
this.setSelectStateViaKeyboard(elementID, itemID);
this.onChange(elementID);
}
}
};
this.setSelectStateViaKeyboard = function(elementID, itemID) {
if(itemID == 'goingUp') incrementValue(elementID, this.getMaxValue(), this.getIncrement());
else if(itemID == 'goingDown') decrementValue(elementID, this.getMaxValue(), this.getIncrement());
};
this.getIncrement = function() {
return increment;
};
this.setIncrement = function(newIncrement) {
increment = newIncrement;
return this;
};
this.getUnits = function() {
return units;
};
this.setUnits = function(newUnits) {
units = newUnits;
return this;
};
this.setData = function(newData) {
data = newData;
};
this.getData = function() {
var dataArray = [];
dataArray[0] = data;
return dataArray;
};
this.saveState = function(indent, preface, nameStr, valStr, suffix) {
if(selectedValue != '') return indent + preface + nameStr + this.getName() + valStr + this.getData() + suffix;
else return '';
};
this.setElementSelectState = function(state, contents) {
var value = parseFloat(contents);
if(value >= this.getMinValue() && value <= this.getMaxValue() && value % this.getIncrement() == 0) {
this.setData(contents);
selectedValue = contents;
setHTMLValue(this.getNodeID(), this.getData());
this.recordInput(this, true);
}
};
this.setValueModifier = function(element) {
valueModifier = element;
};
this.getValueModifier = function() {
return valueModifier;
};
this.setValueModifierOp = function(op) {
valueModifierOp = op;
};
this.getValueModifierOp = function() {
return valueModifierOp;
};
var doModifierOp = function(element, value) {
var modifier = element.getValueModifier();
if(isNaN(modifier)) modifier = persistentVarDB().getElementValue(element.getValueModifier());
if(value == undefined || value == null) logError('ValueModifier ' + modifier + ' for ' + element.getName() + ' is not a number nor in persistentVarDB');
else {
var op = element.getValueModifierOp();
switch(op) {
case 'add': value += modifier;
break;
case 'multiply': value *= modifier;
break;
case 'subtract': value -= modifier;
break;
case 'divide': value /= modifier;
break;
default: dbg().logError(source, 'Value modifer operation "' + op + '" is not defined');
break;
}
}
return value;
};
this.getModifiedValue = function(value) {
if(this.getValueModifier() != null) {
value = doModifierOp(this, value);
}
return value;
};
this.setAttributes = function(attr, node) {
Simulator.Input.FieldSet.prototype.setAttributes.call(this, attr);
for (var i in attr) {
switch (i) {
case 'minValue':
this.setMinValue(attr[i]);
break;
case 'maxValue':
this.setMaxValue(attr[i]);
break;
case 'defaultValue':
this.setDefaultValue(attr[i]);
break;
case 'increment':
this.setIncrement(attr[i]);
break;
case 'units':
this.setUnits(attr[i]);
break;
}
}
};
var setHTMLValue = function(id, value) {
var htmlElement = simDocument().getElementById(id);
if (!htmlElement) htmlElement = simDocument().getElementById(id + 'slider-value');
if (htmlElement) htmlElement.value = value;
};
this.setValueChanged = function(newValueChanged) {
valueChanged = newValueChanged == 'true' || newValueChanged == 'yes' ? true : false;
};
this.getValueChanged = function() {
return valueChanged;
};
this.incrementValue = function(id, maxValue, increment) {
var htmlElement = simDocument().getElementById(id);
currentValue = parseFloat(htmlElement.value);
currentValue = Math.min(currentValue + parseFloat(increment), maxValue);
htmlElement.value = currentValue;
currentValue = this.getModifiedValue(currentValue);
currentValue = currentValue.toString();
this.setData(currentValue);
valueChanged = true;
if(this.getSaveOnChange()) this.onChange(this.getNodeID());
};
this.decrementValue = function(id, minValue, decrement) {
var htmlElement = simDocument().getElementById(id);
currentValue = parseFloat(htmlElement.value);
currentValue = Math.max(currentValue - parseFloat(decrement), minValue);
htmlElement.value = currentValue;
currentValue = this.getModifiedValue(currentValue);
currentValue = currentValue.toString();
this.setData(currentValue);
valueChanged = true;
if(this.getSaveOnChange()) this.onChange(this.getNodeID());
};
this.inspect = function(embedded, forced) {
var buff = [];
var sep = '\n\n';
if (!embedded) {
buff.push('Inspecting ');
buff.push(this.getName());
buff.push(sep);
}
for ( var i in this) {
if (i.substr(0, 3) == 'get') {
buff.push(i);
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
if (!embedded) forced === true ? dbg().debugf(buff.join('')) : dbg().debug(buff.join(''));
else return buff.join('');
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Input.FieldSet.prototype = new Simulator.Input.InputElement();
Simulator.Input.FieldSet.prototype.constructor = Simulator.Input.FieldSet;

// FILE: SimSlider2.js (7b358bac) 5/2/2014 12:55:58 PM

Simulator.Input.SimSlider = function (sim, node, panel, theSection) {
Simulator.Input.FieldSet.call(this, sim);
var that = this;
var source = 'SimSlider';
var instance = this;
var HTMLId = null;
var textAreaId = null;
var sliderBackgroundImage = 'http://yui.yahooapis.com/2.9.0/build/slider/assets/bg-h.gif';
var sliderImage = 'Scripts/Simulator/renderer/Images/slider_thumb.png';
var theSlider = null;
var setValues = [];
var orientation = 'horizontal';
var reportMovement = false;
var startConstraint = 0;
var endConstraint = 210;
var dbg = function () { return sim.getDebug(); };
var utils = function () { return sim.getUtils(); };
var simMgr = function () { return sim.getSimulationManager(); };
var scoringTable = function () { return sim.getScoringTable(); };
var keyboardInput = function () { return sim.getKeyboardInput(); };
var simDocument = function () { return sim.getSimDocument(); };
if (sim) {
this.setPanel(panel);
this.setSection(theSection);
}
this.setHTMLId = function (newHTMLId) {
HTMLId = newHTMLId;
};
this.getHTMLId = function () {
return HTMLId;
};
this.setTextAreaId = function (newTextAreaId) {
textAreaId = newTextAreaId;
};
this.getTextAreaId = function () {
return textAreaId;
};
this.getSetValues = function () {
return setValues;
};
this.setSetValues = function (newSetValues) {
setValues = newSetValues;
return this;
};
this.getSliderBackgroundImage = function () {
return sliderBackgroundImage;
};
this.setSliderBackgroundImage = function (newSliderBackgroundImage) {
sliderBackgroundImage = newSliderBackgroundImage;
return this;
};
this.getSliderImage = function () {
return 'Scripts/Simulator/renderer/Images/slider_thumb.png';
};
this.setSliderImage = function (newSliderImage) {
sliderImage = newSliderImage;
return this;
};
this.getOrientation = function () {
return orientation;
};
this.setOrientation = function (newOrientation) {
orientation = newOrientation;
return this;
};
this.getReportMovement = function () {
return reportMovement;
};
this.setReportMovement = function (newReportMovement) {
reportMovement = newReportMovement == 'yes' ? true : false;
return this;
};
this.handleEvent = function (event) {
switch (event.type) {
case 'inputReq':
this.recordInput(this);
break;
case 'info':
switch (event.context) {
case 'sliderValue':
this.setData(this.getModifiedValue(event.data.toString()));
this.onChange(this.getNodeID());
break;
case 'simulatorStateChange':
break;
}
default:
dbg().logWarning(source, 'Unhandled event type received: ' + event.toString());
return;
}
};
this.keyboardNavigateTo = function (elementID, itemID, index) {
if (this.getTextAreaId()) {
var element = simDocument().getElementById(this.getTextAreaId());
if (element) {
var className = element.getAttribute('class');
className = className + ' ' + 'simAreaFocus';
element.setAttribute('class', className);
element.focus();
}
}
};
this.keyboardNavigateAwayFrom = function (elementID, itemID, index) {
if (this.getTextAreaId()) {
var element = simDocument().getElementById(this.getTextAreaId());
if (element) {
var className = element.getAttribute('class');
var index = className.indexOf('simAreaFocus');
if (index > 0)
className = className.substring(0, index - 1);
element.setAttribute('class', className);
element.blur();
}
}
};
this.recordKeyboardSelection = function (elementID, itemID, itemIndex) {
if ((this.getTextAreaId()) && (theSlider != null)) {
var element = simDocument().getElementById(this.getTextAreaId());
if (element) {
var currentValue = element.value;
if (!isNaN(currentValue)) {
var actualValue = theSlider.jsSlider.getMinValue() - 0;
theSlider.setValue(actualValue + (currentValue / theSlider.scaleFactor));
RecordChange(theSlider);
}
element.blur();
}
}
};
this.disableInput = function () {
var element = simDocument().getElementById(this.getNodeID() + 'sliderHolder');
element.disabled = true;
var txtField = simDocument().getElementById(this.getNodeID() + 'slider-value');
txtField.disabled = true;
this.setState('disabled');
if (this.mySlider) {
this.mySlider.lock();
}
};
this.enableInput = function () {
var element = simDocument().getElementById(this.getNodeID() + 'sliderHolder');
element.disabled = false;
var txtField = simDocument().getElementById(this.getNodeID() + 'slider-value');
txtField.disabled = false;
this.setState('enabled');
if (this.mySlider) {
this.mySlider.unlock();
}
};
this.render = function () {
var panelHtml = panel.getHTMLElement();
var holderDiv = simDocument().createElement('div');
holderDiv.id = this.getNodeID() + 'sliderHolder';
if (this.getOrientation() == 'horizontal') holderDiv.setAttribute('class', 'slider sliderHorizontal');
else holderDiv.setAttribute('class', 'slider sliderVertical');
var label = '';
if (sim.getSpeechEnabled()) {
label = this.getSpeechLabel();
if (!label) {
label = this.getLabel();
if (!label) label = Simulator.Constants.SPEECH_LABEL_PREFIX + label;
else {
label = Section.GetCurrentSectionLabel();
if (!label) label = Simulator.Constants.SPEECH_LABEL_PREFIX + label;
else {
dbg().logFatalError(source, 'Item is speech enabled but no speechLabel, element label, or enclosing section label is specified for ' + this.getName());
return;
}
}
}
}
else {
label = this.getLabel();
if (!label) {
label = ' ';
} else {
label = label + ':';
}
}
var labelElem = simDocument().createElement('span');
labelElem.innerHTML = label;
var txtAreaDiv = simDocument().createElement('div');
txtAreaDiv.setAttribute('class', 'slider-label-area'); ;
var txtAreaInput = simDocument().createElement('input');
txtAreaInput.id = this.getNodeID() + 'slider-value';
this.txtAreaId = txtAreaInput.id;
this.setTextAreaId(txtAreaInput.id);
txtAreaInput.type = 'text';
txtAreaInput.size = utils().getNumberLength(this.getMaxValue());
txtAreaInput.maxlength = txtAreaInput.size;
txtAreaInput.autocomplete = 'off';
txtAreaInput.value = this.getDefaultValue();
txtAreaInput.setAttribute('class', 'slider-text-area');
utils().bindEvent(txtAreaInput, 'change', function () {
var currentValue = txtAreaInput.value;
if (!isNaN(currentValue)) {
var actualValue = theSlider.jsSlider.getMinValue() - 0;
theSlider.setValue(actualValue + Math.round(currentValue / theSlider.scaleFactor));
RecordChange(theSlider);
}
});
utils().bindEvent(txtAreaInput, 'keypress', function (event) {
var key = event.keyCode;
if (key == 13) {
var currentValue = txtAreaInput.value;
if (!isNaN(currentValue)) {
var actualValue = theSlider.jsSlider.getMinValue() - 0;
theSlider.setValue(actualValue + Math.round(currentValue / theSlider.scaleFactor));
RecordChange(theSlider);
}
} else {
var validKey = that.onKeyPressHandler(event);
if (!validKey) {
if (event.preventDefault) {
event.preventDefault();
} else {
event.returnValue = false;
}
}
}
});
var txtAreaUM = null;
if (this.getUnits()) {
txtAreaUM = simDocument().createElement('label');
txtAreaUM.setAttribute('for', txtAreaInput.id);
txtAreaUM.innerHTML = this.getUnits();
}
if (this.isFocusable()) keyboardInput().addFocusableElementItem(this, this.getNodeID(), txtAreaInput.id);
var minMaxDiv = simDocument().createElement('div');
minMaxDiv.setAttribute('class', 'slider-min-max');
var minValSpan = simDocument().createElement('span');
minMaxDiv.appendChild(minValSpan);
minValSpan.innerHTML = this.getMinValue() + '  ';
minValSpan.setAttribute('class', 'yui-slider-min');
var maxValSpan = simDocument().createElement('span');
minMaxDiv.appendChild(maxValSpan);
maxValSpan.setAttribute('class', 'yui-slider-max');
maxValSpan.innerHTML = '  ' + this.getMaxValue();
var image = this.getImage();
var imageDiv = null;
if (image != null && image != undefined) {
imageDiv = simDocument().createElement('div');
imageDiv.setAttribute('class', 'slider withImages');
imageDiv.setAttribute('id', this.getName());
var imageHolder = simDocument().createElement('span');
imageHolder.setAttribute('class', 'holderImage');
var imageElement = simDocument().createElement('img');
imageElement.setAttribute('src', image);
imageHolder.appendChild(imageElement);
imageDiv.appendChild(imageHolder);
}
var bgDivId = this.getNodeID() + 'DivBG';
var sliderDiv = simDocument().createElement('div');
sliderDiv.id = bgDivId;
sliderDiv.setAttribute('class', 'yui-h-slider');
sliderDiv.tabindex = '-1';
sliderDiv.title = 'Slider';
this.setHTMLId(sliderDiv.id);
var sliderThumbDiv = simDocument().createElement('div');
var thumbDivId = this.getNodeID() + 'ThumbDiv';
sliderThumbDiv.id = thumbDivId;
sliderThumbDiv.setAttribute("class", "yui-slider-thumb");
sliderThumbDiv.setAttribute('class', 'yui-slider-thumb');
panelHtml.appendChild(holderDiv);
txtAreaDiv.appendChild(labelElem);
txtAreaDiv.appendChild(txtAreaInput);
if (txtAreaUM) {
txtAreaDiv.appendChild(txtAreaUM);
}
sliderDiv.appendChild(sliderThumbDiv);
holderDiv.appendChild(txtAreaDiv);
holderDiv.appendChild(minMaxDiv);
holderDiv.appendChild(sliderDiv);
if (imageDiv != null) {
holderDiv.appendChild(imageDiv);
}
this.sliderDiv = sliderDiv.id;
this.sliderThumbDiv = sliderThumbDiv.id;
this.startConstraint = startConstraint;
this.endConstraint = endConstraint;
this.sliderDivId = sliderDiv.id;
this.sliderThumbDivId = sliderThumbDiv.id;
sim.getSliderPreRenderQueue().add(this);
this.recordInput(this, true);
this.setPrevValue(this.getDefaultValue());
this.mapHTML2JS(holderDiv);
};
this.onKeyPressHandler = function (event) {
var char = null, match = null;
if (event.which == null) {
char = String.fromCharCode(event.keyCode);
}
else if (event.which != 0 && event.charCode != 0) {
char = String.fromCharCode(event.which);
}
else {
return true;
}
match = char.match(/[0-9]/);
return !!match;
};
this.getHTMLElement = function (id) {
return simDocument().getElementById(this.getNodeID() + 'DivBG');
};
this.getHTMLSlider = function () {
return theSlider;
};
this.setFocusable(true, true);
this.postContainerRender = function () {
var inc = this.getIncrement();
var scaleFactor = (this.getMaxValue() - this.getMinValue()) / endConstraint;
inc = inc / scaleFactor;
this.scaleFactor = scaleFactor;
if (this.getOrientation() == 'horizontal') {
theSlider = YAHOO.widget.Slider.getHorizSlider(this.sliderDivId,
this.sliderThumbDivId, startConstraint, endConstraint, inc);
} else {
theSlider = YAHOO.widget.Slider.getVertSlider(this.sliderDivId,
this.sliderThumbDivId, startConstraint, endConstraint, inc);
}
this.mySlider = theSlider;
this.prevValue = this.getDefaultValue();
theSlider.setValue(Math.abs(this.getDefaultValue() - this.getMinValue()) / scaleFactor, false, true, true);
theSlider.valTxtField = this.txtAreaInput;
theSlider.jsSlider = this;
theSlider.scaleFactor = this.scaleFactor;
theSlider.subscribe('change', function () { RecordChange(theSlider); });
theSlider.subscribe('slideEnd', function () { SliderEnd(theSlider); });
theSlider.animate = false;
var id = this.txtAreaId;
var node = simDocument().getElementById(id);
node.value = this.getDefaultValue();
};
this.setAttributes = function (attr, node) {
if (node) attr = utils().getAttributes(node);
Simulator.Input.SimSlider.prototype.setAttributes.call(this, attr, node);
for (var i in attr) {
switch (i) {
case 'orientation':
this.setOrientation(attr[i]);
break;
case 'sliderBackgroundImage':
this.setSliderBackgroundImage(attr[i]);
break;
case 'sliderImage':
this.setSliderImage(attr[i]);
break;
case 'imagePath':
this.setSliderImagePath(attr[i]);
break;
case 'multModifier':
this.setMultModifier(attr[i]);
break;
case 'addModifier':
this.setAddModifier(attr[i]);
break;
case 'valueModifier':
this.setValueModifier(attr[i]);
break;
case 'reportMovement':
this.setReportMovement(attr[i]);
break;
}
}
if (this.getScoreable()) scoringTable().addElement(this.getName(), 'input');
};
this.getSourceName = function () {
return source;
};
this.inspect = function (embedded, force) {
var buff = [];
var sep = '\n\n';
if (!embedded) {
buff.push('Inspecting ');
buff.push(this.getName());
buff.push(sep);
}
for (var i in this) {
if (i.substr(0, 3) == 'get') {
buff.push(i);
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
if (!embedded) (force === null) ? debug(buff.join('')) : debugf(buff.join(''));
return buff.join('');
};
var SSFixRoundError = function (val, inc) {
if (inc) {
var rem = val % inc;
if (rem) {
val = val + (inc - rem);
}
}
return val;
};
var RecordChange = function (slider) {
var jsSlider = slider.jsSlider;
var actualValue = Math.round(slider.getValue());
actualValue = actualValue * slider.scaleFactor;
if (actualValue < 0)
actualValue = 0;
var offset = jsSlider.getMinValue() - 0;
actualValue = actualValue + offset;
actualValue = SSFixRoundError(actualValue, jsSlider.getIncrement());
var id = jsSlider.txtAreaId;
var node = simDocument().getElementById(id);
node.value = actualValue;
if (jsSlider.getReportMovement()) {
jsSlider.setData(actualValue);
jsSlider.recordInput(jsSlider);
instance.onChange(jsSlider.getNodeID());
}
};
var SliderEnd = function (slider) {
var jsSlider = slider.jsSlider;
var actualValue = Math.round(slider.getValue() * slider.scaleFactor);
if (actualValue < 0)
actualValue = 0;
var offset = slider.jsSlider.getMinValue() - 0;
actualValue = actualValue + offset;
actualValue = SSFixRoundError(actualValue, jsSlider.getIncrement());
var id = jsSlider.txtAreaId;
var node = simDocument().getElementById(id);
node.value = actualValue;
if (jsSlider.prevValue != actualValue) {
jsSlider.setData(jsSlider.getModifiedValue(actualValue) + '');
jsSlider.recordInput(jsSlider);
instance.onChange(jsSlider.getNodeID());
jsSlider.prevValue = actualValue;
}
};
this.setElementSelectState = function(state, contents) {
var value = parseFloat(contents);
if(value >= this.getMinValue() && value <= this.getMaxValue() && value % this.getIncrement() == 0) {
this.setData(contents);
this.setDefaultValue(contents);
setHTMLValue(this.getNodeID(), this.getData());
this.recordInput(this, true);
}
};
var setHTMLValue = function(id, value) {
var htmlElement = simDocument().getElementById(id);
if (!htmlElement) htmlElement = simDocument().getElementById(id + 'slider-value');
if (htmlElement) htmlElement.value = value;
if (!isNaN(value)) {
var actualValue = theSlider.jsSlider.getMinValue() - 0;
theSlider.setValue(actualValue + Math.round(value / theSlider.scaleFactor));
RecordChange(theSlider);
}
};
var debug = function (str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
};
var debugf = function (str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
};
}
Simulator.Input.SimSlider.prototype = new Simulator.Input.FieldSet();
Simulator.Input.SimSlider.parent = Simulator.Input.FieldSet;
Simulator.Input.SimSlider.prototype.constructor = Simulator.Input.SimSlider;

// FILE: TextField2.js (61cfa967) 3/7/2014 11:24:14 AM

Simulator.Input.TextField = function(sim, node, panel, theSection) {
Simulator.Input.InputElement.call(this, sim);
var that = this;
var source = 'TextField';
var userEditable = true;
var prevStyle = {};
var displayLabel = true;
var text = '';
var typeInputAllowed = 'textOnly';
var fieldLength = 7;
var textCache = '';
var dbg = function() { return sim.getDebug(); };
var utils = function() { return sim.getUtils(); };
var eventMgr = function () { return sim.getEventManager(); };
var simDocument = function () { return sim.getSimDocument(); };
var keyboardInput = function () { return sim.getKeyboardInput(); };
var scoringTable = function () { return sim.getScoringTable(); };
if(sim) {
this.setPanel(panel);
this.setSection(theSection);
}
eventMgr().registerEvent(new Simulator.Event(this, 'info', 'animationThreadFinished'), 'to');
this.getUserEditable = function () {
return userEditable;
};
this.setUserEditable = function (newUserEditable) {
userEditable = newUserEditable == 'yes' ? true : false;
return this;
};
this.getDisplayLabel = function () {
return displayLabel;
};
this.setDisplayLabel = function (newDisplayLabel) {
displayLabel = newDisplayLabel == 'yes' ? true : false;
return this;
};
this.getText = function () {
return text;
};
this.setText = function (newText) {
text = newText;
this.setData(newText);
return this;
};
this.setTypeInputAllowed = function (typeInput) {
typeInputAllowed = typeInput;
};
this.getTypeInputAllowed = function () {
return typeInputAllowed;
};
this.getFieldLength = function () {
return fieldLength;
};
this.setFieldLength = function (newLength) {
fieldLength = parseInt(newLength);
return this;
};
this.saveState = function (indent, preface, nameStr, valStr, suffix) {
var data = this.getData();
if (data != '') return indent + preface + nameStr + this.getName() + valStr + data + suffix;
else return '';
};
this.setElementSelectState = function (state, contents) {
this.setData(contents);
this.recordInput(this, true);
};
this.disableInput = function () {
var element = simDocument().getElementById(this.getNodeID());
element.disabled = true;
this.setState('disabled');
};
this.enableInput = function () {
var element = simDocument().getElementById(this.getNodeID());
element.disabled = false;
this.setState('enabled');
};
this.setTextCache = function (cacheText) {
textCache = cacheText;
};
this.handleEvent = function (event) {
switch (event.type) {
case 'inputReq':
this.recordInput(this);
break;
case 'info':
switch (event.context) {
case 'simulatorStateChange':
break;
case 'animationThreadFinished':
this.setData(textCache);
this.recordInput();
textCache = '';
eventMgr().postEvent(new Simulator.Event(this, 'info', 'inputAvailable'));
break;
}
break;
default:
dbg().logWarning(source, 'Unhandled event type received: ' + event.toString());
return;
}
};
this.keyboardNavigateTo = function (elementID, itemID, index) {
var element = simDocument().getElementById(elementID);
if (element) {
prevStyle.color = element.style.borderColor;
prevStyle.width = element.style.borderWidth;
prevStyle.style = element.style.borderStyle;
element.style.borderStyle = 'solid';
element.style.borderWidth = '2px';
element.style.borderColor = '#FF9100';
}
element.focus();
};
this.keyboardNavigateAwayFrom = function (elementID, itemID, index) {
var element = simDocument().getElementById(elementID);
if (element) {
element.style.borderStyle = prevStyle.style;
element.style.borderWidth = prevStyle.width;
element.style.borderColor = prevStyle.color;
element.blur();
}
};
this.recordKeyboardSelection = function (elementID, itemID, itemIndex) {
var element = null;
element = simDocument().getElementById(elementID);
if (element) {
element.style.borderStyle = prevStyle.style;
element.style.borderWidth = prevStyle.width;
element.style.borderColor = prevStyle.color;
element.isSelected = true;
this.setSelectStateViaKeyboard(elementID, itemID);
this.onChange(elementID);
element.blur();
}
};
this.setAttributes = function (attr, node) {
if (node) attr = utils().getAttributes(node);
Simulator.Input.TextField.prototype.setAttributes.call(this, attr, node);
for ( var i in attr) {
try {
switch (i) {
case 'initialText':
this.setText(attr[i]);
break;
case 'userEditable':
this.setUserEditable(attr[i]);
break;
case 'displayLabel':
this.setDisplayLabel(attr[i]);
break;
case 'fieldLength':
this.setFieldLength(attr[i]);
break;
case 'typeInputAllowed':
this.setTypeInputAllowed(attr[i]);
break;
}
} catch(err) {
dbg().logError(source, 'Error occurred getting TextField attribute ' + i + ': ' + err.message);
}
}
if(this.getScoreable()) {
sim.getScoringTable().addElement(this.getName(), 'input');
}
};
this.render = function() {
var nodeID = this.getNodeID();
var panelHtml = panel.getHTMLElement();
var brElement1 = simDocument().createElement('br');
panelHtml.appendChild(brElement1);
var brElement2 = simDocument().createElement('br');
panelHtml.appendChild(brElement2);
var divElement = simDocument().createElement('div');
divElement.setAttribute('class', 'textFieldWrapper withImages');
var image = this.getImage();
if (image != null && image != undefined) {
var spanElement1 = simDocument().createElement('span');
spanElement1.setAttribute('class', 'holderImage');
var imgElement = simDocument().createElement('img');
imgElement.setAttribute('src', image);
imgElement.setAttribute('alt', this.getName());
spanElement1.appendChild(imgElement);
divElement.appendChild(spanElement1);
}
var spanElement2 = simDocument().createElement('span');
spanElement2.setAttribute('class', 'textFieldContainer');
spanElement2.innerHTML = this.getLabel();
var inputEl = simDocument().createElement('input');
inputEl.setAttribute('type', 'text');
inputEl.id = nodeID;
inputEl.setAttribute('value', this.getText());
inputEl.onkeydown = 'return false;';
utils().bindEvent(inputEl, 'keypress', function (event) {
var validKey = that.onKeyPressHandler(nodeID, event);
if (!validKey) {
if (event.preventDefault) {
event.preventDefault();
} else {
event.returnValue = false;
}
}
});
utils().bindEvent(inputEl, 'change', function () {
that.changeInValue(nodeID);
});
inputEl.setAttribute('size', this.getFieldLength());
inputEl.setAttribute('maxlength', this.getFieldLength());
spanElement2.appendChild(inputEl);
divElement.appendChild(spanElement2);
panelHtml.appendChild(divElement);
this.recordInput(this, true);
this.setFocusable(true, true);
if(this.isFocusable()) {
keyboardInput().addFocusableElementItem(this, nodeID);
}
this.mapHTML2JS(divElement);
};
this.changeInValue = function(id) {
if(id) {
var htmlElement = simDocument().getElementById(id);
this.setData(htmlElement.value);
this.recordInput();
eventMgr().postEvent(new Simulator.Event(this, 'info', 'inputAvailable', null, false));
}
};
var numLockKeyCode = 144;
var numLockPressed = false;
this.onKeyPressHandler = function (id, event) {
var char = null, match = null;
if (event.which == null) {
char = String.fromCharCode(event.keyCode);
}
else if (event.which != 0 && event.charCode != 0) {
char = String.fromCharCode(event.which);
}
else {
return true;
}
switch(this.getTypeInputAllowed()) {
case 'alphaOnly':
match = char.match(/[a-z\.]/i);
return !!match;
break;
case 'numericOnly':
match = char.match(/[0-9\.\+\-]/);
return !!match;
break;
case 'alphaNumericOnly':
match = char.match(/[a-z0-9\.\+\-]/i);
return !!match;
break;
case 'textOnly':
return true;
break;
default:
return true;
break;
}
};
this.getSourceName = function() {
return source;
};
this.inspect = function(embedded, force) {
var buff = [];
var sep = '\n\n';
if (!embedded) {
buff.push('Inspecting ');
buff.push(this.getName());
buff.push(sep);
}
for ( var i in this) {
if (i.substr(0, 3) == 'get') {
buff.push(i);
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
if (!embedded) (force === null) ? debug(buff.join('')) : debugf(buff.join(''));
return buff.join('');
};
var debug = function(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
};
var debugf = function(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
};
};
Simulator.Input.TextField.prototype = new Simulator.Input.InputElement();
Simulator.Input.TextField.parent = Simulator.Input.InputElement;
Simulator.Input.TextField.prototype.constructor = Simulator.Input.TextField;

// FILE: StaticElement2.js (5438e893) 3/7/2014 11:24:14 AM

Simulator.Input.StaticElement = function (sim) {
Simulator.SimElement.call(this, sim);
var panel = null;
var section = null;
this.getPanel = function() {
return panel;
};
this.setPanel = function(newPanel) {
panel = newPanel;
return this;
};
this.setSection = function(theSection) {
section = theSection;
};
this.saveState = function(indent, preface, nameStr, valStr, suffix) {
return indent + preface + nameStr + this.getName() + valStr + checkedItems + suffix;
};
};
Simulator.Input.StaticElement.prototype = new Simulator.SimElement();
Simulator.Input.StaticElement.parent = Simulator.SimElement;
Simulator.Input.StaticElement.prototype.constructor = Simulator.Input.StaticElement;

// FILE: VerticalSpace2.js (49ece0f8) 3/7/2014 11:24:14 AM

Simulator.Input.VerticalSpace = function (sim, panel, theSection) {
Simulator.Input.StaticElement.call(this, sim);
var source = 'VerticalSpace';
var lines = 0;
var dbg = function () { return sim.getDebug(); };
var utils = function() { return sim.getUtils(); };
var simDocument = function() { return sim.getSimDocument(); };
if(sim) {
this.setPanel(panel);
this.setSection(theSection);
}
this.setLines = function(newLines) {
lines = parseInt(newLines);
};
this.getLines = function() {
return lines;
};
this.setAttributes = function (attr, node) {
if (node) attr = utils().getAttributes(node);
Simulator.Input.VerticalSpace.prototype.setAttributes(attr);
for (var i in attr) {
switch (i) {
case 'lines':
this.setLines(attr[i]);
break;
}
}
};
this.render = function () {
var panelHtml = panel.getHTMLElement();
var divElement = simDocument().createElement('div');
divElement.style.paddingBottom = 20 * this.getLines() + 'px';
panelHtml.appendChild(divElement);
this.setFocusable(false);
this.mapHTML2JS(divElement);
};
this.getSourceName = function() {
return source;
};
this.inspect = function (embedded, force) {
var buff = [];
var sep = '\n\n';
if (!embedded) {
buff.push('Inspecting ');
buff.push(this.getName());
buff.push(sep);
}
for (var i in this) {
if (i.substr(0, 3) == 'get') {
buff.push(i);
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
if (!embedded) (force === null) ? debug(buff.join('')) : debugf(buff.join(''));
return buff.join('');
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Input.VerticalSpace.prototype = new Simulator.Input.StaticElement();
Simulator.Input.VerticalSpace.parent = Simulator.Input.StaticElement;
Simulator.Input.VerticalSpace.prototype.constructor = Simulator.Input.VerticalSpace;

// FILE: HorizontalLine2.js (85ef7e6d) 3/7/2014 11:24:14 AM

Simulator.Input.HorizontalLine = function (sim, panel, theSection) {
Simulator.Input.StaticElement.call(this, sim);
var source = 'HorizontalLine';
var dbg = function () { return sim.getDebug(); };
var utils = function () { return sim.getUtils(); };
var simDocument = function () { return sim.getSimDocument(); };
if (sim) {
this.setPanel(panel);
this.setSection(theSection);
}
var height = 0;
this.setHeight = function (newHeight) {
height = parseInt(newHeight);
};
this.getHeight = function () {
return height;
};
var width = 1;
this.setWidth = function (newWidth) {
width = parseInt(newWidth);
};
this.getWidth = function () {
return width;
};
var alignment = 'absolute';
this.setAlignment = function (newAlignment) {
alignment = newAlignment;
};
this.getAlignment = function () {
return alignment;
};
var distance = 0;
this.setDistance = function (newDistance) {
distance = newDistance;
};
this.getDistance = function () {
return distance;
};
var ownSpace = true;
this.setOwnSpace = function (newOwnSpace) {
ownSpace = newOwnSpace == 'yes' ? true : false;
};
this.getOwnSpace = function () {
return ownSpace;
};
this.setAttributes = function (attr, node) {
if (node) attr = utils().getAttributes(node);
Simulator.Input.HorizontalLine.prototype.setAttributes(attr);
for (var i in attr) {
switch (i) {
case 'name':
this.setName(attr[i]);
break;
case 'width':
this.setWidth(attr[i]);
break;
case 'height':
this.setHeight(attr[i]);
break;
case 'alignment':
this.setAlignment(attr[i]);
break;
case 'distance':
this.setDistance(attr[i]);
break;
case 'ownSpace':
this.setOwnSpace(attr[i]);
break;
}
}
};
this.render = function () {
var panelHtml = panel.getHTMLElement();
spanElement = simDocument().createElement('span');
spanElement.id = 'horizontalLine';
if (this.getAlignment() == 'left') {
spanElement.setAttribute('class', 'sim_divider sim_divider_left');
if (this.getDistance() != null) spanElement.style.marginLeft = this.getDistance() + 'px';
} else if (this.getAlignment() == 'right') {
spanElement.setAttribute('class', 'sim_divider sim_divider_right');
if (this.getDistance() != null) spanElement.style.marginRight = this.getDistance() + 'px';
} else {
spanElement.setAttribute('class', 'sim_divider sim_divider_center');
}
if (this.getWidth() != null) spanElement.style.width = this.getWidth() + "px";
if (this.getHeight() != null) spanElement.style.height = this.getHeight() + "px";
if (this.getOwnSpace()) spanElement.style.clear = 'both';
panelHtml.appendChild(spanElement);
this.setFocusable(false);
this.mapHTML2JS(spanElement);
};
this.getSourceName = function () {
return source;
};
this.inspect = function (embedded, force) {
var buff = [];
var sep = '\n\n';
if (!embedded) {
buff.push('Inspecting ');
buff.push(this.getName());
buff.push(sep);
}
for (var i in this) {
if (i.substr(0, 3) == 'get') {
buff.push(i);
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
if (!embedded) (force == null) ? debug(buff.join('')) : debugf(buff.join(''));
return buff.join('');
}
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
}
Simulator.Input.HorizontalLine.prototype = new Simulator.Input.StaticElement();
Simulator.Input.HorizontalLine.parent = Simulator.Input.StaticElement;
Simulator.Input.HorizontalLine.prototype.constructor = Simulator.Input.HorizontalLine;

// FILE: SectionDivider2.js (3355d9e6) 3/7/2014 11:24:14 AM

Simulator.Input.SectionDivider = function (sim, panel, theSection) {
Simulator.Input.StaticElement.call(this, sim);
var source = 'SectionDivider';
var dbg = function () { return sim.getDebug(); };
var utils = function () { return sim.getUtils(); };
var simDocument = function () { return sim.getSimDocument(); };
if (sim) {
this.setPanel(panel);
this.setSection(theSection);
}
this.setAttributes = function (attr, node) {
if (node) attr = utils().getAttributes(node);
Simulator.Input.SectionDivider.prototype.setAttributes(attr);
for (var i in attr) {
switch (i) {
case 'name':
this.setName(attr[i]);
break;
}
}
};
this.render = function () {
var panelHtml = panel.getHTMLElement();
divElement = simDocument().createElement('div');
divElement.id = 'hrHolder';
divElement.setAttribute('class', 'hrHolder');
var hrElement = simDocument().createElement('hr');
divElement.appendChild(hrElement);
panelHtml.appendChild(divElement);
this.setFocusable(false);
this.mapHTML2JS(divElement);
};
this.getSourceName = function () {
return source;
};
this.inspect = function (embedded, force) {
var buff = [];
var sep = '\n\n';
if (!embedded) {
buff.push('Inspecting ');
buff.push(this.getName());
buff.push(sep);
}
for (var i in this) {
if (i.substr(0, 3) == 'get') {
buff.push(i);
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
if (!embedded) (force == null) ? debug(buff.join('')) : debugf(buff.join(''));
return buff.join('');
}
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
}
Simulator.Input.SectionDivider.prototype = new Simulator.Input.StaticElement();
Simulator.Input.SectionDivider.parent = Simulator.Input.StaticElement;
Simulator.Input.SectionDivider.prototype.constructor = Simulator.Input.SectionDivider;

// FILE: UpDownCounter2.js (7fffd835) 3/7/2014 11:24:14 AM

Simulator.Input.UpDownCounter = function (sim, node, panel, theSection) {
Simulator.Input.FieldSet.call(this, sim);
var that = this;
var source = 'UpDownCounter';
var setValues = [];
var interButtonDelay = true;
var interButtonDelay = true;
var setValues = [];
var actOnChangeWithMouseout = false;
var dbg = function () { return sim.getDebug(); };
var utils = function () { return sim.getUtils(); };
var simDocument = function () { return sim.getSimDocument(); };
var scoringTable = function () { return sim.getScoringTable(); };
var keyboardInput = function () { return sim.getKeyboardInput(); };
if (sim) {
this.setPanel(panel);
this.setSection(theSection);
}
this.getSetValues = function () {
return setValues;
};
this.setsetValues = function (newsetValues) {
setValues = newsetValues;
return this;
};
this.setInterButtonDelay = function (newInterButtonDelay) {
interButtonDelay = newInterButtonDelay == true || newInterButtonDelay == 'yes' ? true : false;
return this;
};
this.getInterButtonDelay = function () {
return interButtonDelay;
};
this.handleEvent = function (event) {
switch (event.type) {
case 'inputReq':
this.recordInput(this);
break;
case 'info':
switch (event.context) {
case 'simulatorStateChange':
break;
}
break;
default:
dbg().logWarning(source, 'Unhandled event type received: ' + event.toString());
return;
}
};
this.setActOnChangeWithMouseout = function (newActOnChangeWithMouseout) {
actOnChangeWithMouseout = newActOnChangeWithMouseout == 'yes' ? true : false;
};
this.getActOnChangeWithMouseout = function () {
return actOnChangeWithMouseout;
};
this.keyboardNavigateTo = function (elementID, itemID, index) {
var element = simDocument().getElementsByClassName(elementID)[0];
var item = element.getElementsByClassName(itemID)[0];
if (item) item.setAttribute('class', itemID + ' simAreaFocus');
};
this.keyboardNavigateAwayFrom = function (elementID, itemID, index) {
var element = simDocument().getElementsByClassName(elementID)[0];
var item = element.getElementsByClassName(itemID)[0];
if (item) item.setAttribute('class', itemID);
};
this.recordKeyboardSelection = function (elementID, itemID, itemIndex) {
if ((itemID) && (elementID)) {
if (itemIndex == 0) {
this.incrementValue(this.getNodeID(), this.getMaxValue(), this.getIncrement());
}
else if (itemIndex == 1) {
this.decrementValue(this.getNodeID(), this.getMinValue(), this.getIncrement());
}
}
};
this.receivedSpeechFocus = function () {
debug(this.getName() + ' received speech focus');
var node = simDocument().getElementById('incrementalWrapper' + this.getNodeID());
node.style.border = 'thin solid #ff0000';
};
this.removeSpeechFocus = function (value) {
debug(this.getName() + ' lost speech focus');
var node = simDocument().getElementById('incrementalWrapper' + this.getNodeID());
prevBorders = node.borders;
node.style.border = 'none';
};
this.disableInput = function () {
var component = simDocument().getElementById('goingUp' + this.getNodeID());
component.disabled = true;
component = simDocument().getElementById('goingDown' + this.getNodeID());
component.disabled = true;
};
this.enableInput = function () {
var component = simDocument().getElementById('goingUp' + this.getNodeID());
component.disabled = false;
component = simDocument().getElementById('goingDown' + this.getNodeID());
component.disabled = false;
};
this.speechActivated = function (value) {
if (value == 1) this.incrementValue(this.getNodeID(), parseFloat(this.getMaxValue()), parseFloat(this.getIncrement()));
else if (value == -1) this.decrementValue(this.getNodeID(), this.getMinValue(), this.getIncrement());
this.onChange(this.getNodeID());
};
this.setAttributes = function (attr, node) {
if (node) attr = utils().getAttributes(node);
Simulator.Input.UpDownCounter.prototype.setAttributes.call(this, attr, node);
for (var i in attr) {
switch (i) {
case 'actOnChange':
this.setActOnChange(attr[i]);
break;
case 'actOnChangeWithMouseout':
this.setActOnChangeWithMouseout(attr[i]);
break;
case 'interButtonDelay':
this.setInterButtonDelay(attr[i]);
break;
case 'multModifier':
this.setMultModifier(attr[i]);
break;
case 'addModifier':
this.setAddModifier(attr[i]);
break;
}
}
if (this.getScoreable()) scoringTable().addElement(this.getName(), 'input');
};
this.render = function () {
var nodeID = this.getNodeID();
var panelHtml = panel.getHTMLElement();
this.setFocusable(true, true);
var nextNum = utils().getNextSequenceNumber();
var image = this.getImage();
if (this.getSpaceAbove()) {
utils().appendBlankVertcalSpace(panelHtml, this.getSpaceAbove);
}
var needtoShowLabelBelow = false;
needtoShowLabelBelow = true;
var divElement = null;
if (image != null && image != undefined) {
divElement = simDocument().createElement('div');
divElement.id = 'incrementalWrapper' + nodeID;
divElement.setAttribute('class', 'incrementalWrapper withImages');
var spanElement = simDocument().createElement('span');
spanElement.setAttribute('class', 'holderImage');
var imageElement = simDocument().createElement('img');
imageElement.setAttribute('src', image);
imageElement.setAttribute('alt', this.getName());
spanElement.appendChild(imageElement);
divElement.appendChild(spanElement);
}
else {
divElement = simDocument().createElement('div');
divElement.id = 'incrementalWrapper' + nodeID;
divElement.setAttribute('class', 'incrementalWrapper');
if (sim.getSpeechEnabled()) {
divElement.setAttribute('style', 'padding-bottom: 40px');
}
}
var containerSpanElement = simDocument().createElement('span');
containerSpanElement.setAttribute('class', 'incrementalContainer');
var inputElement = simDocument().createElement('input');
inputElement.id = nodeID;
inputElement.setAttribute('readonly', 'readonly');
inputElement.setAttribute('name', 'number' + nodeID);
inputElement.setAttribute('value', this.getDefaultValue());
inputElement.setAttribute('type', 'text');
containerSpanElement.appendChild(inputElement);
var labelElement = simDocument().createElement('label');
labelElement.setAttribute('for', nextNum);
labelElement.innerHTML = this.getUnits();
containerSpanElement.appendChild(labelElement);
var upDownSpanElement = simDocument().createElement('span');
upDownSpanElement.setAttribute('class', 'upDown');
var inputGoingUpElement = simDocument().createElement('input');
inputGoingUpElement.id = 'goingUp' + nodeID;
inputGoingUpElement.setAttribute('class', 'goingUp');
utils().bindEvent(inputGoingUpElement, 'click', function () {
that.incrementValue(nodeID, that.getMaxValue(), that.getIncrement());
});
if (this.getActOnChangeWithMouseout()) {
utils().bindEvent(inputGoingUpElement, 'mouseout', function () {
that.PotentialChangeInValue(nodeID);
});
if (this.getInterButtonDelay()) {
utils().bindEvent(inputGoingUpElement, 'mouseover', function () {
that.CancelNoChange(nodeID);
});
}
}
inputGoingUpElement.setAttribute('type', 'button');
upDownSpanElement.appendChild(inputGoingUpElement);
if (sim.getSpeechEnabled()) {
var textLabelElement1 = simDocument().createTextNode(' Increment');
upDownSpanElement.appendChild(textLabelElement1);
}
var inputGoingDownElement = simDocument().createElement('input');
inputGoingDownElement.id = 'goingDown' + nodeID;
inputGoingDownElement.setAttribute('class', 'goingDown');
utils().bindEvent(inputGoingDownElement, 'click', function () {
that.decrementValue(nodeID, that.getMinValue(), that.getIncrement());
});
if (this.getActOnChangeWithMouseout()) {
utils().bindEvent(inputGoingDownElement, 'mouseout', function () {
that.PotentialChangeInValue(nodeID);
});
if (this.getInterButtonDelay()) {
utils().bindEvent(inputGoingDownElement, 'mouseover', function () {
that.CancelNoChange(nodeID);
});
}
}
inputGoingDownElement.setAttribute('type', 'button');
upDownSpanElement.appendChild(inputGoingDownElement);
if (sim.getSpeechEnabled()) {
var textLabelElement2 = simDocument().createTextNode(' Decrement');
upDownSpanElement.appendChild(textLabelElement2);
}
containerSpanElement.appendChild(upDownSpanElement);
divElement.appendChild(containerSpanElement);
panelHtml.appendChild(divElement);
if (needtoShowLabelBelow) {
var textLabelElement3 = simDocument().createTextNode(this.getLabel());
divElement.appendChild(textLabelElement3);
}
if (this.isFocusable()) {
keyboardInput().addFocusableElementItem(this, 'upDown', 'goingUp');
keyboardInput().addFocusableElementItem(this, 'upDown', 'goingUp');
}
if (this.getSpaceBelow()) {
utils().appendBlankVertcalSpace(panelHtml, this.getSpaceBelow());
}
this.recordInput(this, true);
this.setPrevValue(this.getDefaultValue());
this.mapHTML2JS(divElement);
};
var theCounterID = null;
var prevCounterID = null;
var movementInterval = 50;
var t = null;
this.PotentialChangeInValue = function (id) {
var element = simDocument().getElementById(id);
prevCounterID = theCounterID == null ? id : theCounterID;
theCounterID = id;
if (this.getInterButtonDelay()) {
t = setTimeout(function () { that.ChangeInValue(); }, movementInterval);
} else this.ChangeInValue();
};
this.CancelNoChange = function () {
if (theCounterID == prevCounterID) clearTimeout(t);
};
this.ChangeInValue = function () {
if (theCounterID) {
var htmlElement = simDocument().getElementById(theCounterID);
if (this.getPrevValue() != htmlElement.value) {
this.setPrevValue(this.getData());
this.onChange(theCounterID);
}
theCounterID = null;
}
};
this.incrementValue = function (id, maxValue, increment) {
var htmlElement = simDocument().getElementById(id);
currentValue = parseFloat(htmlElement.value);
if ((currentValue + parseFloat(increment)) <= maxValue) {
currentValue = parseFloat((currentValue + parseFloat(increment)).toFixed(10));
}
htmlElement.value = currentValue;
currentValue = this.getModifiedValue(currentValue);
currentValue = currentValue.toString();
this.setData(currentValue);
valueChanged = true;
if (this.getSaveOnChange()) this.onChange(this.getNodeID());
};
this.decrementValue = function (id, minValue, decrement) {
var htmlElement = simDocument().getElementById(id);
currentValue = parseFloat(htmlElement.value);
if ((currentValue - parseFloat(decrement)) >= minValue) {
currentValue = parseFloat((currentValue - parseFloat(decrement)).toFixed(10));
}
htmlElement.value = currentValue;
currentValue = this.getModifiedValue(currentValue);
currentValue = currentValue.toString();
this.setData(currentValue);
valueChanged = true;
if (this.getSaveOnChange()) this.onChange(this.getNodeID());
};
this.getSourceName = function () {
return source;
};
this.inspect = function (embedded, force) {
var buff = [];
var sep = '\n\n';
if (!embedded) {
buff.push('Inspecting ');
buff.push(this.getName());
buff.push(sep);
}
for (var i in this) {
if (i.substr(0, 3) == 'get') {
buff.push(i);
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
if (!embedded) (force === null) ? debug(buff.join('')) : debugf(buff.join(''));
return buff.join('');
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Input.UpDownCounter.prototype = new Simulator.Input.FieldSet();
Simulator.Input.UpDownCounter.parent = Simulator.Input.FieldSet;
Simulator.Input.UpDownCounter.prototype.constructor = Simulator.Input.UpDownCounter;

// FILE: TextConstant2.js (380d26ac) 3/7/2014 11:24:14 AM

Simulator.Input.TextConstant = function (sim, panel, theSection) {
Simulator.Input.StaticElement.call(this, sim);
var source = 'TextConstant';
var dbg = function () { return sim.getDebug(); };
var utils = function() { return sim.getUtils(); };
var simDocument = function() { return sim.getSimDocument(); };
if(sim) {
this.setPanel(panel);
this.setSection(theSection);
}
var text = '';
var heavy = false;
this.setText = function(newText) {
text = newText;
};
this.getText = function() {
return text;
};
this.setHeavy = function(newHeavy) {
if(newHeavy == 'yes') heavy = true;
else heavy = false;
};
this.getHeavy = function() {
return heavy;
};
this.setAttributes = function (attr, node) {
if (node) attr = utils().getAttributes(node);
Simulator.Input.TextConstant.prototype.setAttributes(attr);
for (var i in attr) {
switch (i) {
case 'text':
this.setText(attr[i]);
break;
case 'heavy':
this.setHeavy(attr[i]);
break;
}
}
};
this.render = function () {
var panelHtml = panel.getHTMLElement();
var divElement = simDocument().createElement('div');
if (this.getSpaceAbove() > 0) utils().appendBlankVertcalSpace(divElement, this.getSpaceAbove());
panelHtml.appendChild(divElement);
if (this.getHeavy()) divElement.innerHTML = '<b>' + this.getText() + '</b>';
else divElement.innerHTML = this.getText();
if (this.getSpaceBelow() > 0) utils().appendBlankVertcalSpace(divElement, this.getSpaceBelow());
this.setFocusable(false);
this.mapHTML2JS(divElement);
};
this.getSourceName = function() {
return source;
};
this.inspect = function (embedded, force) {
var buff = [];
var sep = '\n\n';
buff.push('Inspecting TextElement');
buff.push(sep);
for (var i in this) {
if (i.substr(0, 3) == 'get') {
buff.push(i);
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
if (!embedded) (force === null) ? debug(buff.join('')) : debugf(buff.join(''));
return buff.join('');
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Input.TextConstant.prototype = new Simulator.Input.StaticElement();
Simulator.Input.TextConstant.parent = Simulator.Input.StaticElement;
Simulator.Input.TextConstant.prototype.constructor = Simulator.Input.TextConstant;

// FILE: CommandElement2.js (857c2608) 3/7/2014 11:24:14 AM

Simulator.Control.CommandElement = function (sim) {
Simulator.SimElement.call(this, sim);
var source = 'CommandElement';
var parent = Simulator.SimElement.prototype;
var cmdElementImages = ['image_Trashcan'];
var handler = null;
var state = 'enabled';
var handlerParameters = '';
var alwaysEnabled = false;
var eventsRegistered = false;
var panel = null;
var util = function () { return sim.getUtils(); };
var simMgr = function () { return sim.getSimulationManager(); };
var eventMgr = function () { return sim.getEventManager(); };
var dbg = function () { return sim.getDebug(); };
var simDocument = function() { return sim.getSimDocument(); };
var registerClassEvents = function (instance) {
if (!eventsRegistered) {
eventMgr().registerEvent(new Simulator.Event(instance, 'info', 'simulatorStateChange'));
eventsRegistered = true;
}
};
this.setEname(source);
this.isAPredefinedCmdElementImage = function (imageName) {
return util().elementInArray(cmdElementImages, imageName);
};
this.getState = function () {
return state;
};
this.setState = function (newState) {
if (simMgr().isPlaying() || simMgr().isReadOnly()) state = 'disabled';
else if (newState == 'disabled') {
if (this.getAlwaysEnabled()) state = 'enabled';
else state = newState;
}
else if (newState == 'enabled') {
state = newState;
} else dbg().logFatalError(source, 'Invalid state passed to CommandElement.setState()');
return this;
};
this.keyboardNavigateTo = function (elementID, itemID, index) {
var element = simDocument().getElementById(elementID);
if (element) element.setAttribute('class', element.getAttribute('class') + ' simAreaFocus');
};
this.keyboardNavigateAwayFrom = function (elementID, itemID, index) {
var element = simDocument().getElementById(elementID);
if (element) {
var className = element.getAttribute('class');
var index = className.indexOf('simAreaFocus');
if (index > 0)
className = className.substring(0, index - 1);
element.setAttribute('class', className);
}
};
this.getHandler = function () {
return handler;
};
this.setHandler = function (newHandler) {
handler = newHandler;
return this;
};
this.getHandlerParameters = function () {
return handlerParameters;
};
this.setHandlerParameters = function (newHandlerParameters) {
handlerParameters = newHandlerParameters;
return this;
};
this.setPredefinedImage = function (newImage) {
this.setImage(newImage);
};
this.getAlwaysEnabled = function () {
return alwaysEnabled;
};
this.setAlwaysEnabled = function (newAlwaysEnabled) {
alwaysEnabled = newAlwaysEnabled == 'yes' ? true : false;
return this;
};
this.isDisabled = function () {
return state == 'disabled';
};
this.setPanel = function (thePanel) {
panel = thePanel;
panel.registerIOElement(this);
return this;
};
this.saveState = function(indent, preface, nameStr, valStr, suffix) {
return '';
};
this.getSourceName = function() {
return source;
};
this.inspect = function(embedded, force) {
var buff = [];
var sep = '\n';
buff.push('Inspecting ' + source + sep);
var str = Simulator.Control.CommandElement.prototype.inspect.call(this, true, force);
if (str) return str;
else {
for ( var i in this) {
if (i.substr(0, 3) == 'get') {
buff.push(i.charAt(3).toLowerCase() + i.slice(4));
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
buff.push('End Inspecting ' + source + sep + sep);
if(!embedded) force == true ? dbg().debugf(source, buff.join('')) : dbg().debug(source, buff.join(''));
else return buff.join('');
}
};
this.setAttributes = function (attr, node) {
Simulator.Control.CommandElement.prototype.setAttributes.call(this, attr, node);
for (var i in attr) {
switch (i) {
case 'predefinedImage':
this.setPredefinedImage(attr[i]);
break;
case 'handler':
this.setHandler(attr[i]);
break;
case 'handlerParameters':
this.setHandlerParameters(attr[i]);
break;
case 'alwaysEnabled':
this.setAlwaysEnabled(attr[i]);
break;
case 'speechLabel':
this.setSpeechLabel(attr[i]);
break;
}
}
};
if (sim) {
registerClassEvents(this);
}
};
Simulator.Control.CommandElement.prototype = new Simulator.SimElement();
Simulator.Control.CommandElement.parent = Simulator.SimElement;
Simulator.Control.CommandElement.prototype.constructor = Simulator.Control.CommandElement;

// FILE: Button2.js (facfc7bf) 3/7/2014 11:24:14 AM

Simulator.Control.Button = function (sim, panel, section) {
Simulator.Control.CommandElement.call(this, sim);
var source = 'Button';
var instance = this;
var HTMLButton = null;
var src = '';
var implication = 'neutral';
var borderColor = '';
var eventsRegistered = false;
var debouceInterval = 1000;
var lastStartTrialTime = 0;
var genericButtonReady = true;
var startTrialButtonReady = true;
var startAnimationButtonReady = true;
var resetTrialsButtonReady = true;
var newTrialButtonReady = true;
var submitInputButtonReady = true;
var submitItemButtonReady = true;
var requestAnimationOutputButtonReady = true;
var showDialogButtonReady = true;
var showAlertButtonReady = true;
var util = function () { return sim.getUtils(); };
var simMgr = function () { return sim.getSimulationManager(); };
var eventMgr = function () { return sim.getEventManager(); };
var dbg = function () { return sim.getDebug(); };
var speechGrammarBldr = function () { return sim.getSpeechGrammarBldr(); };
var scoringTable = function () { return sim.getScoringTable(); };
var html2jsMap = function () { return sim.getHTML2JSMap(); };
var simDocument = function () { return sim.getSimDocument(); };
var keyboardInput = function () { return sim.getKeyboardInput(); };
var whiteboard = function () { return sim.getWhiteboard(); };
var registerClassEvents = function (instance) {
if (!eventsRegistered) {
eventMgr().registerEvent(new Simulator.Event(instance, 'info', 'animationFinished'));
eventMgr().registerEvent(new Simulator.Event(instance, 'info', 'animationThreadFinished'));
eventsRegistered = true;
}
};
function resetButton(buttonName) {
switch (buttonName) {
case 'generic':
genericButtonReady = true;
break;
case 'startTrial':
startTrialButtonReady = true;
break;
case 'startAnimation':
startAnimationButtonReady = true;
break;
case 'resetTrials':
resetTrialsButtonReady = true;
break;
case 'newTrial':
newTrialButtonReady = true;
break;
case 'submitInput':
submitInputButtonReady = true;
break;
case 'submitItem':
submitItemButtonReady = true;
break;
case 'requestAnimationOutput':
requestAnimationOutputButtonReady = true;
break;
case 'showDialog':
showDialogButtonReady = true;
break;
case 'showAlert':
showAlertButtonReady = true;
break;
case 'speechLabel':
this.setSpeechLabel(attr[i]);
break;
default:
break;
}
};
function publishEvents(jsButton, context) {
var anEvent = jsButton.nextEvent(true);
if (!context) context = '*';
while (anEvent != null) {
if (anEvent.context == context || anEvent.context == '*' || context == '*') {
eventMgr().postEvent(anEvent);
}
anEvent = jsButton.nextEvent();
}
};
this.setEname(source);
if (panel) {
this.setPanel(panel);
}
this.setHTMLButton = function () {
return HTMLButton;
};
this.setHTMLButton = function (newHTMLButton) {
HTMLButton = newHTMLButton;
return this;
};
this.getSrc = function () {
return src;
};
this.setSrc = function (newSrc) {
src = newSrc;
return this;
};
this.getImplication = function () {
return implication;
};
this.setImplication = function (newImplication) {
implication = newImplication;
return this;
};
this.recordKeyboardSelection = function (elementID, itemID) {
if (itemID) {
var handler = this.getHandler();
handler(elementID);
}
};
this.receivedSpeechFocus = function () {
debug(this.getName() + ' received speech focus');
var node = simDocument().getElementById('buttonDiv' + this.getNodeID());
borderColor = node.style.border.color;
node.style.border = '#ff0000';
};
this.removeSpeechFocus = function (value) {
debug(this.getName() + ' lost speech focus');
var node = simDocument().getElementById('buttonDiv' + this.getNodeID());
node.style.border.color = borderColor;
};
this.speechActivated = function (value) {
var handler = 'Button.' + this.getHandler();
eval(handler)(this.getNodeID());
};
this.handleEvent = function (event) {
var newEvent = undefined;
switch (event.type) {
case 'command':
break;
case 'info':
switch (event.context) {
case 'animationThreadFinished':
resetButton('startTrial');
break;
case 'animationFinished':
resetButton('startTrial');
break;
}
break;
default:
dbg().logWarning(this.getName() + ': Unhandled event type received: ' + event.toString());
return;
}
if (newEvent != undefined && newEvent != null) newEvent.postEvent();
};
this.disableInput = function () {
var element = simDocument().getElementById(this.getNodeID());
element.disable = true;
this.setState('disabled');
};
this.enableInput = function () {
var element = simDocument().getElementById(this.getNodeID());
element.disable = false;
this.setState('enabled');
};
this.getSourceName = function () {
return source;
};
this.inspect = function (embedded, force) {
var buff = [];
var sep = '\n';
buff.push('Inspecting ' + source + ' ' + this.getName() + sep);
var str = Simulator.Control.Button.prototype.inspect.call(this, true, force);
if (str) buff.push(str);
else {
for (var i in this) {
if (i.substr(0, 3) == 'get') {
buff.push(i.charAt(3).toLowerCase() + i.slice(4));
buff.push(' = ');
buff.push(eval('this.' + i + '()'));
buff.push(sep);
}
}
}
buff.push('End inspecting ' + source + ' ' + this.getName() + sep + sep);
if (!embedded) force == true ? debugf(buff.join('')) : debug(buff.join(''));
else return buff.join('');
};
function onClick(id) {
var newTime = new Date();
var theButton = simDocument().getElementById(id);
if (theButton) {
var jsButton = html2jsMap().getJSFromHTML(theButton);
if (jsButton.getState() == 'enabled') {
if ((genericButtonReady == true) && (!simMgr().isPlaying())) {
if ((newTime - lastStartTrialTime) > debouceInterval) {
lastStartTrialTime = newTime;
genericButtonReady = false;
setTimeout(function () { resetButton("generic"); }, debouceInterval);
if (jsButton.isDisabled()) {
(simMgr().GetDisabledAction())();
}
else {
publishEvents(jsButton);
}
}
}
}
else {
dbg().logWarning(source, '-- Button with id = ' + id + ' could not be activated --');
}
}
else {
dbg().logFatalError(source, 'Could not get Button instance with id = ' + id);
}
};
function StartTrial(id) {
if (!simMgr().verifyCheckListSelection()) {
var newTime = new Date();
var debounceMultiplier = (sim.animationIsPresent()) ? 4 : .5;
var theButton = simDocument().getElementById(id);
if (theButton) {
var jsButton = html2jsMap().getJSFromHTML(theButton);
if (jsButton.getState() == 'enabled') {
if ((startTrialButtonReady == true) && (!simMgr().isPlaying()) && !simMgr().isReadOnly()) {
lastStartTrialTime = newTime;
startTrialButtonReady = false;
whiteboard().clearCategory('evaluationOutput');
whiteboard().clearCategory('animationOutput');
setTimeout(function () { resetButton("startTrial"); }, debouceInterval * debounceMultiplier);
publishEvents(jsButton, 'startTrial');
}
}
} else {
dbg().logFatalError(source, 'Could not get Button instance with id = ' + id);
}
}
};
function StartAnimation(id) {
if (!simMgr().verifyCheckListSelection()) {
var newTime = new Date();
var theButton = simDocument().getElementById(id);
if (theButton) {
var jsButton = html2jsMap().getJSFromHTML(theButton);
if (jsButton.getState() == 'enabled') {
if ((startAnimationButtonReady == true) && (!simMgr().isPlaying()) && !simMgr().isReadOnly()) {
lastStartTrialTime = newTime;
startAnimationButtonReady = false;
whiteboard().clearCategory('evaluationOutput');
whiteboard().clearCategory('animationOutput');
setTimeout(function () { resetButton("startAnimation"); }, debouceInterval * 4);
publishEvents(jsButton, 'startAnimation');
}
}
} else {
dbg().logFatalError(source, 'Could not get Button instance with id = ' + id);
}
}
};
function NewTrial(id) {
if (!simMgr().verifyCheckListSelection()) {
var newTime = new Date();
var theButton = simDocument().getElementById(id);
if (theButton) {
var jsButton = html2jsMap().getJSFromHTML(theButton);
if (jsButton.getState() == 'enabled') {
if ((newTrialButtonReady == true) && (!simMgr().isPlaying())) {
if ((newTime - lastStartTrialTime) > debouceInterval) {
lastStartTrialTime = newTime;
newTrialButtonReady = false;
setTimeout(function () { resetButton("newTrial"); }, debouceInterval);
if (jsButton.isDisabled()) {
(simMgr().GetDisabledAction())();
}
else {
simMgr().NexTrial();
}
}
}
}
}
}
};
function SubmitInput(id) {
var newTime = new Date();
var theButton = simDocument().getElementById(id);
if (theButton) {
var jsButton = html2jsMap().getJSFromHTML(theButton);
if (jsButton.getState() == 'enabled') {
if ((submitInputButtonReady == true) && (!simMgr().isPlaying())) {
if ((newTime - lastStartTrialTime) > debouceInterval) {
lastStartTrialTime = newTime;
submitInputButtonReady = false;
setTimeout(function () { resetButton("submitInput"); }, debouceInterval);
if (jsButton.isDisabled()) {
(simMgr().GetDisabledAction())();
}
else {
publishEvents(jsButton, 'submitInput');
}
}
}
}
}
};
function SubmitItem(id) {
var newTime = new Date();
var theButton = simDocument().getElementById(id);
if (theButton) {
var jsButton = html2jsMap().getJSFromHTML(theButton);
if (jsButton.getState() == 'enabled') {
if ((submitItemButtonReady == true) && (!simMgr().isPlaying())) {
if ((newTime - lastStartTrialTime) > debouceInterval) {
lastStartTrialTime = newTime;
submitItemButtonReady = false;
setTimeout(function () { resetButton("submitItem"); }, debouceInterval);
if (jsButton.isDisabled()) {
(simMgr().GetDisabledAction())();
}
else {
var answer = confirm('Are You Sure You Want to Submit the Item for Scoring');
if (answer) {
simMgr().ScoreItem();
Simulator.showAlert('Question', 'Press "Next" for Next Test Item');
simMgr().GetNextItem();
}
}
}
}
}
}
};
function RequestAnimationOutput(id) {
var newTime = new Date();
var theButton = simDocument().getElementById(id);
if (theButton) {
var jsButton = html2jsMap().getJSFromHTML(theButton);
if (jsButton.getState() == 'enabled') {
if ((requestAnimationOutputButtonReady == true) && (!simMgr().isPlaying())) {
if ((newTime - lastStartTrialTime) > debouceInterval) {
lastStartTrialTime = newTime;
requestAnimationOutputButtonReady = false;
setTimeout(function () { resetButton("requestAnimationOutput"); }, debouceInterval);
if (jsButton.isDisabled()) {
(simMgr().GetDisabledAction())();
}
else {
eventMgr().postEvent(new Simulator.Event(jsButton, 'command', 'outputReq'));
}
}
}
}
}
};
function ShowDialog(id, dialogID) {
var newTime = new Date();
var theButton = simDocument().getElementById(id);
if (theButton) {
var jsButton = html2jsMap().getJSFromHTML(theButton);
if (jsButton.getState() == 'enabled') {
if ((showDialogButtonReady == true) && (!simMgr().isPlaying())) {
if ((newTime - lastStartTrialTime) > debouceInterval) {
lastStartTrialTime = newTime;
showDialogButtonReady = false;
setTimeout(function () { resetButton("showDialog"); }, debouceInterval);
if (jsButton.isDisabled()) {
(simMgr().GetDisabledAction())();
}
else {
dialogID.style.display = '';
}
}
}
}
}
};
function ShowAlert(id, parameters) {
var newTime = new Date();
var theButton = simDocument().getElementById(id);
if (theButton) {
var jsButton = html2jsMap().getJSFromHTML(theButton);
if (jsButton.getState() == 'enabled') {
if ((showAlertButtonReady == true) && (!simMgr().isPlaying())) {
if ((newTime - lastStartTrialTime) > debouceInterval) {
lastStartTrialTime = newTime;
showAlertButtonReady = false;
setTimeout(function () { resetButton("showAlert"); }, debouceInterval);
if (jsButton.isDisabled())
(simMgr().GetDisabledAction())();
else {
if (parameters) {
var parts = parameters.split('|');
var elements = [];
var aParameter = null;
for (var i = 0; i < parts.length; i++) {
aParameter = parts[i].split('*');
elements[aParameter[0]] = aParameter[1];
}
if ('contents' in elements) Simulator.showAlertWarning(unescape(elements['contents']));
}
}
}
}
}
}
};
function ResetTrials(id) {
var newTime = new Date();
var theButton = simDocument().getElementById(id);
if (theButton) {
var jsButton = html2jsMap().getJSFromHTML(theButton);
if (jsButton.getState() == 'enabled' && !simMgr().isReadOnly()) {
if ((resetTrialsButtonReady == true) && (!simMgr().isPlaying())) {
if ((newTime - lastStartTrialTime) > debouceInterval) {
lastStartTrialTime = newTime;
resetTrialsButtonReady = false;
setTimeout(function () { resetButton("resetTrials"); }, debouceInterval);
if (jsButton.isDisabled()) {
(simMgr().GetDisabledAction())();
}
else {
publishEvents(jsButton, 'resetTrials');
simMgr().setReadyState();
scoringTable().clearTable();
}
}
}
}
}
};
this.setAttributes = function (attr, node) {
if (node) attr = util().getAttributes(node);
Simulator.Control.Button.prototype.setAttributes.call(this, attr, node);
for (var i in attr) {
switch (i) {
case 'implication':
this.setImplication(attr[i]);
break;
}
}
};
this.recordKeyboardSelection = function (elementID, itemID, itemIndex) {
var bHandler = this.getHandler();
var bNodeID = this.getNodeID();
var parameters = this.getHandlerParameters();
if (parameters) parameters = ', "' + parameters + '"';
if (!parameters)
parameters = '';
eval(bHandler + '("' + bNodeID + '"' + parameters + ')');
};
this.render = function (panelName) {
var needTableDiv = false;
var tableDiv = null;
var buttonDiv = null;
var HTMLPanel = panel.getHTMLElement();
var button = null;
var imageSpan = null;
var imageElement = null;
var labelSpan = null;
var type = this.getType();
var tableElement = null;
if (HTMLPanel.id.indexOf('dataOutputPanel') != -1) {
tableElement = util().getElementsByClassName('table_controls', HTMLPanel);
needTableDiv = true;
}
if (needTableDiv) {
tableDiv = simDocument().createElement('div');
tableDiv.id = 'tableDiv' + this.getNodeID();
tableDiv.setAttribute('class', 'table_controls');
HTMLPanel.appendChild(tableDiv);
} else {
buttonDiv = simDocument().createElement('div');
buttonDiv.id = 'buttonDiv' + this.getNodeID();
HTMLPanel.appendChild(buttonDiv);
}
button = simDocument().createElement('button');
button.id = this.getNodeID();
button.setAttribute('type', 'button');
var bHandler = this.getHandler();
var bNodeID = this.getNodeID();
var parameters = this.getHandlerParameters();
if (parameters) parameters = ', "' + parameters + '"';
if (!parameters)
parameters = '';
util().bindEvent(button, 'click', function (event) {
eval(bHandler + '("' + bNodeID + '"' + parameters + ')');
if (event.preventDefault) {
event.preventDefault();
} else {
event.returnValue = false;
}
return false;
});
if (type == 'mixed' || type == 'image') {
imageSpan = simDocument().createElement('span');
imageSpan.setAttribute('class', 'holderImage');
var image = this.getImage();
if (this.isAPredefinedCmdElementImage(image)) button.setAttribute('class', 'actionButton ' + image + ' ' + this.getImplication());
else {
button.setAttribute('class', 'actionButton withImages ' + this.getImplication());
imageElement = simDocument().createElement('img');
imageElement.src = image;
imageElement.alt = this.getLabel();
imageSpan.appendChild(imageElement);
}
button.appendChild(imageSpan);
}
if (type == 'mixed' || type == 'text') {
if (type == 'text')
button.setAttribute('class', 'actionButton ' + this.getImplication());
labelSpan = simDocument().createElement('span');
labelSpan.setAttribute('class', 'holderText');
if (sim.getSpeechEnabled()) {
labelSpan.innerHTML = Simulator.Constants.SPEECH_CMD_ITEM_PREFIX + this.getLabel();
} else labelSpan.innerHTML = this.getLabel();
button.appendChild(labelSpan);
}
if (needTableDiv)
tableDiv.appendChild(button);
else if (HTMLPanel.id.indexOf('dataOutputPanel') == -1)
buttonDiv.appendChild(button);
else
tableElement[0].appendChild(button);
this.setHTMLButton(button);
hButton = button;
this.mapHTML2JS(button);
this.setFocusable(true, true);
if (sim.getSpeechEnabled()) {
var speechLabel = this.getSpeechLabel();
if (!speechLabel) {
speechLabel = this.getLabel();
if (!speechLabel && section) {
label = section.getSectionLabel();
}
if (!speechLabel) {
dbg().logFatalError(source, 'Item is speech enabled but speechLabel attribute is missing for ' + this.getName(), true);
return;
}
}
speechGrammarBldr().createButtonGrammarRule(this.getName(), speechLabel, this, speechLabel);
}
if (this.isFocusable()) {
keyboardInput().addFocusableElementItem(this, this.getNodeID());
}
};
if (sim) {
registerClassEvents(instance);
}
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Control.Button.prototype = new Simulator.Control.CommandElement();
Simulator.Control.Button.parent = Simulator.Control.CommandElement;
Simulator.Control.Button.prototype.constructor = Simulator.Control.Button;

// FILE: DataDisplayElement2.js (20d98ee3) 3/7/2014 11:24:14 AM

Simulator.Display.DataDisplayElement = function  (sim) {
Simulator.SimElement.call(this, sim);
var visible = 'true';
var displayVector = [];
var waitOn = null;
var fixedDigits = 2;
this.getVisible = function() {
return visible;
};
this.setVisible = function(newVisible) {
visible = newVisible;
return this;
};
this.getDisplayVector = function() {
return displayVector;
};
this.setDisplayVector = function(newDisplayVector) {
displayVector = newDisplayVector;
return this;
};
this.getWaitOn = function() {
return waitOn;
};
this.setWaitOn = function(newWaitOn) {
waitOn = newWaitOn;
return this;
};
this.getFixedDigits = function() {
return fixedDigits;
};
this.setFixedDigits = function(newFixedDigits) {
fixedDigits = newFixedDigits;
return this;
};
this.onChange = function (id) {
this.postOnChangeEvents();
};
this.setAttributes = function (attr, node) {
Simulator.Display.DataDisplayElement.prototype.setAttributes.call(this, attr, node);
for (var i in attr) {
switch (i) {
case 'visible':
this.setVisible(attr[i]);
break;
case 'fixedDigits':
this.setFixedDigits(attr[i]);
break;
case 'waitOn':
this.setWaitOn(attr[i]);
break;
}
}
};
};
Simulator.Display.DataDisplayElement.prototype = new Simulator.SimElement();
Simulator.Display.DataDisplayElement.parent = Simulator.SimElement;
Simulator.Display.DataDisplayElement.prototype.constructor = Simulator.Display.DataDisplayElement;

// FILE: DataTable2.js (5ec2b308) 3/7/2014 11:24:14 AM

Simulator.Display.DataTable = function (sim, panel) {
Simulator.Display.DataDisplayElement.call(this, sim);
var source = 'DataTable';
var iteratorSelectorMap = [];
var rowFunctionMap = [];
var headingMap = [];
var headingNames = [];
var autoCountMap = [];
var scoreableMap = [];
var numFiguresMap = [];
var includeKeyInOutput = [];
var columnTextLengthMap = [];
var hasOutputKeys = false;
var colWidth = -1;
var whiteboardKey = null;
var userAlerted = false;
var deleteColumn = false;
var numRows = undefined;
var htmlTableRendered = false;
var userAddRows = true;
var numColumns = undefined;
var header = true;
var incrementTrialOnOutput = false;
var clearRows = false;
var footer = false;
var scoreable = false;
var headerVisible = true;
var outputSource = 'evaluator';
var deleteRowImage = '';
var prevBorder = 'none';
var simID = null;
var instance = this;
if (sim) {
simID = sim.getSimID();
}
var HTMLPanel = panel.getHTMLElement();
var keyboardInput = function () { return sim.getKeyboardInput(); };
var util = function () { return sim.getUtils(); };
var simMgr = function () { return sim.getSimulationManager(); };
var eventMgr = function () { return sim.getEventManager(); };
var dbg = function () { return sim.getDebug(); };
var speechGrammarBldr = function () { return sim.getSpeechGrammarBldr(); };
var whiteboard = function () { return sim.getWhiteboard(); };
var scoringTable = function () { return sim.getScoringTable(); };
var simDocument = function () { return sim.getSimDocument(); };
var HTMLDataTable = simDocument().createElement('table');
HTMLDataTable.setAttribute('class', 'dataTable');
HTMLDataTable.rules = 'all';
function updateHTMLTable(newHTMLTable) {
HTMLDataTable = newHTMLTable;
}
this.setFocusable(true, true);
function addRow(table, loadFromResponse) {
var newCell = null;
var hTable = simDocument().getElementById(table.getID());
var nRows = hTable.rows.length;
var lastCellID = table.createCellId(hTable.tBodies[0].rows.length - 2, numColumns - 1);
var newRow = hTable.insertRow(nRows);
for (var i = 0; i < numColumns; i++) {
newCell = newRow.insertCell(i);
newCell.id = table.createCellId(hTable.tBodies[0].rows.length - 1, i);
newCell.innerHTML = ' ';
if (table.isFocusable()) keyboardInput().addFocusableElementItem(table, table.getID(), newCell.id);
}
if (table.getClearRows()) {
var dCell = newCell = newRow.insertCell(numColumns);
dCell.style.borderRight = '0px';
dCell.style.borderTop = '0px';
dCell.style.borderBottom = '0px';
dCell.id = table.createCellId(hTable.tBodies[0].rows.length - 1, numColumns);
var anchor = simDocument().createElement('a');
anchor.href = '#';
anchor.setAttribute('class', 'clearRow');
var img = simDocument().createElement('img');
img.src = table.getDeleteRowImage();
anchor.appendChild(img);
anchor.onclick = (function (e) {
var theRow = simMgr().getTrialNum() - 1;
if (loadFromResponse) {
theRow = nRows - 1;
}
var id = table.getNodeID();
return function (e) {
instance.clearRow(e, id, theRow);
};
})();
dCell.appendChild(anchor);
if (table.isFocusable()) keyboardInput().addFocusableElementItem(table, table.getID(), dCell.id);
}
updateHTMLTable(hTable);
table.setNumRows(hTable.tBodies[0].rows.length);
}
function resolveColumn(inputKey, outputKey) {
for (var i = 0; i < numColumns; i++) {
if (headingMap[i]['inputKey']) {
if (inputKey) {
if (headingMap[i]['inputKey'].toLowerCase() == inputKey.toLowerCase()) {
if (outputKeyMatch(outputKey, i)) return i;
else return -1;
}
}
} else if (outputKey) {
if (outputKeyMatch(outputKey, i)) return i;
}
}
return -1;
}
function outputKeyMatch(outputKey, colNum) {
if (headingMap[colNum]['outputKey']) {
if (outputKey) {
if (headingMap[colNum]['outputKey'][0] == '+') {
if (headingMap[colNum]['outputKey'].substring(1) == outputKey) return true;
}
else {
theOutputKeys = headingMap[colNum]['outputKey'].split(',');
for (var j = 0; j < theOutputKeys.length; j++) {
anOutputKey = theOutputKeys[j].replace(/^\s+/, '');
anOutputKey = anOutputKey.replace(/\s+$/, '');
if (anOutputKey.toLowerCase() == outputKey.toLowerCase()) return true;
} return false;
}
}
} else {
if (outputKey) return false;
else return true;
}
}
function parseTableInput(obj, inputs) {
var inputArray = [];
var elements = null;
var parts = null;
var cellWritten = false;
for (var p in inputs) {
inputArray = inputs[p];
if (inputArray) {
for (var i = 0; i < inputArray.length; i++) {
if (inputArray[i]) {
elements = inputArray[i].split(Simulator.Constants.PAIR_DELIMITTER);
for (var k = 0; k < elements.length; k++) {
parts = elements[k].split(Simulator.Constants.KEY_VALUE_DELIMITTER);
if (parts[1]) cellWritten = obj.setCell(parts[0], parts[1]);
else cellWritten = obj.setCell(p, parts[0]);
}
}
}
}
}
if (cellWritten && !hasOutputKeys) {
debug(source, 'cellWritten = ' + cellWritten + ', hasOutputKeys = ' + hasOutputKeys + '. Sending "tableUpdated" event');
eventMgr().postEvent(new Simulator.Event(obj, 'info', 'tableUpdated'));
}
}
function parseOutput(obj, outputs) {
var parts = [];
var functionList = [];
var functionDB = [];
var iterations = [];
if (outputs == '' || outputs == ';') {
dbg().logError(source, 'Improper output parameter received in DataTable.parseOutput: ' + outputs + '');
return;
}
iterations = outputs.split(Simulator.Constants.ITERATION_DELIMITTER);
for (var t = 0; t < iterations.length; t++) {
functionList = iterations[t].split(Simulator.Constants.PAIR_DELIMITTER);
for (var fl = 0; fl < functionList.length; fl++) {
parts = functionList[fl].split(Simulator.Constants.KEY_VALUE_DELIMITTER);
parts[0] = util().removeHeadingAndTrailingQuotes(parts[0], 'both');
parts[1] = util().removeHeadingAndTrailingQuotes(parts[1], 'both');
if (t == 0)
functionDB[parts[0]] = [];
if (parts[0])
functionDB[parts[0]].push(parts[parts.length - 1]);
}
}
var cellWritten = false;
for (var k = 0; k < numColumns; k++) {
var allData = null;
var inputKey = headingMap[k]['inputKey'];
var outputKeys = headingMap[k]['outputKey'];
if (outputKeys) {
var outputKeyList = outputKeys.split(',');
for (var i = 0; i < outputKeyList.length; i++) {
var data = null;
if (typeof outputKeyList[i] == 'Array') outputKeyList[i] = outputKeyList[i][0];
outputKeyList[i] = outputKeyList[i].replace(/^\s*/, "");
outputKeyList[i] = outputKeyList[i].replace(/\s*$/, "");
outputKeyList[i] = outputKeyList[i].replace(/^"\s*/, "\*");
outputKeyList[i] = outputKeyList[i].replace(/\s*\"$/, "\"");
outputKeyList[i] = outputKeyList[i].replace(/\"/g, "");
if (outputKeyList[i] in functionDB) {
if (iteratorSelectorMap[k]) {
data = util().applyFilter(iteratorSelectorMap[k], functionDB[outputKeyList[i]]);
functionDB[outputKeyList[i]] = data;
} else {
if (includeKeyInOutput[k]) {
functionDB[outputKeyList[i]] = outputKeyList[i] + ' : ' + functionDB[outputKeyList[i]];
}
}
data = functionDB[outputKeyList[i]];
if (data instanceof Array) data = data.join(',');
if (allData) allData = allData + ', ' + data;
else allData = data;
cellWritten = obj.setCell(inputKey, allData, outputKeyList[i]);
}
}
}
}
if (cellWritten) {
obj.saveScoreableInputs();
eventMgr().postEvent(new Simulator.Event(obj, 'info', 'tableUpdated'));
}
}
function compoundOutputKey(outputs) {
return outputs[0] == '+' ? true : false;
}
function postTableDataToWhiteboard(obj) {
var dataSeriesID = null;
whiteboard().addCategory('itemTableData');
var cellID = null;
var cell = null;
var buff = [];
for (var j = 0; j < numRows; j++) {
for (var i = 0; i < numColumns; i++) {
cellID = obj.createCellId(j, i);
cell = simDocument().getElementById(cellID);
if (i == 0) buff.push(cell.innerHTML);
else {
buff.push(', ');
buff.push(cell.innerHTML);
}
}
dataSeriesID = 'series' + (j + 1);
if (!whiteboardKey) whiteboardKey = whiteboard().addItem('itemTableData', dataSeriesID);
whiteboard().setItem('itemTableData', dataSeriesID, buff.join(''), whiteboardKey);
}
}
function rowIsEmpty(tbl, theRow) {
var nCols = tbl.getNumColumns();
if (theRow < tbl.getNumRows() && theRow >= 0) {
for (var i = 0; i < nCols; i++) {
var id = tbl.createCellId(theRow, i);
var cell = simDocument().getElementById(id);
if (cell.innerHTML != '') return false;
}
}
return true;
}
var createTableBody = function (tbl) {
var tBody = simDocument().createElement('tbody');
HTMLDataTable.appendChild(tBody);
var row;
tbl.setFocusable(true, false);
for (var j = 0; j < numRows; j++) {
row = simDocument().createElement('tr');
tBody.appendChild(row);
for (var i = 0; i < numColumns; i++) {
var cell = simDocument().createElement('td');
cell.id = tbl.createCellId(j, i);
row.appendChild(cell);
cell.innerHTML = '';
if (tbl.isFocusable()) keyboardInput().addFocusableElementItem(tbl, tbl.getNodeID(), cell.id);
}
if (tbl.getClearRows()) {
var dCell = newCell = row.insertCell(row.cells.length);
dCell.id = tbl.createCellId(j, numColumns);
dCell.style.borderRight = '0px';
dCell.style.borderTop = '0px';
dCell.style.borderBottom = '0px';
var anchor = simDocument().createElement('a');
anchor.href = '#';
anchor.setAttribute('class', 'clearRow');
var img = simDocument().createElement('img');
img.src = tbl.getDeleteRowImage();
anchor.appendChild(img);
anchor.onclick = (function (e) {
var theRow = j;
var id = tbl.getNodeID();
return function (e) {
instance.clearRow(e, id, theRow);
};
})();
dCell.appendChild(anchor);
if (tbl.isFocusable()) keyboardInput().addFocusableElementItem(tbl, tbl.getNodeID(), dCell.id);
}
}
return;
};
var createRowDeletionSpeechCommand = function (tbl) {
speechGrammarBldr().createTableRowClearRule(tbl.getName(), '', tbl, 'Data Table');
};
this.setEname(source);
this.getHTMLTable = function () {
return HTMLDataTable;
};
this.getID = function () {
return HTMLDataTable.id;
};
this.setID = function (id) {
HTMLDataTable.setAttribute('id', this.getNodeID());
};
this.getUserAddRows = function () {
return userAddRows;
};
this.setUserAddRows = function (newUserAddRows) {
if (newUserAddRows == 'true') userAddRows = true;
else userAddRows = false;
};
this.getNumRows = function () {
return numRows;
};
this.setNumRows = function (newNumRows) {
numRows = parseInt(newNumRows);
if (numRows == undefined) {
dbg().logWarning(source, 'Could not convert string representation of number of data table rows to an integer');
}
if (numRows == 0) deleteColumn = true;
return this;
};
this.getNumColumns = function () {
return numColumns;
};
this.setNumColumns = function (newNumColumns) {
numColumns = parseInt(newNumColumns);
if (!numColumns) {
dbg().logWarning(source, 'Could not convert string representation of number of data table columns to an integer');
}
colWidth = 85 / numColumns;
dColWidth = (100 - (colWidth * numColumns)) + '%';
return this;
};
this.getHeader = function () {
return header;
};
this.setHeader = function (header) {
var indexStr = '';
var maxLength = 0;
var k = -1;
var cell = null;
var headingText = null;
var isIE = util().isInternetExplorer();
if (header != null) {
var tHead = HTMLDataTable.createTHead();
var row = simDocument().createElement('tr');
tHead.appendChild(row);
for (var i = 0; i < header.childNodes.length; i++) {
try {
var child = header.childNodes[i];
if (child.nodeName[0] != '#') {
k += 1;
if (k <= numColumns) {
cell = simDocument().createElement('th');
row.appendChild(cell);
indexStr = 'text';
if (isIE) headingText = child.attributes.getNamedItem(indexStr).value;
else headingText = child.attributes[indexStr].nodeValue;
cell.innerHTML = headingText;
headingNames[k] = headingText;
headingMap[k] = [];
indexStr = "contentType";
headingMap[k].push([indexStr]);
if (isIE) {
if (child.attributes.getNamedItem(indexStr) != undefined)
headingMap[k][indexStr] = child.attributes.getNamedItem(indexStr).value;
else
headingMap[k][indexStr] = "text";
}
else {
if (child.attributes[indexStr] != undefined)
headingMap[k][indexStr] = child.attributes[indexStr].nodeValue;
else
headingMap[k][indexStr] = "text";
}
indexStr = "inputKey";
headingMap[k].push([indexStr]);
if (isIE) {
if (child.attributes.getNamedItem(indexStr) != undefined)
headingMap[k][indexStr] = child.attributes.getNamedItem(indexStr).value;
else
headingMap[k][indexStr] = null;
}
else {
if (child.attributes[indexStr] != undefined)
headingMap[k][indexStr] = child.attributes[indexStr].nodeValue;
else
headingMap[k][indexStr] = null;
}
indexStr = "outputKey";
headingMap[k].push([indexStr]);
if (isIE) {
if (child.attributes.getNamedItem(indexStr) != undefined) {
headingMap[k][indexStr] = child.attributes.getNamedItem(indexStr).value;
headingMap[k][indexStr] = headingMap[k][indexStr].replace(/\s*\"\s*/g, "\"");
hasOutputKeys = true;
}
else
headingMap[k][indexStr] = null;
}
else {
if (child.attributes[indexStr] != undefined) {
headingMap[k][indexStr] = child.attributes[indexStr].nodeValue;
headingMap[k][indexStr] = headingMap[k][indexStr].replace(/\s*\"\s*/g, "\"");
hasOutputKeys = true;
}
else headingMap[k][indexStr] = null;
}
indexStr = "includeKeyInOutput";
if (isIE) {
if (child.attributes.getNamedItem(indexStr))
if (child.attributes.getNamedItem(indexStr).value == "yes") includeKeyInOutput[k] = true;
else includeKeyInOutput[k] = false;
}
else {
if (child.attributes[indexStr])
if (child.attributes[indexStr].nodeValue == "yes") includeKeyInOutput[k] = true;
else includeKeyInOutput[k] = false;
}
indexStr = "autoCount";
if (isIE) {
if (child.attributes.getNamedItem(indexStr)) autoCountMap[k] = child.attributes.getNamedItem(indexStr).value;
else autoCountMap[k] = null;
}
else {
if (child.attributes[indexStr]) autoCountMap[k] = child.attributes[indexStr].nodeValue;
else autoCountMap[k] = null;
}
indexStr = "filter";
if (isIE) {
if (child.attributes.getNamedItem(indexStr)) iteratorSelectorMap[k] = child.attributes.getNamedItem(indexStr).value;
var len = headingText.length;
if (len > maxLength) maxLength = len;
}
else {
if (child.attributes[indexStr]) iteratorSelectorMap[k] = child.attributes[indexStr].nodeValue;
var len = headingText.length;
if (len > maxLength) maxLength = len;
}
indexStr = "scoreable";
if (isIE) {
if (child.attributes.getNamedItem(indexStr) != undefined) {
scoreableMap[k] = true;
scoringTable().addElement(headingNames[k], "output");
}
else scoreableMap[k] = false;
}
else {
if (child.attributes[indexStr] != undefined) {
scoreableMap[k] = true;
scoringTable().addElement(headingNames[k], "output");
}
else scoreableMap[k] = false;
}
indexStr = "numDecFigures";
if (isIE) {
if (child.attributes.getNamedItem(indexStr) != undefined) numFiguresMap[k] = child.attributes.getNamedItem(indexStr).value;
}
else {
if (child.attributes[indexStr] != undefined) numFiguresMap[k] = child.attributes[indexStr].nodeValue;
}
indexStr = "rowFunction";
if (isIE) {
if (child.attributes.getNamedItem(indexStr) != undefined) rowFunctionMap[k] = child.attributes.getNamedItem(indexStr).value;
}
else {
if (child.attributes[indexStr] != undefined) rowFunctionMap[k] = child.attributes[indexStr].nodeValue;
}
indexStr = "maxTextLength";
if (isIE) {
if (child.attributes.getNamedItem(indexStr)) columnTextLengthMap[k] = child.attributes.getNamedItem(indexStr).value;
else columnTextLengthMap[k] = -1;
}
else {
if (child.attributes[indexStr]) columnTextLengthMap[k] = child.attributes[indexStr].nodeValue;
else columnTextLengthMap[k] = -1;
}
}
}
} catch (err) {
dbg().logError(source, 'Error occurred during construction of data table header column ' + k + ' for attribute ' + indexStr + ': ' + err.message);
}
}
}
return this;
};
this.getInputKey = function (columnNumber) {
return headingMap[columnNumber]['inputKey'];
};
this.getOutputKey = function (columnNumber) {
return headingMap[columnNumber]['outputKey'];
};
this.headingMapInverse = function (num) {
for (var key in headingMap) {
if (headingMap[key] == num) return key;
}
return null;
};
this.setIncrementTrialOnOutput = function (newIncrementTrialOnOutput) {
if (newIncrementTrialOnOutput == 'true') incrementTrialOnOutput = true;
else incrementTrialOnOutput = false;
};
this.getIncrementTrialOnOutput = function () {
return incrementTrialOnOutput;
};
this.createCellId = function (row, col) {
return this.getName() + simID + row + col;
};
this.getFooter = function () {
return footer;
};
this.setFooter = function (footer) {
var tFoot = HTMLDataTable.createTFoot();
var row = simDocument().createElement('TR');
tFoot.appendChild(row);
for (var i = 0; i < numColumns; i++) {
var cell = simDocument().createElement('TD');
cell.style.width = colWidth;
row.appendChild(cell);
cell.innerHTML = ' ';
}
this.HTMLDataTable.style.display = 'block';
return this;
};
this.getClearRows = function () {
return clearRows;
};
this.setClearRows = function (newClearRows) {
clearRows = newClearRows == 'true' || newClearRows == 'yes' ? true : false;
return this;
};
this.getScoreable = function () {
return scoreable;
};
this.setScoreable = function (newScoreable) {
if (newScoreable == 'yes') scoreable = true;
else scoreable = false;
return this;
};
this.getHeaderVisible = function () {
return headerVisible;
};
this.setHeaderVisible = function (newHeaderVisible) {
headerVisible = newHeaderVisible;
return this;
};
this.getOutputSource = function () {
return outputSource;
};
this.setOutputSource = function (newOutputSource) {
outputSource = newOutputSource;
return this;
};
this.getDeleteRowImage = function () {
return deleteRowImage;
};
this.setDeleteRowImage = function (newDeleteRowImage) {
deleteRowImage = newDeleteRowImage;
if (deleteRowImage) {
this.setClearRows(true);
deleteColumn = true;
}
return this;
};
this.evaluateRowFunction = function (row, column) {
if (rowFunctionMap[column]) {
var sum = 0;
var cellID = this.createCellId(row, column);
var cell = simDocument().getElementById(cellID);
switch (rowFunctionMap[column]) {
case 'mean':
for (var i = 0; i < numColumns; i++) if (i != column) sum += parseFloat(cell.inerHTML);
return (sum / numRows).toFixed(this.getFixedDigits());
break;
case 'sum':
for (var i = 0; i < numColumns; i++) if (i != column) sum += parseFloat(cell.inerHTML);
return sum.toFixed(this.getFixedDigits());
break;
case 'max':
var max = null;
for (var i = 0; i < numColumns; i++) max = Math.max(parseFloat(cell.inerHTML), max);
return max.toFixed(this.getFixedDigits());
break;
case 'min':
var min = null;
for (var i = 0; i < numColumns; i++) min = Math(min, parseFloat(cell.inerHTML));
return min.toFixed(this.getFixedDigits());
break;
}
}
};
this.replace = function () {
HTMLPanel.replaceChild(HTMLDataTable, HTMLDataTable);
this.refreshTable();
};
this.append = function () {
HTMLPanel.appendChild(HTMLDataTable);
};
this.setCell = function (inputKey, data, outputKey) {
var cellWritten = false;
var rowNum = simMgr().getTrialNum() - 1;
var colNum = resolveColumn(inputKey, outputKey);
if (rowNum == numRows) {
if (userAddRows) addRow(this);
else {
if (!userAlerted) {
Simulator.showAlertWarning('You cannot add additional data table rows.');
userAlerted = true;
}
return;
}
}
cellWritten = this.setCellWithRowColNum(rowNum, colNum, data);
this.setAutoCountCells(rowNum);
return cellWritten;
};
this.setCellWithRowColNum = function (rowNum, colNum, data) {
var cellWritten = false;
var testVal = null;
if (rowNum < numRows && rowNum >= 0 && colNum != -1) {
var id = this.createCellId(rowNum, colNum);
cell = simDocument().getElementById(id);
var contentType = headingMap[colNum]['contentType'];
if (data === Simulator.Constants.NO_DATA_INDICATOR) cell.inerHTML = Simulator.Constants.NO_DATA_INDICATOR;
else if (contentType == 'text') {
if (!isNaN(data)) {
testVal = parseFloat(data);
var figures = parseInt(numFiguresMap[colNum]);
if (!figures) figures = 0;
if (rowFunctionMap[colNum]) testVal = this.evaluateRowFunction(rowNum, colNum);
data = testVal.toFixed(figures);
}
else if (columnTextLengthMap[colNum] != -1) {
var parts = data.split(Simulator.Constants.MULTIPLE_VALUE_DELIMITTER);
var txtLen = parseInt(columnTextLengthMap[colNum]);
for (var i = 0; i < parts.length; i++) {
if (parts[i].length > txtLen) parts[i] = parts[i].substr(0, txtLen - 4) + " ...";
if (i > 0) parts[i] = ', ' + parts[i];
}
if (parts.length > 1) data = parts.join('\n');
else data = parts[0];
}
cell.innerHTML = util().replaceAll(data, Simulator.Constants.MULTIPLE_VALUE_DELIMITTER, ',');
} else if (contentType == 'image') {
cell.inerHTML = '<img src="data:image/png;base64,"' + data + '" alt="x">';
}
cellWritten = true;
} else cellWritten = false;
return cellWritten;
};
this.setAutoCountCells = function (rowNum) {
if (rowNum < numRows && rowNum >= 0) {
for (var i = 0; i < this.getNumColumns(); i++) {
if (autoCountMap[i] != null) {
var id = this.createCellId(rowNum, i);
cell = simDocument().getElementById(id);
cell.innerHTML = simMgr().getTrialNum();
}
}
}
};
this.handleEvent = function (event) {
var newEvent = undefined;
var data = '';
switch (event.type) {
case 'inputReq':
break;
case 'input':
data = event.data;
parseTableInput(this, data);
break;
case 'command':
switch (event.context) {
case 'resetTrials':
this.clearAllRows(this);
userAlerted = false;
break;
case 'startTrial':
if (!simMgr().trialLimitReached()) {
userAlerted = false;
data = whiteboard().getCategory('dataInput');
if (data != null) {
parseTableInput(this, data);
postTableDataToWhiteboard(this);
}
}
break;
case 'startAnimation':
userAlerted = false;
data = whiteboard().getCategory('dataInput');
if (data != null) {
parseTableInput(this, data);
postTableDataToWhiteboard(this);
}
break;
default:
dbg().logWarning(source, 'Unhandled command ' + event.context + ' received by DataTable');
break;
}
break;
case 'info':
switch (event.context) {
case 'inputAvailable':
if (!simMgr().trialLimitReached()) {
data = whiteboard().getCategory('dataInput');
if (data != null) {
parseTableInput(this, data);
postTableDataToWhiteboard(this);
}
}
break;
case Simulator.Constants.ANIMATION_FINISHED:
case Simulator.Constants.ANIMATION_THREAD_FINISHED:
if (this.getOutputSource()) {
if (this.getOutputSource() == 'evaluator') data = whiteboard().getItem('evaluationOutput', 'output');
else if (this.getOutputSource() == 'animation') data = whiteboard().getItem('animationOutput', 'output');
} else {
data = whiteboard().getItem('evaluationOutput', 'output');
if (!data) data = whiteboard().getItem('animationOutput', 'output');
}
if (data != null) parseOutput(this, data);
break;
case 'outputAvailable':
if ((!simMgr().trialLimitReached()) && ((this.getWaitOn() == null) || (this.getWaitOn() == ''))) {
data = whiteboard().getItem('evaluationOutput', 'output');
if (!data) data = whiteboard().getItem('evaluation', 'output');
if (!data) data = whiteboard().getItem('animationOutput', 'output');
if (data != null) parseOutput(this, data);
else eventMgr().postEvent(new Simulator.Event(this, 'info', 'tableUpdated'));
} else if ((this.getWaitOn() != null) && (this.getWaitOn() != '')) {
eventMgr().registerEvent(new Simulator.Event(this, 'info', this.getWaitOn()));
}
break;
case 'animationOutputAvailable':
data = whiteboard().getItem('animationOutput', 'output');
if (data != null) parseOutput(this, data);
else eventMgr().postEvent(new Simulator.Event(this, 'info', 'tableUpdated'));
break;
}
break;
default:
dbg().logWarning(source, 'DataTable ' + this.getName() + ': Unhandled event type received: ' + event.inspect());
return;
}
if (newEvent != undefined && newEvent != null) newEvent.postEvent();
};
this.allAttributesLoaded = function () {
createTableBody(this);
};
this.saveScoreableInputs = function () {
var row = simMgr().getTrialNum() - 1;
for (var i = 0; i < numColumns; i++) {
var cellID = this.createCellId(row, i);
var cell = simDocument().getElementById(cellID);
if (scoreableMap[i]) scoringTable().setValue(headingNames[i], row, cell.innerHTML);
}
};
this.getContents = function (indent, name) {
var buff = [];
var numCols = 0;
var table = simDocument().getElementById(this.getNodeID());
if (table) {
var body = table.tBodies[0];
var children = body.childNodes;
if (!name) buff.push(indent + '<stateTable>\n');
else buff.push('<' + name + '>\n');
for (var i = 0; i < children.length; i++) {
if (children[i].nodeName[0] != '#') {
var child = children[i];
if (child.nodeName.toLowerCase() == 'tr') {
buff.push(indent + '  <tr>\n');
var cols = child.childNodes;
if (this.getClearRows() == true) numCols = cols.length - 1;
else numCols = cols.length;
for (var j = 0; j < numCols; j++) {
if (cols[j].nodeName.toLowerCase() == 'th') {
buff.push(indent + '    <th>');
buff.push(cols[j].childNodes[0].textContent);
buff.push('</th>');
} else if (cols[j].nodeName.toLowerCase() == 'td') {
buff.push(indent + '    <td>');
buff.push(cols[j].textContent);
buff.push('</td>\n');
}
}
buff.push(indent + '  </tr>\n');
}
}
}
if (!name) buff.push(indent + '</stateTable>\n');
else buff.push('</' + name + '>\n');
return buff.join('');
} else return '';
};
this.loadFromResponse = function (node) {
var responseRowNum = -1;
var lastTableRowNum = this.getNumRows() - 1;
var colNum = -1;
var children = node.childNodes;
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (child.nodeName[0] != '#') {
if (child.nodeName.toLowerCase() == 'tr') {
responseRowNum++;
colNum = -1;
if (lastTableRowNum < responseRowNum) {
addRow(this, true);
lastTableRowNum++;
}
var childChildren = child.childNodes;
for (var j = 0; j < childChildren.length; j++) {
var childChild = childChildren[j];
if (childChild.nodeName[0] != '#') {
if (childChild.nodeName.toLowerCase() == 'td') {
colNum++;
var cellID = this.createCellId(responseRowNum, colNum);
var cell = simDocument().getElementById(cellID);
if (cell) cell.innerHTML = childChild.textContent;
else dbg().logError(source, 'DataTable.loadFromResponse: Could not find cell with ID = ' + cellID);
}
}
}
}
}
}
};
this.keyboardNavigateTo = function (elementID, itemID, index) {
var item = simDocument().getElementById(itemID);
if (item) item.setAttribute('class', 'simAreaFocus');
};
this.keyboardNavigateAwayFrom = function (elementID, itemID, index) {
var item = simDocument().getElementById(itemID);
if (item) item.removeAttribute('class');
};
this.recordKeyboardSelection = function (elementID, itemID, itemIndex) {
var element = null;
var item = null;
if (itemID) {
item = simDocument().getElementById(itemID);
if (!item) {
element = simDocument().getElementById(elementID);
if (element) item = element.getElementsByClassName(itemID)[0];
}
if (item) {
item.isSelected = true;
if (this.getClearRows()) {
if ((itemIndex % (numColumns + 1)) == numColumns) {
var currentRow = Math.floor(itemIndex / (numColumns + 1));
this.clearRow(null, itemID, currentRow, false);
}
}
}
}
};
this.receivedSpeechFocus = function () {
debug(this.getName() + ' received speech focus');
var node = simDocument().getElementById(this.getID());
prevBorder = node.style.border;
node.style.border = 'thin solid #ff0000';
};
this.removeSpeechFocus = function (value) {
debug(this.getName() + ' lost speech focus');
var node = simDocument().getElementById(this.getID());
node.style.border = prevBorder;
};
this.speechActivated = function (value) {
var parts = value.split('#');
this.clearRow(null, this.getNodeID(), parts[1].trim(), false);
};
this.getSourceName = function () {
return source;
};
this.inspect = function (embedded, force) {
var buff = [];
var sep = '\n\n';
var rowSep = '\n\n';
var colSep = '   ';
var tHeader = HTMLDataTable.tHead;
var tBody = HTMLDataTable.tBodies[0];
buff.push('Inspecting '); buff.push(this.getName()); buff.push(sep);
for (var i = 0; i < numColumns; i++) {
buff.push(tHeader.rows[0].cells[i].innerHTML); buff.push(colSep);
}
buff.push(rowSep);
for (var l = 0; l < numRows; l++) {
var row = tBody.rows[l];
for (var j = 0; j < numColumns; j++) {
buff.push(row.cells[j].innerHTML); buff.push(colSep);
}
buff.push(rowSep);
}
buff.push(sep);
for (var prop in this) {
if (prop.substr(0, 3) == 'get') {
buff.push(prop);
buff.push(' = ');
buff.push(eval('this.' + prop + '()'));
buff.push(sep);
}
}
if (!embedded) (force === null) ? debug(buff.join('')) : debugf(buff.join(''));
return buff.join('');
};
this.refreshTable = function () {
HTMLDataTable.style.display = 'none';
HTMLDataTable.style.display = 'table';
};
this.clearRow = function (e, htmlTbl, theRow, batchDelete) {
var evt = window.event || e;
if (!simMgr().isPlaying() && !simMgr().isReadOnly()) {
var tbl = this;
var nRows = tbl.getNumRows();
var nCols = tbl.getNumColumns();
if (theRow < nRows && theRow >= 0) {
if (!rowIsEmpty(tbl, theRow)) {
for (var i = 0; i < nCols; i++) {
var id = tbl.createCellId(theRow, i);
var cell = simDocument().getElementById(id);
cell.innerHTML = '';
}
scoringTable().clearRow(theRow);
if (!batchDelete) eventMgr().postEvent(new Simulator.Event(tbl, 'command', 'redoTrial', theRow + 1));
}
}
}
if (evt) {
if (evt.preventDefault) {
evt.preventDefault();
} else {
evt.returnValue = false;
}
}
};
this.clearAllRows = function (tbl) {
if (!simMgr().isReadOnly()) {
var htmlTbl = simDocument().getElementById(tbl.getNodeID());
var nRows = tbl.getNumRows();
for (var j = 0; j < nRows; j++) {
this.clearRow(null, htmlTbl.id, j, true);
}
eventMgr().postEvent(new Simulator.Event(tbl, 'info', 'allTableRowsCleared'));
}
};
this.setAttributes = function (attr, node) {
if (node) attr = util().getAttributes(node);
Simulator.Display.DataTable.prototype.setAttributes.call(this, attr, node);
for (var key in attr) {
switch (key) {
case 'rows':
this.setNumRows(attr[key]);
break;
case 'columns':
this.setNumColumns(attr[key]);
break;
case 'footer':
this.setFooter(attr[key]);
break;
case 'clearRow':
this.setClearRows(attr[key]);
break;
case 'headerVisible':
this.setHeaderVisible(attr[key]);
break;
case 'name':
this.setID(this.getName());
break;
case 'deleteRowImage':
this.setDeleteRowImage(attr[key]);
break;
case 'contentType':
this.setContentType(attr[key]);
break;
case 'incrementTrialOnOutput':
this.setIncrementTrialOnOutput(attr[key]);
break;
case 'userAddRows':
this.setUserAddRows(attr[key]);
break;
case 'rowFunction':
this.setRowFunction(attr[key]);
break;
case 'outputSource':
this.setOutputSource(attr[key]);
break;
}
}
var children = node.childNodes;
for (var k = 0; k < children.length; k++) {
if (children[k].nodeName == 'header') {
this.setHeader(children[k]);
break;
}
}
this.allAttributesLoaded();
};
this.render = function (panelName) {
if (this.getVisible()) {
if (!htmlTableRendered) {
this.append();
htmlTableRendered = true;
}
else this.append();
this.refreshTable();
} else {
var HTMLTable = simDocument().getElementById(this.getName());
HTMLTable.style.display = 'none';
this.mapHTML2JS(HTMLTable);
}
};
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};
Simulator.Display.DataTable.prototype = new Simulator.Display.DataDisplayElement();
Simulator.Display.DataTable.parent = Simulator.Display.DataDisplayElement;
Simulator.Display.DataTable.prototype.constructor = Simulator.Display.DataTable;

// FILE: DialogPanel2.js (684f7af1) 3/7/2014 11:24:14 AM

Simulator.Display.DialogPanel = function(sim, enclosingPanel, panelID, buttonLabel, attr) {
var source = 'DialogPanel';
var HTMLDialogPanel = null;
var title = '';
var instructions = '';
var id = '';
var dialogAttr = [];
var dbg = function() { return sim.getDebug(); };
var simDocument = function() { return sim.getSimDocument(); };
this.getTitle = function() {
return title;
};
this.getInstructions = function() {
return instructions;
};
this.getID = function() {
return id;
};
this.setClass = function(newClass) {
HTMLDialogPanel.setAttribute('class', newClass);
};
this.setInstructions = function(newInstructions) {
dialogAttr['instructions'] = newInstructions;
};
this.setTitle = function(newTitle) {
dialogAttr['title'] = newITitle;
};
this.getDialogAttr = function() {
return dialogAttr;
};
this.render = function(enclosingPanel, attr, panelID, buttonLabel) {
dialogButton = dialogPanel.createButton(panelID + 'button', panelID, buttonLabel);
var htmlButton = simDocument().getElementById(dialogButton.getNodeID());
HTMLPanel = simDocument().getElementById(panelID);
dialogPanel.innerHTML = dialogAttr['instructions'];
dialogPanel.display = 'none';
HTMLPanel.appendChild(htmlButton);
};
this.getDialogButton = function() {
return dialogButton;
};
function setAttributes(attr) {
for(var i in attr) {
switch (i) {
case 'title':
title = attr[i];
break;
case 'instructions':
instructions = attr[i];
break;
default:
dbg().logError(source, 'Unknown DialogPanel attribute seen: ' + i + 'with value "' + attr[i] + '"');
}
}
setStructure();
}
function setStructure() {
HTMLDialogPanel = simDocument().createElement('div');
HTMLDialogPanel.setAttribute('class', 'infoWrapper');
HTMLDialogPanel.style.display = 'none';
var titleDiv = simDocument().createElement('div');
titleDiv.setAttribute('class', 'instructionsTitle');
var header = simDocument().createElement('h2');
header.innerHTML = title;
titleDiv.appendChild(header);
var anchor = simDocument().createElement('a');
anchor.href = '#';
anchor.setAttribute('class', 'close instructions');
anchor.innerHTML = 'Close';
titleDiv.appendChild(anchor);
HTMLDialogPanel.appendChild(titleDiv);
var instrDiv = simDocument().createElement('div');
instrDiv.setAttribute('class', 'holderInfo');
instrDiv.innerHTML = instructions;
HTMLDialogPanel.appendChild(instrDiv);
}
this.createButton = function(htmlID, panelName, buttonLabel) {
var theButton = new Button();
var attr = [];
attr['implication'] = 'neutral';
attr['label'] = buttonLabel;
attr['name'] = htmlID;
attr['type'] = 'text';
attr['alwaysEnabled'] = 'yes';
attr['handler'] = 'ShowDialog';
attr['handlerParameters'] = panelName;
theButton.setAttributes(attr, null);
theButton.render(panelName);
return theButton;
};
function debug(str1, str2, tace) {
dbg().debug(source + ': ' + str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source + ': ' + str1, str2, trace);
}
setAttributes(attr);
};

// FILE: SimParser.js (3ac3b06c) 3/7/2014 11:24:14 AM

var SimParser = SimParser || {};
SimParser.nameSpace = function() {
var nsObj = null, parts;
for (var i = 0; i < arguments.length; i++) {
parts = ('' + arguments[i]).split('.');
nsObj = SimParser;
for (var j = (parts[0] == 'SimParser') ? 1 : 0; j < parts.length; j++) {
nsObj[parts[j]] = nsObj[parts[j]] || {};
nsObj = nsObj[parts[j]];
}
}
return nsObj;
};
SimParser.ParserItem = SimParser.nameSpace('SimParser', 'ParserItem');
SimParser.Utils = SimParser.nameSpace('SimParser', 'Utils');
SimParser.Variable = SimParser.nameSpace('SimParser', 'Variable');
SimParser.VariableManager = SimParser.nameSpace('SimParser', 'VariableManager');
SimParser.Range = SimParser.nameSpace('SimParser', 'Range');
SimParser.RangeManager = SimParser.nameSpace('SimParser', 'RangeManager');
SimParser.Constraint = SimParser.nameSpace('SimParser', 'Constraint');
SimParser.ConstraintManager = SimParser.nameSpace('SimParser', 'ConstraintManager');
SimParser.Permutation = SimParser.nameSpace('SimParser', 'Permutation');
SimParser.Function = SimParser.nameSpace('SimParser', 'Function');
SimParser.FunctionManager = SimParser.nameSpace('SimParser', 'FunctionManager');
SimParser.FilterEvaluation = SimParser.nameSpace('SimParser', 'FilterEvaluation');
SimParser.FunctionEvaluation = SimParser.nameSpace('SimParser', 'FunctionEvaluation');
SimParser.EvaluationUnit = SimParser.nameSpace('SimParser', 'EvaluationUnit');

// FILE: ParserItem.js (33eb0c18) 3/7/2014 11:24:14 AM

SimParser.ParserItem = function(parser) {
var eName = 'ParserItem';
this.getEname = function() {
return eName;
};
this.setEname = function(newEname) {
eName = newEname;
return this;
};
SimParser.ParserItem.prototype.setAttributes = function (attr, node) {
for (var i in attr) {
switch (i) {
case 'eName':
this.setEname(attr[i]);
break;
}
}
}
};

// FILE: SimUtils.js (c38dc0fb) 3/7/2014 11:24:14 AM

if (typeof(EU) === 'undefined') EU = {};
EU.debug = function(str)
{
if (typeof debug == 'function') debug(str);
if (typeof console == 'object') console.log(str);
};
SimParser.Utils = function (vUnit) {
var evUnit = vUnit;
var whiteboard = evUnit.getSimInstance().getWhiteboard();
this.greedyEvaluation = function (varsWB, varsFunc) {
var varCount = new Array(varsFunc.length);
for (var i = 0; i < varsFunc.length; i++) {
varCount[i] = countVarBindable(varsWB, varsFunc[i]);
}
var iMax = 0;
for (var i = 0; i < varCount.length; i++) {
if (varCount[i].bindable && varCount[i].count > iMax) {
iMax = varCount[i].count;
}
}
r = [];
for (var i = 0; i < varsFunc.length; i++) {
if ((varCount[i].bindable && varCount[i].count === iMax) || varCount[i].count === 0) {
r.push(varsFunc[i].name);
}
}
return r;
};
this.fullEvaluation = function (varsWB, varsFunc) {
var func = [];
var vMng = evUnit.getVariableManager();
for (var i = 0; i < varsFunc.length; i++) {
var v = varsFunc[i].vars;
var fBind = true;
for (var j = 0; j < v.length; j++) {
if ((vMng.isVarBindable(v[j])) && (varsWB.indexOf(v[j]) === -1)) {
fBind = false;
break;
}
}
if (fBind) {
func.push(varsFunc[i]);
}
}
return func;
};
this.countVarBindable = function (varsWB, varFunc) {
var r = { count: 0, bindable: true };
var v = varFunc.vars;
var vMng = evUnit.getVariableManager();
for (var i = 0; i < v.length; i++) {
if (vMng.isVarBindable(v[i])) {
if (varsWB.indexOf(v[i]) !== -1) {
r.count++;
} else {
r.bindable = false;
}
}
}
return r;
};
this.mergeWBVariables = function (varsWB) {
var r = {};
var varsWB1 = [];
for (var i = 0; i < varsWB.length; i++) {
for (var key in varsWB[i]) {
varsWB1.push({ name: key, value: varsWB[i][key] });
}
}
for (var i = 0; i < varsWB1.length; i++) {
if (r[varsWB1[i].name] === undefined) {
r[varsWB1[i].name] = [varsWB1[i].value]
}
else {
r[varsWB1[i].name].push(varsWB1[i].value);
}
}
var rr = [];
for (var key in r) {
rr.push({ name: key, value: r[key] });
}
return rr;
};
this.getWBVarNames = function (varsWB) {
var names = [];
for (var i = 0; i < varsWB.length; i++) {
names.push(varsWB[i].name);
}
return names;
};
this.getWBVarValues = function (varsWB) {
var v = [];
for (var i = 0; i < varsWB.length; i++) {
v.push(varsWB[i].value);
}
return v;
};
this.convertElementNamesToVarNames = function (vNames) {
r = [];
var vMng = evUnit.getVariableManager();
for (var j = 0; j < vNames.length; j++) {
var v = vMng.getVariableByObjectName(vNames[j]);
if (v) {
r.push(v.getName());
} else {
EU.debug('Cannot find a varible name for element:' + vNames[j]);
r.push(vNames[j]);
}
}
return r;
};
this.getConstantValues = function () {
r = { vNames: [], vValues: [] };
var vMng = evUnit.getVariableManager();
var c = vMng.getConstants();
for (var i = 0; i < c.length; i++) {
if (r.vNames.indexOf(c[i].name) === -1) {
r.vNames.push(c[i].name);
r.vValues.push(c[i].value);
}
}
return r;
};
this.getImplicitValues = function (varFuncs) {
var imvarsRequiredNames = [];
var imvarsRequiredValues = [];
var vMng = evUnit.getVariableManager();
var impvarsDeclaredNames = vMng.getVariableNames(['implicit']);
for (var i = 0; i < varFuncs.length; i++) {
var v = varFuncs[i].vars;
for (var j = 0; j < v.length; j++) {
if (impvarsDeclaredNames.indexOf(v[j]) >= 0) {
if (imvarsRequiredNames.indexOf(v[j]) === -1) {
imvarsRequiredNames.push(v[j]);
var sirVar = vMng.getVariableByName(v[j]);
imvarsRequiredValues.push(sirVar.getValues());
}
}
}
}
return { 'names': imvarsRequiredNames, 'values': imvarsRequiredValues };
};
this.getVarObject = function(varNames, varValues) {
var r = {};
for (var i = 0; i < varNames.length; i++) {
r[varNames[i]] = varValues[i];
}
return r;
};
this.getFuncVars = function () {
vFuncs = [];
var fMng = evUnit.getFunctionManager();
var fn = fMng.getFunctions();
for (var i = 0; i < fn.length; i++) {
vFuncs.push({ name: fn[i].getName(), vars: fn[i].getVarNames() });
}
return vFuncs;
};
this.writeDataOnWhiteBoard = function (data, key1, cat, item) {
if (typeof (whiteboard) === 'undefined') {
EU.debug('whiteboard object not defined.');
return;
}
whiteboard.addCategory(cat);
if (!key1) {
key1 = whiteboard.addItem(cat, item);
}
whiteboard.setItem(cat, item, data, key1)
return key1;
};
this.readDataFromWhiteBoard = function (section, item) {
var  vars = [{ 'chalk': 15 }, { 'surfaceArea': 600 }, { 'chalk': 16}];
return vars;
};
this.readDataFromWhiteBoard = function (category) {
var data = [];
var cat = whiteboard.getCategory(category);
if (cat !== null || cat !== undefined || cat.length !== 0) {
for (var p in cat) {
if (cat.hasOwnProperty(p)) {
var d = {};
d[p] = cat[p];
data.push(d);
}
}
}
return data;
};
this.packVariablesforWhiteboard = function (v) {
var vv = {};
var vMng = evUnit.getVariableManager();
for (var i = 0; i < v.length; i++) {
var objName = v[i].name;
var sirVar = vMng.getVariableByName(v[i].name);
if (sirVar && sirVar.getType() === 'binding') {
objName = sirVar.getObjectName();
}
vv[objName] = v[i].value;
}
return vv;
};
this.packFunctionforWhiteboard = function (f, v) {
var ff = {};
for (var i = 0; i < f.length; i++) {
ff[f[i]] = v[i];
}
return ff;
};
this.getFuncNames = function (algorithm, varNames, varFuncs) {
if (algorithm === 'greedy') {
return greedyEvaluation(varNames, varFuncs)
} else {
if (algorithm === 'all') {
return this.fullEvaluation(varNames, varFuncs)
} else {
EU.debug('Unsupported algorithm in function evaluation');
}
}
};
this.createSingleOutput = function (varList, funcList) {
var r = {};
var v = {};
var f = {};
for (var i = 0; i < varList.length; i++) {
v[varList[i].name] = varList[i].value;
}
for (var i = 0; i < funcList.length; i++) {
f[funcList[i].name] = funcList[i].value;
}
r = { variables: v, functions: f };
return r;
};
this.oddValue = function (v) {
return ((v === undefined) || ((v === null) ||
((typeof (v) === 'string') ||
((typeof (v) === 'number') &&
((v === Infinity) || (v === -Infinity) || (v.toString() === 'NaN'))))))
};
}
if (!Array.prototype.indexOf)
{
Array.prototype.indexOf = function(elt           )
{
var len = this.length;
var from = Number(arguments[1]) || 0;
from = (from < 0)
? Math.ceil(from)
: Math.floor(from);
if (from < 0)
from += len;
for (; from < len; from++)
{
if ((from in this) && (this[from] === elt)) {
return from;
}
}
return -1;
};
}

// FILE: Parser.js (ff7ed807) 3/7/2014 11:24:14 AM

var Parser = function () {
if(!Array.indexOf){
Array.prototype.indexOf = function(arg){
for(var i=0; i<this.length; i++){
if(this[i]==arg){
return i;
}
}
return -1;
}
}
String.trim = function(strArg) {
return strArg.replace(/^\s+|\s+$/g,"");
}
function object(o) {
function F() {}
F.prototype = o;
return new F();
}
var TNUMBER = 0;
var TOP1 = 1;
var TOP2 = 2;
var TVAR = 3;
var TFUNCALL = 4;
function Token(type_, index_, prio_, number_) {
this.type_ = type_;
this.index_ = index_ || 0;
this.prio_ = prio_ || 0;
this.number_ = (number_ !== undefined && number_ !== null) ? number_ : 0;
this.toString = function () {
switch (this.type_) {
case TNUMBER:
return this.number_;
case TOP1:
case TOP2:
case TVAR:
return this.index_;
case TFUNCALL:
return "CALL";
default:
return "Invalid Token";
}
};
}
function Expression(tokens, ops1, ops2, functions) {
this.tokens = tokens;
this.ops1 = ops1;
this.ops2 = ops2;
this.functions = functions;
}
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
escapable = /[\\\'\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
meta = {
'\b': '\\b',
'\t': '\\t',
'\n': '\\n',
'\f': '\\f',
'\r': '\\r',
"'" : "\\'",
'\\': '\\\\'
};
function escapeValue(v) {
if (typeof v === "string") {
escapable.lastIndex = 0;
return escapable.test(v) ?
"'" + v.replace(escapable, function (a) {
var c = meta[a];
return typeof c === 'string' ? c :
'\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
}) + "'" :
"'" + v + "'";
}
return v;
}
function append(a, b) {
if (Object.prototype.toString.call(a) != "[object Array]") {
return [a, b];
}
a = a.slice();
a.push(b);
return a;
}
function fac(a) {
a = Math.floor(a);
var b = a;
while (a > 1) {
b = b * (--a);
}
return b;
}
function pyt(a, b) {
return Math.sqrt(a * a + b * b);
}
function random(a) {
return Math.random() * (a || 1);
}
function Parser() {
this.success = false;
this.errormsg = "";
this.expression = "";
this.pos = 0;
this.tokennumber = 0;
this.tokenprio = 0;
this.tokenindex = 0;
this.tmpprio = 0;
this.ops1 = {
"sin": Math.sin,
"cos": Math.cos,
"tan": Math.tan,
"asin": Math.asin,
"acos": Math.acos,
"atan": Math.atan,
"sqrt": Math.sqrt,
"log": Math.log,
"exp": Math.exp,
"abs": Math.abs,
"ceil": Math.ceil,
"floor": Math.floor,
"round": Math.round,
"if": function(x){return x;},
"-": function(x){return -x;},
"!": function(x){return !x;},
"{": function(a){eval('var z = {'+a+'}'); return z;}
};
this.ops2 = {
"+": function(a,b){return Number(a) + Number(b);},
"-": function(a,b){return a - b;},
"*": function(a,b){return a * b;},
"/": function(a,b){return a / b;},
"%": function(a,b){return a % b;},
",":  append,
"&&": function(a,b){return a&&b;},
"||": function(a,b){return a||b;},
"^":   Math.pow,
"pow": Math.pow,
"?":  function(a,b){if(a){return b;}else{return null;};},
":":  function(ab,c){if(ab === null){return c;}else{return ab;};},
"[]": function(a,b){return a[b];},
"==": function(a,b){return a == b;},
"!=": function(a,b){return a != b;},
"<":  function(a,b){return a <  b;},
"<=": function(a,b){return a <= b;},
">":  function(a,b){return a >  b;},
">=": function(a,b){return a >= b;}
};
this.functions = {
"Math.atan2": Math.atan2,
"Math.sin": Math.sin,
"Math.cos": Math.cos,
"Math.floor": Math.floor,
"Math.min": Math.min,
"Math.max": Math.max,
"Math.pow": Math.pow,
"Math.rand": Math.random,
"Math.random": Math.random,
"Math.round": Math.round,
"Math.sqrt": Math.sqrt,
"atan2": Math.atan2,
"fac": fac,
"min": Math.min,
"max": Math.max,
"pow": Math.pow,
"random": random,
"rand": random,
"pyt": pyt
};
this.consts = {
"E": Math.E,
"e": Math.E,
"PI": Math.PI,
"pi": Math.PI
};
}
Parser.parbracketsAndCo = function (expr){
expr = enclosers(expr, '(', ')', '');
expr = enclosers(expr, '[', ']', '[]');
expr = enclosers(expr, '{', '}', '{');
return expr;
function enclosers(expr, delimOpen , delimClose, name){
var newExp = "",
char = 0,
pos = 0,
charOpen = delimOpen.charAt(0),
charClose = delimClose.charAt(0),
countingOpenedGroup = 0;
while(pos < expr.length) {
char = expr.charAt(pos);
if (char == charOpen) {
countingOpenedGroup ++;
if (delimOpen == '{')
newExp += name + '(' +'`';
else
newExp += name + '(';
}
else if (char == charClose) {
countingOpenedGroup --;
if(countingOpenedGroup < 0){
noIllegalGroup(countingOpenedGroup, delimOpen , delimClose);
}
if (delimOpen == '{')
newExp += '`' + ')';
else
newExp += ')';
}
else {
newExp += char;
}
pos++;
}
noIllegalGroup(countingOpenedGroup, delimOpen , delimClose);
return newExp;
}
function noIllegalGroup(countingOpenedGroup, delimOpen , delimClose){
if(countingOpenedGroup < 0) {
throw new Error('parse error : ' + delimOpen + '...'
+ delimClose + ', missing opening character');
}
else if(countingOpenedGroup > 0) {
throw new Error('parse error : ' + delimOpen + '...'
+ delimClose + ', missing closing character');
}
}
}
Parser.evaluate = function (expr, variables) {
return Parser.parse(expr).evaluate(variables);
};
Parser.Expression = Expression;
Parser.values = {
sin: Math.sin,
cos: Math.cos,
tan: Math.tan,
asin: Math.asin,
acos: Math.acos,
atan: Math.atan,
sqrt: Math.sqrt,
log: Math.log,
abs: Math.abs,
ceil: Math.ceil,
floor: Math.floor,
"Math.floor": Math.floor,
round: Math.round,
random: random,
rand: random,
fac: fac,
exp: Math.exp,
min: Math.min,
max: Math.max,
"Math.max": Math.max,
pyt: pyt,
pow: Math.pow,
atan2: Math.atan2,
E: Math.E,
PI: Math.PI
};
var PRIMARY  = 1 << 0;
var OPERATOR = 1 << 1;
var FUNCTION = 1 << 2;
var LPAREN   = 1 << 3;
var RPAREN   = 1 << 4;
var COMMA    = 1 << 5;
var SIGN     = 1 << 6;
var CALL     = 1 << 7;
Parser.prototype = {
parse: function (expr) {
expr = Parser.parbracketsAndCo(expr);
this.errormsg = "";
this.success = true;
var operstack = [];
var tokenstack = [];
this.tmpprio = 0;
var expected = (PRIMARY | LPAREN | FUNCTION | SIGN);
var noperators = 0;
var lptsl = -1;
this.expression = expr;
this.pos = 0;
while (this.pos < this.expression.length) {
var cc = this.expression.charAt(this.pos);
if (this.isOperator()) {
if (this.isSign() && (expected & SIGN)) {
if (this.isNegativeSign()) {
this.tokenprio = 2;
this.tokenindex = "-";
this.addfunc(tokenstack, operstack, TOP1);
noperators += 1;
}
expected = (PRIMARY | LPAREN | FUNCTION | SIGN);
}
else if (this.isComment()) {
}
else {
if ((expected & OPERATOR) === 0) {
this.error_parsing(this.pos, "unexpected operator");
}
this.addfunc(tokenstack, operstack, TOP2);
noperators += 2;
expected = (PRIMARY | LPAREN | FUNCTION | SIGN);
}
}
else if (this.isNumber()) {
if ((expected & PRIMARY) === 0) {
this.error_parsing(this.pos, "unexpected number");
}
var token = new Token(TNUMBER, 0, 0, this.tokennumber);
tokenstack.push(token);
expected = (OPERATOR | RPAREN | COMMA);
}
else if (this.isString()) {
if ((expected & PRIMARY) === 0) {
this.error_parsing(this.pos, "unexpected string");
}
var token = new Token(TNUMBER, 0, 0, this.tokennumber);
tokenstack.push(token);
expected = (OPERATOR | RPAREN | COMMA);
}
else if (this.isLeftParen()) {
if ((expected & LPAREN) === 0) {
this.error_parsing(this.pos, "unexpected \"(\"");
}
if (expected & CALL) {
this.tokenprio = -2;
this.tokenindex = -1;
this.addfunc(tokenstack, operstack, TFUNCALL);
noperators += 2;
lptsl = tokenstack.length;
}
expected = (PRIMARY | LPAREN | FUNCTION | SIGN | RPAREN);
}
else if (this.isRightParen()) {
if ((expected & RPAREN) === 0) {
this.error_parsing(this.pos, "unexpected \")\"");
}
if (lptsl == tokenstack.length) {
var token = new Token(TNUMBER, 0, 0, '');
tokenstack.push(token);
lptsl = -1;
}
expected = (OPERATOR | RPAREN | COMMA | LPAREN | CALL);
}
else if (this.isComma()) {
if ((expected & COMMA) === 0) {
this.error_parsing(this.pos, "unexpected \",\"");
}
this.addfunc(tokenstack, operstack, TOP2);
noperators += 2;
expected = (PRIMARY | LPAREN | FUNCTION | SIGN);
}
else if (this.isConst()) {
if ((expected & PRIMARY) === 0) {
this.error_parsing(this.pos, "unexpected constant");
}
var consttoken = new Token(TNUMBER, 0, 0, this.tokennumber);
tokenstack.push(consttoken);
expected = (OPERATOR | RPAREN | COMMA);
}
else if (this.isOp2()) {
if ((expected & FUNCTION) === 0) {
this.error_parsing(this.pos, "unexpected function");
}
this.addfunc(tokenstack, operstack, TOP2);
noperators += 2;
expected = (LPAREN);
}
else if (this.isOp1()) {
if ((expected & FUNCTION) === 0) {
this.error_parsing(this.pos, "unexpected function");
}
this.addfunc(tokenstack, operstack, TOP1);
noperators += 1;
expected = (LPAREN);
}
else if (this.isVar()) {
if ((expected & PRIMARY) === 0) {
this.error_parsing(this.pos, "unexpected variable");
}
var vartoken = new Token(TVAR, this.tokenindex, 0, 0);
tokenstack.push(vartoken);
expected = (OPERATOR | RPAREN | COMMA | LPAREN | CALL);
}
else if (this.isWhite()) {
}
else {
if (this.errormsg === "") {
this.error_parsing(this.pos, "unknown character");
}
else {
this.error_parsing(this.pos, this.errormsg);
}
}
}
if (this.tmpprio < 0 || this.tmpprio >= 10) {
this.error_parsing(this.pos, "unmatched \"()\"");
}
while (operstack.length > 0) {
var tmp = operstack.pop();
tokenstack.push(tmp);
}
if (noperators + 1 !== tokenstack.length) {
this.error_parsing(this.pos, "parity");
}
return new Expression(tokenstack, object(this.ops1), object(this.ops2), object(this.functions));
},
evaluate: function (expr, variables) {
return this.parse(expr).evaluate(variables);
},
error_parsing: function (column, msg) {
this.success = false;
this.errormsg = "parse error: " + msg + "; col. " + column + " in: '" + this.expression + "'";
throw new Error(this.errormsg);
},
addfunc: function (tokenstack, operstack, type_) {
var operator = new Token(type_, this.tokenindex, this.tokenprio + this.tmpprio, 0);
while (operstack.length > 0) {
if (operator.prio_ <= operstack[operstack.length - 1].prio_) {
tokenstack.push(operstack.pop());
}
else {
break;
}
}
operstack.push(operator);
},
isNumber: function () {
var r = false;
var str = "";
while (this.pos < this.expression.length) {
var code = this.expression.charCodeAt(this.pos);
if ((code >= 48 && code <= 57) || code === 46) {
str += this.expression.charAt(this.pos);
this.pos++;
this.tokennumber = parseFloat(str);
r = true;
}
else {
break;
}
}
return r;
},
unescape: function (v, pos) {
var buffer = [];
var escaping = false;
var i;
for (i = 0; i < v.length; i++) {
var c = v.charAt(i);
if (escaping) {
switch (c) {
case "'":
buffer.push("'");
break;
case '\\':
buffer.push('\\');
break;
case '/':
buffer.push('/');
break;
case 'b':
buffer.push('\b');
break;
case 'f':
buffer.push('\f');
break;
case 'n':
buffer.push('\n');
break;
case 'r':
buffer.push('\r');
break;
case 't':
buffer.push('\t');
break;
case 'u':
var codePoint = parseInt(v.substring(i + 1, i + 5), 16);
buffer.push(String.fromCharCode(codePoint));
i += 4;
break;
default:
throw this.error_parsing(pos + i, "Illegal escape sequence: '\\" + c + "'");
}
escaping = false;
} else {
if (c == '\\') {
escaping = true;
} else {
buffer.push(c);
}
}
}
return buffer.join('');
},
isString: function () {
var r = false;
var str = "";
var startpos = this.pos;
var char0 = this.expression.charAt(this.pos);
if (this.pos < this.expression.length && (char0 == "'" || char0=='"' || char0=='`') ) {
this.pos++;
while (this.pos < this.expression.length) {
var char = this.expression.charAt(this.pos);
if (char != char0 || str.slice(-1) == "\\") {  //String must begin and end with the same type of quote
str += this.expression.charAt(this.pos);
this.pos++;
}
else {
this.pos++;
this.tokennumber = this.unescape(str, startpos);
r = true;
break;
}
}
}
return r;
},
isConst: function () {
var str;
for (var i in this.consts) {
if (true) {
var L = i.length;
str = this.expression.substr(this.pos, L);
if (i === str) {
this.tokennumber = this.consts[i];
this.pos += L;
return true;
}
}
}
return false;
},
isOperator: function () {
var opsyns = {
"+": ["+",0],
"-": ["-",0],
"&&": ["&&",-3],
"and": ["&&",-3],
"&amp;&amp;": ["&&",-3],
"||": ["||",-4],
"or": ["||",-4],
"*": ["*",1],
"/": ["/",2],
"%": ["%",2],
"^": ["^",3],
"?": ["?",-5],
":": [":",-6],
"if": ["+",-4],
"then": ["?",-5],
"else": [":",-6],
"[]": ["[]",4],
"===": ["==",-2],
"==": ["==",-2],
"=": ["==",-2],
"!==": ["!=",-2],
"!=": ["!=",-2],
"<>": ["!=",-2],
"<=": ["<=",-1],
"<": ["<",-1],
">=": [">=",-1],
">": [">",-1],
"&lt;=": ["<=",-1],
"&lt;": ["<",-1],
"&gt;=": [">=",-1],
"&gt;": [">",-1]
};
for (var key in opsyns) {
var found = true;
var equiv = opsyns[key][0];
var thischar = this.expression.charAt(this.pos);
for (var i=0; i<key.length; i+=1) {
found = found && this.expression.charAt(this.pos + i).toLowerCase() === key.charAt(i);
}
if (found) {
this.tokenindex = equiv;
this.tokenprio = opsyns[key][1];
this.pos += key.length;
return true;
};
}
return false;
},
isSign: function () {
var char = this.expression.charAt(this.pos - 1);
var prevchar = this.expression.charAt(this.pos - 2);
if (char === "-" || char === "+" || (prevchar+char) === "if") {
return true;
}
return false;
},
isPositiveSign: function () {
var char = this.expression.charAt(this.pos - 1);
if (char === "+") {
return true;
}
return false;
},
isNegativeSign: function () {
var char = this.expression.charAt(this.pos - 1);
if (char === "-") {
return true;
}
return false;
},
isLeftParen: function () {
var char = this.expression.charAt(this.pos);
if (char === "(") {
this.pos++;
this.tmpprio += 10;
return true;
}
return false;
},
isRightParen: function () {
var char = this.expression.charAt(this.pos);
if (char === ")") {
this.pos++;
this.tmpprio -= 10;
return true;
}
return false;
},
isComma: function () {
var char = this.expression.charAt(this.pos);
if (char === ",") {
this.pos++;
this.tokenprio = -1;
this.tokenindex = ",";
return true;
}
return false;
},
isWhite: function () {
var code = this.expression.charCodeAt(this.pos);
if (code === 32 || code === 9 || code === 10 || code === 13) {
this.pos++;
return true;
}
return false;
},
isOp1: function () {
var i, str = "";
for (i = this.pos; i < this.expression.length; i++) {
var c = this.expression.charAt(i);
if ( (c.toUpperCase() === c.toLowerCase()) && (c != '{') ) {
if (i === this.pos || c < '0' || c > '9') {
break;
}
}
str += c;
}
if (str.length > 0 && (str in this.ops1)) {
this.tokenindex = str;
this.tokenprio = 5;
this.pos += str.length;
return true;
}
return false;
},
isOp2: function () {
var i, str = "";
for (i = this.pos; i < this.expression.length; i++) {
var c = this.expression.charAt(i);
if (c.toUpperCase() === c.toLowerCase()) {
if (i === this.pos || c < '0' || c > '9') {
break;
}
}
str += c;
}
if (str.length > 0 && (str in this.ops2)) {
this.tokenindex = str;
this.tokenprio = 5;
this.pos += str.length;
return true;
}
return false;
},
isVar: function () {
var i, str = "";
for (i = this.pos; i < this.expression.length; i++) {
var c = this.expression.charAt(i);
if ((c.toUpperCase() === c.toLowerCase()) && (c !== '_') && (c !== '.')) {
if (i === this.pos || c < '0' || c > '9') {
break;
}
}
str += c;
}
if (str.length > 0) {
this.tokenindex = str;
this.tokenprio = 4;
this.pos += str.length;
return true;
}
return false;
},
isComment: function () {
var char = this.expression.charAt(this.pos - 1);
if (char === "/" && this.expression.charAt(this.pos) === "*") {
this.pos = this.expression.indexOf("*/", this.pos) + 2;
if (this.pos === 1) {
this.pos = this.expression.length;
}
return true;
}
return false;
}
};
Expression.prototype = {
simplify: function (values) {
values = values || {};
var nstack = [];
var newexpression = [];
var f, i, item, n1, n2;
var L = this.tokens.length;
for (i = 0; i < L; i++) {
item = this.tokens[i];
var type_ = item.type_;
if (type_ === TNUMBER) {
nstack.push(item);
}
else if (type_ === TVAR && (item.index_ in values)) {
item = new Token(TNUMBER, 0, 0, values[item.index_]);
nstack.push(item);
}
else if (type_ === TOP2 && nstack.length > 1) {
n2 = nstack.pop();
n1 = nstack.pop();
f = this.ops2[item.index_];
item = new Token(TNUMBER, 0, 0, f(n1.number_, n2.number_));
nstack.push(item);
}
else if (type_ === TOP1 && nstack.length > 0) {
n1 = nstack.pop();
f = this.ops1[item.index_];
item = new Token(TNUMBER, 0, 0, f(n1.number_));
nstack.push(item);
}
else {
while (nstack.length > 0) {
newexpression.push(nstack.shift());
}
newexpression.push(item);
}
}
while (nstack.length > 0) {
newexpression.push(nstack.shift());
}
return new Expression(newexpression, object(this.ops1), object(this.ops2), object(this.functions));
},
substitute: function (variable, expr) {
if (!(expr instanceof Expression)) {
expr = new Parser().parse(String(expr));
}
var newexpression = [];
var L = this.tokens.length;
var i, item;
for (i = 0; i < L; i++) {
item = this.tokens[i];
var type_ = item.type_;
if (type_ === TVAR && item.index_ === variable) {
for (var j = 0; j < expr.tokens.length; j++) {
var expritem = expr.tokens[j];
var replitem = new Token(expritem.type_, expritem.index_, expritem.prio_, expritem.number_);
newexpression.push(replitem);
}
}
else {
newexpression.push(item);
}
}
var ret = new Expression(newexpression, object(this.ops1), object(this.ops2), object(this.functions));
return ret;
},
evaluate: function (values) {
values = values || {};
var nstack = [];
var f, i, item, n1, n2;
var L = this.tokens.length;
for (i = 0; i < L; i++) {
item = this.tokens[i];
var type_ = item.type_;
if (type_ === TNUMBER) {
nstack.push(item.number_);
}
else if (type_ === TOP2) {
n2 = nstack.pop();
n1 = nstack.pop();
f = this.ops2[item.index_];
nstack.push(f(n1, n2));
}
else if (type_ === TVAR) {
if (item.index_ in values) {
nstack.push(values[item.index_]);
}
else if (item.index_ in this.functions) {
nstack.push(this.functions[item.index_]);
}
else {
throw new Error("undefined variable: " + item.index_);
}
}
else if (type_ === TOP1) {
n1 = nstack.pop();
f = this.ops1[item.index_];
nstack.push(f(n1));
}
else if (type_ === TFUNCALL) {
n1 = nstack.pop();
f = nstack.pop();
if (f.apply && f.call) {
if (Object.prototype.toString.call(n1) == "[object Array]") {
nstack.push(f.apply(undefined, n1));
}
else {
nstack.push(f.call(undefined, n1));
}
}
else {
throw new Error(f + " is not a function");
}
}
else {
throw new Error("invalid Expression");
}
}
if (nstack.length > 1) {
throw new Error("invalid Expression (parity)");
}
return nstack[0];
},
toString: function (toJS) {
var nstack = [];
var L = this.tokens.length;
var f, i, item, n1, n2;
for (i = 0; i < L; i++) {
item = this.tokens[i];
var type_ = item.type_;
if (type_ === TNUMBER) {
nstack.push(escapeValue(item.number_));
}
else if (type_ === TOP2) {
n2 = nstack.pop();
n1 = nstack.pop();
f = item.index_;
if (toJS && f == "^") {
nstack.push("Math.pow(" + n1 + "," + n2 + ")");
}
else {
nstack.push("(" + n1 + f + n2 + ")");
}
}
else if (type_ === TVAR) {
nstack.push(item.index_);
}
else if (type_ === TOP1) {
n1 = nstack.pop();
f = item.index_;
if (f === "-") {
nstack.push("(" + f + n1 + ")");
}
else {
nstack.push(f + "(" + n1 + ")");
}
}
else if (type_ === TFUNCALL) {
n1 = nstack.pop();
f = nstack.pop();
nstack.push(f + "(" + n1 + ")");
}
else {
throw new Error("invalid Expression");
}
}
if (nstack.length > 1) {
throw new Error("invalid Expression (parity)");
}
return nstack[0];
},
toLaTeX: function () {
var nstack = [];
var f, i, item, n1, n2;
var L = this.tokens.length;
for (i = 0; i < L; i++) {
item = this.tokens[i];
var type_ = item.type_;
if (type_ === TNUMBER) {
nstack.push(escapeValue(item.number_));
}
else if (type_ === TOP2) {
n2 = nstack.pop();
n1 = nstack.pop();
f = item.index_;
if (f == "^") {
nstack.push("{" + n1 + "}^{" + n2 + "}");
}
else if (f == "*") {
nstack.push(n1 + " \\times " + n2);
}
else if (f == "/") {
nstack.push("\\frac{" + n1 + "}{" + n2 + "}");
}
else {
nstack.push(n1 + " " + f + " " + n2);
}
}
else if (type_ === TVAR) {
nstack.push(item.index_);
}
else if (type_ === TOP1) {
n1 = nstack.pop();
f = item.index_;
if (f === "-") {
nstack.push(f + n1);
}
else {
nstack.push(f + ' ' + n1);
}
}
else if (type_ === TFUNCALL) {
n1 = nstack.pop();
f = nstack.pop();
nstack.push(f + ' ' + n1);
}
else {
throw new Error("invalid Expression");
}
}
if (nstack.length > 1) {
throw new Error("invalid Expression (parity)");
}
return nstack[0];
},
variables: function () {
var L = this.tokens.length;
var vars = [];
var i;
for (i = 0; i < L; i++) {
var item = this.tokens[i];
if (item.type_ === TVAR && (vars.indexOf(item.index_) == -1)) {
vars.push(item.index_);
}
}
return vars;
},
toJSFunction: function (param, variables) {
var f = new Function(param, "with(Parser.values) { return " + this.simplify(variables).toString(true) + "; }");
return f;
}
};
return Parser;
} ();

// FILE: Constraints.js (4a38f906) 3/7/2014 11:24:13 AM

SimParser.Constraint = function() {
SimParser.ParserItem.call(this);
var constraint;
var boundedConstraint;
var formulaName;
var name;
var varList;
var type;
this.getName = function () {
return name;
}
this.setName = function (newName) {
name = newName;
}
this.getFormulaName = function () {
return formulaName;
}
this.setFormulaName = function (newFormulaName) {
formulaName = newFormulaName;
}
this.getConstraint = function () {
return constraint;
}
this.setConstraint = function (newConstraint) {
constraint = newConstraint;
}
this.getType = function () {
return type;
}
this.setType = function (newType) {
type = newType;
}
this.isConstraintBindable = function (varsWB) {
var varNames = getVarNames();
r = true;
for (var i = 0; i < varNames.length; i++) {
if (varsWB.indexOf(varNames[i]) === -1) {
r = false;
break;
}
}
return r;
}
this.setAttributes = function (attr, node) {
if (attr.name !== undefined) {
this.setName(attr.name);
}
if (attr.formula !== undefined) {
this.setFormulaName(attr.formula);
}
if (attr.clause !== undefined) {
this.setConstraint(attr.clause);
}
if (attr.type !== undefined) {
this.setType(attr.type);
}
}
this.bindConstraint = function (vars) {
varList = [];
var c = constraint;
tokens = c.match(/\w+/g);
for (var i = 0; i < tokens.length; i++) {
for (var j = 0; j < vars.length; j++) {
if (tokens[i] === vars[j].getName()) {
varList.push(vars[j]);
break;
}
}
}
var strVar = new String();
for (var i = 0; i < varList.length; i++) {
strVar = strVar + varList[i].getName() + '=' + varList[i].getValue() + ';';
}
c = c.replace(/\bor\b/g, '||').replace(/\band\b/g, '&&');
boundedConstraint = strVar + '(' + c +')';
return boundedConstraint;
}
this.evaluate = function () {
if (boundedConstraint)
return eval(boundedConstraint);
}
this.getVarNames = function () {
var c = constraint;
var cNames = [];
var tokens = c.match(/\w+/g);
for (var i = 0; i < tokens.length; i++) {
if (tokens[i].toString().toLowerCase() === 'and' ||
tokens[i].toString().toLowerCase() === 'or' ||
parseFloat(tokens[i] !== NaN)) {
;
}
else {
cNames.push(tokens[i]);
}
}
return cNames;
}
this.setEname('Constraint');
}
SimParser.Constraint.prototype = new SimParser.ParserItem();
SimParser.Constraint.prototype.constructor = SimParser.Constraint;

// FILE: ConstraintManager.js (0b955c71) 3/7/2014 11:24:13 AM

SimParser.ConstraintManager = function() {
var constraints = [];
var that = this;
var subs = { '&lt;': '<', '&gt;': '>'};
this.getConstraints = function () {
return constraints;
};
this.setConstraints = function (root) {
constraints = [];
var r = root.getElementsByTagName('constraints').item(0);
if (r !== null && r.hasChildNodes()) {
for (var i = 0; i < r.childNodes.length; i++) {
var attr = {};
if (r.childNodes[i].nodeName[0] === '#') {
continue;
}
for (var j = 0; j < r.childNodes[i].attributes.length; j++) {
attr[r.childNodes[i].attributes[j].name] = r.childNodes[i].attributes[j].nodeValue;
}
c = new SimParser.Constraint();
c.setAttributes(attr, r);
constraints.push(c);
}
}
};
this.getConstraintNames = function (funcName, filter) {
var cNames = [];
if (typeof (filter) === 'undefined') {
filter = 'pre-condition';
}
for (var i = 0; i < constraints.length; i++) {
if (constraints[i].getFormulaName() === funcName && constraints[i].getType() === filter) {
cNames.push(constraints[i].getName());
}
}
return cNames;
};
this.getConstraintByName = function (cName, filter) {
if (typeof (filter) === 'undefined') {
filter = 'pre-condition';
}
for (var i = 0; i < constraints.length; i++) {
if (constraints[i].getName() === cName && constraints[i].getType() === filter) {
return constraints[i];
}
}
};
this.evalPreConstraints = function (fName, varValueList) {
var cEval = true;
if (typeof (fName) === 'undefined') {
fName = '';
}
var cn = that.getConstraintNames(fName, 'pre-condition');
for (var j = 0; j < cn.length; j++) {
var cnt = that.getConstraintByName(cn[j]);
var r = evalConstraint(cnt.getConstraint(), varValueList);
if (typeof (r) !== 'boolean') {
cEval = false;
}
else {
cEval = cEval && r;
}
if (!cEval) {
break;
}
}
return cEval;
};
this.evalPostConstraints = function (fName, varValueList, funcValueList) {
var cEval = true;
if (typeof (fName) === 'undefined') {
fName = '';
}
var varList = [];
for (var i = 0; i < varValueList.length; i++) {
varList.push(varValueList[i]);
}
for (var i = 0; i < funcValueList.length; i++) {
if (typeof (funcValueList[i]) !== 'undefined') {
varList.push(funcValueList[i]);
}
}
var cn = that.getConstraintNames(fName, 'post-condition');
for (var j = 0; j < cn.length; j++) {
var cnt = that.getConstraintByName(cn[j], 'post-condition');
var r = evalConstraint(cnt.getConstraint(), varList);
if (typeof (r) !== 'boolean') {
cEval = false;
}
else {
cEval = cEval && r;
}
if (!cEval) {
break;
}
}
return cEval;
};
var evalConstraint = function (constraint, vars) {
var result = null;
var varList = [];
var c = constraint;
var variables = vars;
var nonVariableTokens = [];
var tokens = c.match(/\w+/g);
for (var i = 0; i < tokens.length; i++) {
var tokenIsVariable = false;
for (var j = 0; j < variables.length; j++) {
if (tokens[i] === variables[j].name) {
varList.push(variables[j]);
tokenIsVariable = true;
break;
}
}
if ((isNaN(tokens[i])) && (tokens[i] !== 'and') && (tokens[i] !== 'or') && (tokenIsVariable == false) && (!arrayContains(nonVariableTokens, tokens[i]))) {
var pattern = new RegExp(tokens[i], 'g');
var newPatten = "'" + tokens[i] + "'";
c = c.replace(pattern, newPatten);
nonVariableTokens.push(tokens[i]);
}
}
var strVar = new String();
for (var i = 0; i < varList.length; i++) {
if (varList[i].value[0] != null) {
if (isNaN(varList[i].value[0])) {
strVar = strVar + varList[i].name + "='" + varList[i].value + "';";
}
else {
strVar = strVar + varList[i].name + '=' + varList[i].value + ';';
}
}
else if (varList[i].value != null) {
if (isNaN(varList[i].value)) {
strVar = strVar + varList[i].name + "='" + varList[i].value + "';";
}
else {
strVar = strVar + varList[i].name + '=' + varList[i].value + ';';
}
}
}
c = c.replace(/\bor\b/g, '||').replace(/\band\b/g, '&&');
try {
result = eval(strVar + '(' + c + ')');
}
catch (err) {
result = err.message;
}
return result;
};
var arrayContains = function(arr, obj) {
var i = arr.length;
while (i--) {
if (arr[i] === obj) {
return true;
}
}
return false;
};
};

// FILE: Permutations.js (f3e6b91c) 3/7/2014 11:24:14 AM

SimParser.Permutation = function(vars) {
var n = vars.length;
var pia = [];
var piv = [];
var rs = [];
var init = function () {
rs = [];
for (var i = 0; i < n; i++) {
pia[i] = 0;
piv[i] = vars[i].length - 1;
}
}
var next = function () {
for (var i = n - 1; i >= 0; i--) {
if (pia[i] < piv[i]) {
pia[i]++;
return true;
}
else {
var j = i - 1;
while ((j >= 0) && (pia[j] === piv[j])) j--;
if (j < 0) {
return false
} else {
pia[j]++;
for (var k = j + 1; k <= i; k++) pia[k] = 0;
return true;
}
}
}
}
var currentPermutation = function () {
var cp = [];
for (i = 0; i < n; i++) {
cp.push(vars[i][pia[i]]);
}
return cp;
}
var run = function () {
init();
do {
rs.push(currentPermutation());
}
while (next());
return rs;
}
return run();
};

// FILE: Functions.js (f72ba796) 3/7/2014 11:24:13 AM

SimParser.Function = function() {
SimParser.ParserItem.call(this);
var name;
var nameProxy;
var equation='';
var varList = [];
var value;
var context;
var type = 'regualar';
var variable;
var parser = new Parser();
var lookup;
var code = '';
var func;
var keyName = undefined;
var filter = '';
var scoreable = 'yes';
var orderedEvaluation = false;
var depLevel = -1;
var compOrder = -1;
this.bindVariables = function (vars) {
var vList = [];
var p = parser.parse(equation);
for (var i = 0; i < p.tokens.length; i++) {
if (p.tokens[i].type_ === 3) {
for (var j = 0; j < vars.length; j++) {
var v = undefined;
if (vars[j].getName() === p.tokens[i].index_) {
v = vars[j];
break;
}
}
if (v) {
vList.push(v);
}
}
}
this.setVarList(vList);
}
this.evaluateEquation = function () {
var bindList= {};
for (var i = 0; i < varList.length; i++) {
bindList[varList[i].getName()] = varList[i].getValue();
}
return parser.parse(this.getEquation()).evaluate(bindList);
}
this.testAnswer = function(testValue) {
return (value === testValue);
}
this.getValue = function () {
return value;
}
this.setValue = function (newValue) {
value = newValue;
return this;
}
this.getEquation = function () {
return equation;
}
this.setEquation = function (newEquation) {
equation = newEquation;
return this;
}
this.getVarList = function () {
return varList;
}
this.setVarList = function (vars) {
varList = vars;
return this;
}
this.setVarList = function (newVarList) {
varList = newVarList;
return this;
}
this.getName = function () {
return name;
}
this.setName = function (newName) {
name = newName;
return this;
}
this.getContext = function () {
return context;
}
this.setContext = function (newContext) {
context = newContext;
return this;
}
this.getDepLevel = function () {
return depLevel;
}
this.setDepLevel = function (level) {
depLevel = level;
}
this.getCompOrder = function () {
return compOrder;
}
this.setCompOrder = function (newCompOrder) {
compOrder = newCompOrder;
}
this.getVariable = function () {
return variable;
}
this.setVariable = function (newVariable) {
variable = newVariable;
}
this.getCode = function () {
return code;
}
this.setCode = function (newCode) {
code = newCode;
}
this.getScoreable = function () {
return scoreable;
}
this.setScoreable = function (newScorable) {
if (newScorable !== 'no') {
newScorable='yes'
}
scoreable = newScorable;
}
this.getOrderedEvaluation = function () {
return orderedEvaluation;
}
this.setOrderedEvaluation = function (ordered) {
if (ordered === 'yes') {
orderedEvaluation = true;
}
else {
orderedEvaluation = false;
}
}
this.getFunction = function () {
if (!func) {
var vNames = this.getVarNames();
var params = vNames.join(',');
func = new Function(params, 'return ' + this.getCode());
}
return func;
}
this.getVarNames = function () {
var fNames = [];
var p = parser.parse(equation);
for (var i = 0; i < p.tokens.length; i++) {
if (p.tokens[i].type_ === 3 && fNames.indexOf(p.tokens[i].index_) === -1 && p.tokens[i].index_ !== name) {
if ((p.tokens[i].index_.length < 5) || (p.tokens[i].index_.substring(0,5).toLowerCase() != 'math.')) {
fNames.push(p.tokens[i].index_);
}
}
}
return fNames;
}
this.getType = function () {
return type;
}
this.setType = function (t) {
type = t;
}
this.getKeyName = function () {
return keyName;
}
this.setKeyName = function (k) {
keyName = k;
}
this.getLookupValue = function (v) {
if (!lookup) {
lookup = {};
lookup = eval('(' + equation + ')');
}
return lookup[v];
}
this.getFilter = function () {
return filter;
}
this.setFilter = function (f) {
filter = f;
}
this.getProxyName = function () {
return nameProxy;
}
this.setProxyName = function (p) {
nameProxy = p;
}
this.setAttributes = function (attr, node) {
if (attr.type !== undefined) this.setType(attr.type);
if (attr.nameProxy !== undefined) this.setProxyName(attr.nameProxy);
if (attr.name !== undefined) this.setName(attr.name);
if (attr.formula !== undefined) this.setEquation(attr.formula);
if (attr.context !== undefined) this.setContext(attr.context);
if (attr.value !== undefined) this.setValue(attr.value);
if (attr.variable !== undefined) this.setVariable(attr.variable);
if (attr.code !== undefined) {
if (this.getType() === 'javascript') {
this.setEquation(attr.code);
}
this.setCode(attr.code);
}
if (attr.keyName !== undefined) this.setKeyName(attr.keyName);
if (attr.filter !== undefined) this.setFilter(attr.filter);
this.setScoreable(attr.scoreable);
if (attr.orderedEvaluation !== undefined) this.setOrderedEvaluation(attr.orderedEvaluation);
}
this.setEname('Equation');
};
SimParser.Function.prototype = new SimParser.ParserItem();
SimParser.Function.prototype.constructor = SimParser.Function;

// FILE: FunctionManager.js (056fcbc2) 3/7/2014 11:24:13 AM

SimParser.FunctionManager = function (eUnit) {
var functions = [];
var lfunctions = [];
var jfunctions = [];
var that = this;
var maxDepLevel = 0;
var depTreeExists = false;
var currentOrder = 0;
var varCurrent = [];
var evUnit = eUnit;
var scoringTable = evUnit.getSimInstance().getScoringTable();
var cMng = evUnit.getConstraintManager();
function mergeArrays(arrayOne, arrayTwo) {
var result = [];
for (var i = 0; i < arrayOne.length; i++) {
result.push(arrayOne[i]);
}
for (var i = 0; i < arrayTwo.length; i++) {
result.push(arrayTwo[i]);
}
return result;
}
function compareArrays(arrayOne, arrayTwo) {
for (var i = 0; i < arrayOne.length; i++) {
if (arrayTwo.indexOf(arrayOne[i]) === -1) {
return false;
}
}
return true;
}
this.getMaxDepLevel = function () {
return maxDepLevel;
}
this.setMaxDepLevel = function (level) {
maxDepLevel = level;
}
this.getFunctions = function () {
return functions;
}
this.getLFunctions = function () {
return lfunctions;
}
this.getJFunctions = function () {
return jfunctions;
}
this.setFunctions = function (root) {
functions = [];
var r = root.getElementsByTagName('functions').item(0);
if (r !== null && r.hasChildNodes()) {
for (var i = 0; i < r.childNodes.length; i++) {
var attr = {};
if (r.childNodes[i].nodeName[0] === '#') {
continue;
}
for (var j = 0; j < r.childNodes[i].attributes.length; j++) {
attr[r.childNodes[i].attributes[j].name] = r.childNodes[i].attributes[j].nodeValue;
}
var newFunction = new SimParser.Function();
newFunction.setAttributes(attr, r);
if (newFunction.getScoreable() !== 'no') {
scoringTable.addElement(newFunction.getName(), 'output');
}
if (attr.type === 'lookup') {
lfunctions.push(newFunction);
}
else {
functions.push(newFunction);
}
}
}
}
this.getFunctionNames = function () {
var fNames = [];
for (var i = 0; i < functions.length; i++) {
fNames.push(functions[i].getName());
}
return fNames;
}
this.getFunctionByName = function (funcName) {
for (var i = 0; i < functions.length; i++) {
if (functions[i].getName() === funcName) {
return functions[i];
}
}
for (var i = 0; i < lfunctions.length; i++) {
if (lfunctions[i].getName() === funcName) {
return lfunctions[i];
}
}
for (var i = 0; i < jfunctions.length; i++) {
if (jfunctions[i].getName() === funcName) {
return jfunctions[i];
}
}
}
this.getLFunctionByName = function (funcName) {
for (var i = 0; i < functions.length; i++) {
if (lfunctions[i].getName() === funcName) {
return lfunctions[i];
}
}
}
this.evaluateOrderedFunctions = function () {
var evaluationSucceed = true;
var iCompOrder = 0;
var vMng = evUnit.getVariableManager();
varCurrent = vMng.getVariableNames(['binding', 'constant', 'implicit', 'persistent', 'cumulative']);
for (var i=0; i<functions.length; i++) {
if (functions[i].getOrderedEvaluation() == true) {
if (this.canComputeFunction(functions[i], varCurrent)) {
functions[i].setCompOrder(iCompOrder);
iCompOrder++;
var varNext = [];
varNext.push(functions[i].getValue());
varCurrent = mergeArrays(varCurrent, varNext);
}
else {
EU.debug('Function evaluation cannot work because ordered function ' + functions[i].getValue() + ' cannot be evaluated');
evaluationSucceed = false;
break;
}
}
}
if (evaluationSucceed == true) {
currentOrder = iCompOrder;
}
}
this.buildFunctionDependancyTree = function () {
this.evaluateOrderedFunctions();
if (depTreeExists) {
return;
}
var orderedFuncList = [];
var varNext = [];
var iCompOrder = currentOrder;
var iDepLevel = 0;
var bEnd = false;
var iTotalAmount = functions.length;
while (iCompOrder < iTotalAmount && !bEnd) {
var oldCompOrder = iCompOrder;
for (var k = 0; k < functions.length; k++) {
if ((functions[k].getOrderedEvaluation() == false) && (functions[k].getDepLevel() === -1) && (this.canComputeFunction(functions[k], varCurrent))) {
functions[k].setDepLevel(iDepLevel);
functions[k].setCompOrder(iCompOrder);
orderedFuncList.push(functions[k]);
iCompOrder++;
varNext.push(functions[k].getValue());
}
}
iDepLevel++;
varCurrent = mergeArrays(varCurrent, varNext);
bEnd = !!oldCompOrder == iCompOrder;
}
if (iCompOrder === iTotalAmount) {
depTreeExists = true;
}
else {
EU.debug('Function evaluation cannot work because of broken dependancy tree.');
}
maxDepLevel = iDepLevel - 1;
}
this.buildFuncVarMap = function () {
var map = {};
for (var i = 0; i < functions.length; i++) {
map[functions[i].name] = functions[i].value;
}
return map;
}
this.canComputeFunction = function (func, values) {
var fvars = func.getVarNames();
return compareArrays(fvars, values);
}
this.getFunctionByCompOrder = function (order) {
for (var i = 0; i < functions.length; i++) {
if (functions[i].getCompOrder() === order) {
return functions[i];
}
}
}
this.bindVars = function () {
for (var i = 0; i < functions.length; i++) {
functions[i].bindVariables(variables);
}
}
this.evalFuncs = function () {
var res = [];
for (var i = 0; i < functions.length; i++) {
res.push(functions[i].evaluateEquation());
}
}
this.evaluateLFunctions = function (varValueList, varNames, varValues) {
var r = {};
for (var i = 0; i < lfunctions.length; i++) {
if (lfunctions[i].getScoreable() === 'yes') {
var varName = lfunctions[i].getName();
var fName = lfunctions[i].getKeyName();
if ((varName) && (cMng.evalPreConstraints(varName, varValueList))) {
var ind = varNames.indexOf(fName);
if (ind >= 0) {
var val = varValues[ind];
r[varName] = lfunctions[i].getLookupValue(val);
scoringTable.setValue(varName, null, r[varName]);
}
}
}
}
return r;
}
var evalFormula = function (formula, variables) {
var parser = new Parser();
try {
var result = parser.parse(formula).evaluate(variables);
}
catch (e) {
result = e.message;
}
return result;
}
this.evaluateJFunctions = function (varNames, varValues) {
var r = {};
var evUtils = new SimParser.Utils(evUnit);
var v = evUtils.getVarObject(varNames, varValues);
for (var i = 0; i < jfunctions.length; i++) {
if (jfunctions[i].getScoreable() === 'yes') {
var varName = jfunctions[i].getName();
if (varName) {
var sirF = jfunctions[i];
var jF = sirF.getFunction();
v[varName] = jF;
r[varName] = evalFormula(sirF.getEquation(), v);
scoringTable.setValue(varName, null, r[varName]);
}
}
}
return r;
}
this.getFunctionIndexByName = function (name, type) {
var fn = this.getFunctions();
if (type === 'lookup') var fn = this.getLFunctions();
for (var i = 0; i < fn.length; i++) {
if (fn[i].getName() === name) {
return i;
}
}
}
this.createFunction = function (name, type, formula, vName) {
var f = new SimParser.Function();
var attr = { 'name': name, 'type': type, 'formula': formula, 'variable': vName };
f.setAttributes(attr);
if (attr.type === 'lookup') {
lfunctions.push(f);
}
else {
functions.push(f);
}
}
this.renameEquation = function (oldName, newName) {
var f = this.getFunctionByName(oldName);
if (f) {
f.setName(newName);
}
}
this.updateFunction = function (name, type, formula, vName) {
var f = this.getFunctionNames(name);
if (!f) f = this.getLFunctionNames(name);
if (f) {
var attr = { 'name': name, 'type': type, 'formula': formula, 'variable': vName };
f.setAttributes(attr);
}
}
this.deleteFunction = function (name) {
var i = this.getFunctionIndexByName(name);
if (i) {
var fn = this.getFunctions();
fn.splice(i, 1);
}
else {
i = this.getFunctionIndexByName(name, 'lookup');
if (i) {
var fn = getLFunctions();
fn.splice(i, 1);
}
}
}
};

// FILE: FilterEvaluation.js (63af4f4c) 3/7/2014 11:24:13 AM

SimParser.FilterEvaluation = function (eUnit) {
var filters = 'max, min, average';
var rs;
var impVar = [];
var evUnit = eUnit;
var vMng = evUnit.getVariableManager();
var fMng = evUnit.getFunctionManager();
function getValues(fName) {
var r = [];
for (var i = 0; i < rs.length; i++) {
r.push(rs[i].functions[fName]);
}
return r;
}
function getVarValues(vName) {
var r = [];
for (var i = 0; i < rs.length; i++) {
r.push(rs[i].variables[vName]);
}
return r;
}
function max(fName) {
var v = getValues(fName);
var f = false;
var vr = impVar;
var maxValue = - Infinity;
var maxIndex = undefined;
for (var i=0; i<v.length; i++) {
if (v[i] && (v[i] > maxValue)) {
maxValue = v[i];
maxIndex = vr[i];
f = true;
}
}
return f ? maxValue : undefined;
}
function min(fName) {
var v = getValues(fName);
var vr = impVar;
var minValue = Infinity;
var minIndex = undefined;
var f = false;
for (var i=0; i<v.length; i++) {
if (v[i] && (v[i] < minValue)) {
minValue = v[i];
minIndex = vr[i];
f = true;
}
}
return f ? minValue : undefined;
}
function average(fName) {
var v = getValues(fName);
var totValue = 0;
var avValue = 0.0;
var f = false;
for (var i=0; i<v.length; i++) {
totValue = totValue + v[i];
}
if (v.length > 0) {
avValue = totValue / v.length;
f = true;
}
return f ? avValue : undefined;
}
this.run = function (result) {
rs = result;
var fList = fMng.getFunctionNames();
var impNames = vMng.getVariableNames(['implicit']);
if (impNames.length !== 1) {
return rs;
}
impVar = getVarValues(impNames[0]);
for (var i = 0; i < fList.length; i++) {
var r = {};
var sirF = fMng.getFunctionByName(fList[i]);
var filter = sirF.getFilter();
if (filter !== '') {
var fValues = getValues(fList[i]);
var aFilter = filter.split(',');
for (var j=0; j<aFilter.length; j++){
switch (aFilter[j]) {
case 'max':
r = max(fList[i]);
break;
case 'min':
r = min(fList[i]);
break;
case 'average':
r = average(fList[i]);
break;
}
}
for (var k=0; k<rs.length;k++) {
delete rs[k].functions[fList[i]];
var allgone = true;
if (fList.length - 1 === i || k > 0) {
for (var p in rs[k].functions) {
if (rs[k].functions.hasOwnProperty(p)) {
allgone = false;
break;
}
}
if (allgone) {
delete rs[k].functions;
delete rs[k].variables;
rs[k] = undefined;
}
}
}
rs[0].functions[fList[i]] = r;
}
}
var rs1 = [];
for (var i = 0; i < rs.length; i++) {
if (rs[i] !== undefined) {
rs1.push(rs[i]);
}
}
return rs1;
}
}

// FILE: Ranges.js (20308803) 3/7/2014 11:24:14 AM

SimParser.Range = function() {
SimParser.ParserItem.call(this);
var name;
var type;
this.getName = function () {
return name;
}
this.setName = function (newName) {
name = newName;
}
this.getType = function () {
return type;
}
this.setType = function (newType) {
type = newType;
}
SimParser.Range.prototype.setAttributes = function (attr) {
if (attr.name !== undefined) {
this.setName(attr.name);
}
if (attr.type !== undefined) {
this.setType(attr.type);
}
}
}
SimParser.Range.prototype = new SimParser.ParserItem();
SimParser.Range.prototype.constructor = SimParser.Range;

// FILE: RangeManager.js (ed4ffc7c) 3/7/2014 11:24:14 AM

SimParser.RangeManager = function() {
var ranges = [];
var that = this;
this.getRanges = function () {
return ranges;
}
this.setRanges = function (root) {
ranges = [];
var r = root.getElementsByTagName('ranges').item(0);
if (r !== null && r.hasChildNodes()) {
for (var i = 0; i < r.childNodes.length; i++) {
var attr = {};
if (r.childNodes[i].nodeName[0] === '#') {
continue;
}
for (var j = 0; j < r.childNodes[i].attributes.length; j++) {
attr[r.childNodes[i].attributes[j].name] = r.childNodes[i].attributes[j].nodeValue;
}
switch (attr.type) {
case 'range':
var rn = new SimParser.MinMaxRange();
break;
case 'iterator':
var rn = new SimParser.IterationRange();
break;
}
rn.setAttributes(attr, r);
ranges.push(rn);
}
}
}
this.getRangeByName = function (name) {
for (var i = 0; i < ranges.length; i++) {
if (ranges[i].getName() === name) {
return ranges[i];
}
}
}
}

// FILE: MinMaxRange.js (1b373b55) 3/7/2014 11:24:14 AM

SimParser.MinMaxRange = function() {
SimParser.Range.call(this);
var minValue = new Number();
var maxValue = new Number();
var increment = new Number();
var values;
var currentValue = new Number();
this.runNext = function (callback, params) {
if (currentValue <= maxValue) {
callback(params);
currentValue++;
}
}
this.runAll = function (callback, params) {
for (var i = minValue; i <= maxValue; i += increment) {
callback(params);
currentValue = i;
}
}
this.IsValueinRange = function (val) {
return (value >= minValue && value <= maxValue);
}
this.reset = function () {
currentValue = minValue;
}
this.getValues = function () {
return values;
}
this.setValues = function () {
values = [];
if (typeof (minValue) === 'undefined' || typeof (maxValue) === 'undefined' || typeof (incrementValue) === 'undefined') {
EU.debug('minValue/maxValue/increment is not defined in ' + name);
}
var curValue = minValue;
while (curValue <= maxValue) {
values.push(curValue);
curValue = curValue + increment;
}
}
SimParser.MinMaxRange.prototype.setAttributes = function (attr) {
SimParser.Range.prototype.setAttributes.call(this, attr);
if (attr.minValue !== undefined) {
minValue = parseInt(attr.minValue);
}
else {
minValue = 1;
}
if (attr.maxValue !== undefined) {
maxValue = parseInt(attr.maxValue);
}
else {
maxValue = 10;
}
if (attr.increment !== undefined)  {
increment = parseFloat(attr.increment);
}
else {
increment = 1;
}
this.setValues();
}
}
SimParser.MinMaxRange.prototype = new SimParser.Range();
SimParser.MinMaxRange.prototype.constructor = SimParser.MinMaxRange;

// FILE: IterationRange.js (a59630b6) 3/7/2014 11:24:13 AM

SimParser.IterationRange = function() {
SimParser.Range.call(this);
var startValue = new Number();
var numIterations = new Number();
var currentValue = new Number();
var values;
this.runNext = function (callback, params) {
if (currentValue <= numIterations) {
callback(params);
currentValue++;
}
}
this.runAll = function (callback, params) {
for (var i = 1; i <= numIterations; i++) {
callback(params);
currentValue = i;
}
}
this.reset = function () {
currentValue = 1;
}
this.getValues = function () {
return values;
}
this.getStartValue = function () {
return startValue;
}
this.setStartValue = function (newStartValue) {
startValue = newStartValue;
}
this.setValues = function () {
values = [];
if (typeof (startValue) === 'undefined' || typeof (numIterations) === 'undefined') {
EU.debug('startValue or numIterations is not defined in ' + name);
}
for (var i = startValue; i < numIterations; i++) {
values.push(i);
}
}
this.getNumIterations = function () {
return numIterations;
}
this.setNumIterations = function (iterations) {
numIterations = iterations;
}
SimParser.IterationRange.prototype.setAttributes = function (attr) {
SimParser.Range.prototype.setAttributes.call(this, attr);
if (attr.numIteration !== undefined) {
numIterations = parseInt(attr.numIteration);
}
else {
numIterations = 10;
}
if (attr.startValue !== undefined) {
startValue = parseInt(attr.startValue);
}
else {
startValue = 1;
}
if (attr.type !== undefined) {
this.type = attr.type;
}
this.setValues();
}
}
SimParser.IterationRange.prototype = new SimParser.Range();
SimParser.IterationRange.prototype.constructor = SimParser.IterationRange;

// FILE: Variables.js (968c17ce) 3/7/2014 11:24:14 AM

SimParser.Variable = function() {
SimParser.ParserItem.call(this);
var name;
var type;
var objectName;
var value = new Number();
this.getName = function () {
return name;
}
this.setName = function (n) {
name = n;
return this;
}
this.getType = function () {
return type;
}
this.setType = function (t) {
type = t;
return this;
}
this.getValue = function () {
return value;
}
this.setValue = function (v) {
value = v;
return this;
}
this.getObjectName = function () {
return objectName;
}
this.setObjectName = function (o) {
objectName = o;
return this;
}
SimParser.Variable.prototype.setAttributes = function (attr, node) {
if (attr.name !== undefined) {
this.setName(attr.name);
}
if (attr.type !== undefined) {
this.setType(attr.type);
}
if (attr.value !== undefined) {
this.setValue(attr.value);
}
if (attr.object !== undefined) {
this.setObjectName(attr.object);
}
}
this.setEname('BaseVariable');
}
SimParser.Variable.prototype = new SimParser.ParserItem();
SimParser.Variable.prototype.constructor = SimParser.Variable;

// FILE: VariableManager.js (a90121a7) 3/7/2014 11:24:14 AM

SimParser.VariableManager = function (eUnit) {
var variables = [];
var evUnit = eUnit;
var that = this;
this.getVariables = function () {
return variables;
}
this.setVariables = function (root) {
variables = [];
r = root.getElementsByTagName('variables').item(0);
if (r !== null && r.hasChildNodes()) {
for (var i = 0; i < r.childNodes.length; i++) {
if (r.childNodes[i].nodeName[0] === '#') {
continue;
}
var attr = {};
var rc = r.childNodes[i];
for (var j = 0; j < r.childNodes[i].attributes.length; j++) {
attr[r.childNodes[i].attributes[j].name] = r.childNodes[i].attributes[j].nodeValue;
}
if (rc.hasChildNodes()) {
var vals = [];
for (var k = 0; k < rc.childNodes.length; k++) {
if (rc.childNodes[k].nodeName[0] === '#') {
continue;
}
vals.push(rc.childNodes[k].textContent);
}
attr.allValues = vals;
}
var vr;
switch (attr.type) {
case 'binding':
vr = new SimParser.BindableVariable();
break;
case 'constant':
vr = new SimParser.ConstantVariable();
break;
case 'implicit':
vr = new SimParser.ImplicitVariable();
var rMng = evUnit.getRangeManager();
attr.sirRange = rMng.getRangeByName(attr.range);
break;
case 'result':
vr = new SimParser.ResultVariable();
break;
case 'lookup':
vr = new SimParser.LookupVariable();
break;
case 'cumulative':
vr = new SimParser.CumulativeVariable();
break;
case 'persistent':
vr = new SimParser.PersistentVariable();
break;
default:
vr = new SimParser.Variable();
break;
}
vr.setAttributes(attr, r);
variables.push(vr);
}
}
}
this.getConstants = function () {
var cNames = [];
var vars = that.getVariables();
for (var i = 0; i < vars.length; i++) {
if (vars[i].type === 'constant') {
cNames.push({ name: vars[i].name, value: [vars[i].value] });
}
}
return cNames;
}
this.getVariableByName = function (vName) {
var v = undefined;
for (var i = 0; i < variables.length; i++) {
if (variables[i].getName() === vName) {
return variables[i];
}
}
}
this.getVarIndexByName = function (vName) {
for (var i = 0; i < variables.length; i++) {
if (variables[i].getName() === vName) {
return i;
}
}
}
this.getVariableNames = function (filter) {
var vNames = [];
for (var i = 0; i < variables.length; i++) {
if ((filter === undefined) || (filter.indexOf(variables[i].getType()) >= 0)) {
vNames.push(variables[i].getName());
}
}
return vNames;
}
this.getVariableByObjectName = function (name) {
for (var i = 0; i < variables.length; i++) {
if (variables[i].getObjectName() === name) {
return variables[i];
}
}
}
this.isVarBindable = function (vName) {
var v = that.getVariableByName(vName);
return (v === undefined) ? false : v.type === 'binding';
}
this.isVarConstant = function (vName) {
var v = that.getVariableByName(vName);
return (v === undefined) ? false : v.type === 'constant';
}
this.isVarImplicit = function (vName) {
var v = that.getVariableByName(vName);
return (v === undefined) ? false : v.type === 'implicit';
}
this.isVarResult = function (vName) {
var v = that.getVariableByName(vName);
return (v === undefined) ? false : v.type === 'result';
}
this.getConstantNames = function () {
var cNames = [];
var vars = that.getVariables();
for (var i = 0; i < vars.length; i++) {
if (vars[i].getType() === 'constant') {
cNames.push(vars[i].getName());
}
}
return cNames;
}
this.getConstants = function () {
var cNames = [];
var vars = that.getVariables();
for (var i = 0; i < vars.length; i++) {
if (vars[i].getType() === 'constant') {
cNames.push({ name: vars[i].getName(), value: [vars[i].getValue()] });
}
}
return cNames;
}
function createVariable (name, value, type) {
var vr = undefined;
var attr = { 'type': type, 'name': name, 'value': value };
switch (attr.type) {
case 'binding':
vr = new SimParser.BindableVariable();
break;
case 'constant':
vr = new SimParser.ConstantVariable();
break;
case 'implicit':
vr = new SimParser.ImplicitVariable();
attr.sirRange = SirRangeManager.getRangeByName(attr.range);
break;
case 'result':
vr = new SimParser.ResultVariable();
break;
case 'lookup':
vr = new SimParser.LookupVariable();
break;
}
if (vr) {
vr.setAttributes(attr);
variables.push(vr);
return true;
}
else {
return false;
}
}
this.saveVariable = function (name, value, type) {
var v = this.getVariableByName(name);
if (v) {
v.setValue(value);
v.setName(name)
}
else {
createVariable(name, value, type);
}
}
this.renameVariable = function (oldName, newName) {
var v = this.getVariableByName(oldName);
if (v) {
v.setName(newName);
}
}
this.updateVariable = function (name, value) {
var v = this.getVariableByName(name);
if (v) {
var attr = { 'name': name, 'value': value };
v.setAttributes(attr);
}
}
this.deleteVariable = function (name) {
var i = this.getVarIndexByName(name);
if (i) {
functions.splice(i, 1);
}
}
};

// FILE: PersistentVariable.js (a729e6fa) 3/7/2014 11:24:14 AM

SimParser.PersistentVariable = function () {
SimParser.Variable.call(this);
var store;
this.getStore = function () {
return store;
}
this.setStore = function (s) {
store = s;
return this;
}
SimParser.PersistentVariable.prototype.setAttributes = function (attr, node) {
SimParser.Variable.prototype.setAttributes.call(this, attr, node);
if (attr.store !== undefined) {
this.setStore(attr.store);
}
if (attr.comOp !== undefined) {
this.setStore(attr.cumOP);
}
}
this.setEname('PersistentVariable');
};
SimParser.PersistentVariable.prototype = new SimParser.PersistentVariable();
SimParser.PersistentVariable.prototype.constructor = SimParser.Variable;

// FILE: ImplicitVariable.js (ff8ae7b2) 3/7/2014 11:24:13 AM

SimParser.ImplicitVariable = function () {
SimParser.Variable.call(this);
var allValues;
var range;
this.getValues = function () {
if (allValues) {
return allValues;
}
else {
if (range) {
allValues = range.getValues();
}
else {
allValues = [];
}
return allValues;
}
}
this.bindRange = function (newRange) {
range = newRange;
}
SimParser.ImplicitVariable.prototype.setAttributes = function (attr, node) {
SimParser.Variable.prototype.setAttributes.call(this, attr, node);
if (attr.range !== undefined) {
this.bindRange(attr.sirRange);
}
if (attr.defaultValue !== undefined) {
this.setValue(attr.defaultValue);
}
}
this.setEname('ImplicitVariable');
};
SimParser.ImplicitVariable.prototype = new SimParser.ImplicitVariable();
SimParser.ImplicitVariable.prototype.constructor = SimParser.Variable;

// FILE: LookupVariable.js (577cbf2a) 3/7/2014 11:24:14 AM

SimParser.LookupVariable = function () {
SimParser.Variable.call(this);
this.getAllValues = function () {
return [value];
}
SimParser.LookupVariable.prototype.setAttributes = function (attr, node) {
SimParser.Variable.prototype.setAttributes.call(this, attr, node);
if (attr.value !== undefined) {
this.setValue(attr.value);
}
if (attr.defaultValue !== undefined) {
this.setValue(attr.defaultValue);
}
}
this.setEname('LookupVariable');
};
SimParser.LookupVariable.prototype = new SimParser.LookupVariable();
SimParser.LookupVariable.prototype.constructor = SimParser.Variable;

// FILE: BindableVariable.js (3889f902) 3/7/2014 11:24:13 AM

SimParser.BindableVariable = function () {
SimParser.Variable.call(this);
var allValues;
this.getValues = function () {
return allValues;
}
this.setValues = function (v) {
allValues = v;
return this;
}
SimParser.BindableVariable.prototype.setAttributes = function (attr, node) {
SimParser.Variable.prototype.setAttributes.call(this, attr, node);
if (attr.allValues !== undefined) {
this.setValues(attr.allValues);
}
if (attr.defaultValue !== undefined) {
this.setValue(attr.defaultValue);
}
}
this.setEname('BindableVariable');
};
SimParser.BindableVariable.prototype = new SimParser.BindableVariable();
SimParser.BindableVariable.prototype.constructor = SimParser.Variable;

// FILE: ConstantVariable.js (77bb829f) 3/7/2014 11:24:13 AM

SimParser.ConstantVariable = function () {
SimParser.Variable.call(this);
var allValues;
this.getAllValues = function () {
return [value];
}
SimParser.ConstantVariable.prototype.setAttributes = function (attr, node) {
SimParser.Variable.prototype.setAttributes.call(this, attr, node);
if (attr.object !== undefined) {
this.setObjectName(attr.object);
}
}
this.setEname('ConstantVariable');
};
SimParser.ConstantVariable.prototype = new SimParser.ConstantVariable();
SimParser.ConstantVariable.prototype.constructor = SimParser.Variable;

// FILE: CumulativeVariable.js (0b412004) 3/7/2014 11:24:13 AM

SimParser.CumulativeVariable = function () {
SimParser.Variable.call(this);
var store;
var cumOp;
this.getStore = function () {
return store;
}
this.setStore = function (s) {
store = s;
return this;
}
this.getCumOp = function () {
return cumOp;
}
this.setCumOp = function (c) {
cumOp = c;
return this;
}
SimParser.CumulativeVariable.prototype.setAttributes = function (attr, node) {
SimParser.Variable.prototype.setAttributes.call(this, attr, node);
if (attr.store !== undefined) {
this.setStore(attr.store);
}
if (attr.cumOp !== undefined) {
this.setCumOp(attr.cumOp);
}
}
this.setEname('CumulativeVariable');
};
SimParser.CumulativeVariable.prototype = new SimParser.CumulativeVariable();
SimParser.CumulativeVariable.prototype.constructor = SimParser.Variable;

// FILE: ResultVariable.js (39bf143e) 3/7/2014 11:24:14 AM

SimParser.ResultVariable = function () {
SimParser.Variable.call(this);
SimParser.ResultVariable.prototype.setAttributes = function (attr, node) {
SimParser.Variable.prototype.setAttributes.call(this, attr, node);
}
this.setEname('ResultVariable');
};
SimParser.ResultVariable.prototype = new SimParser.ResultVariable();
SimParser.ResultVariable.prototype.constructor = SimParser.Variable;

// FILE: FunctionEvaluation.js (fbe0a444) 3/7/2014 11:24:13 AM

SimParser.FunctionEvaluation = function (eUnit) {
var key = undefined;
var varList = [];
var varNames = [];
var varValues = [];
var varFuncs = [];
var evalResult = [];
var isContinue = true;
var evUnit = eUnit;
var evUtils = new SimParser.Utils(eUnit);
var scoringTable = function() { return evUnit.getSimInstance().getScoringTable(); };
this.process = function (p, f) {
var d1 = new Date();
doInit(p,f);
if (isContinue) {
evalResult = doProcess(p,f);
if (evalResult.length > 0) {
doEnd();
}
}
var d2 = new Date();
return evalResult;
}
function doInit(p, f) {
varNames = [];
varValues = [];
varFuncs = [];
varList = [];
varList = evUtils.readDataFromWhiteBoard('evaluationInput', 'input');
if (varList === undefined || varList.length === 0) {
isContinue = false;
return;
}
var vWB = evUtils.mergeWBVariables(varList);
varNames = evUtils.getWBVarNames(vWB);
varValues = evUtils.getWBVarValues(vWB);
varNames = evUtils.convertElementNamesToVarNames(varNames);
p = new Parser();
var c = evUtils.getConstantValues();
for (var i = 0; i < c.vNames.length; i++) {
varNames.push(c.vNames[i]);
varValues.push(c.vValues[i]);
}
if (typeof (f) === 'undefined') {
varFuncs = evUtils.getFuncVars();
} else {
varFuncs = evUtils.getFuncVars(f);
}
var impVars = evUtils.getImplicitValues(varFuncs);
for (var i = 0; i < impVars.names.length; i++) {
varNames.push(impVars.names[i]);
varValues.push(impVars.values[i]);
}
}
function doProcess (p, f) {
var param = {};
if (typeof (p) === 'undefined') {
param.algorithm = 'greedy';
}
else {
param.algorithm = p;
}
var fList = [];
if (typeof (f) === 'undefined' || f === null || f === '') {
}
else {
var fMng = evUnit.getFunctionManager();
var sirF = fMng.getFunctionByName(f);
if (sirF === undefined) {
EU.debug('unknown function to evaluate: ' + f);
}
else {
fList.push(f);
}
}
var r = doProcess3();
return r;
}
var evalFormula2 = function (formula, variables) {
var parser = new Parser();
vars = {};
for (var i = 0; i < variables.length; i++) {
vars[variables[i].name] = variables[i].value;
}
try {
var result = parser.parse(formula).evaluate(vars);
}
catch (e) {
result = e.message;
}
return result;
}
function doProcess3 () {
var fMng = evUnit.getFunctionManager();
fMng.buildFunctionDependancyTree();
var result = [];
var persistentVarDB = evUnit.getSimInstance().getPersistentVariableDB();
var funcCount = fMng.getFunctions().length;
var permList = SimParser.Permutation(varValues);
var varValueList = [];
var vMng = evUnit.getVariableManager();
var cMng = evUnit.getConstraintManager();
for (var i = 0; i < permList.length; i++) {
varValueList = [];
var fLastIteration = false;
for (var k = 0; k < varNames.length; k++) {
varValueList.push({ 'name': varNames[k], 'value': permList[i][k] });
}
for (var k = 0; k < funcCount; k++) {
var sirF = fMng.getFunctionByCompOrder(k);
if (sirF.getValue() != null) {
var currentVariable = vMng.getVariableByName(sirF.getValue());
if ((currentVariable != null) && ((currentVariable.getType() == 'cumulative') || (currentVariable.getType() == 'persistent'))) {
var variableStore = currentVariable.getStore();
if (variableStore != null) {
if (persistentVarDB.getElementValue(variableStore) != null) {
varValueList.push ({ 'name': sirF.getValue(), 'value': persistentVarDB.getElementValue(variableStore)});
}
}
}
}
}
var funcVector = [];
var varFuncVars = [];
var fEval = true;
var fn = [];
if (cMng.evalPreConstraints('', varValueList)) {
for (var k = 0; k < funcCount; k++) {
var sirF = fMng.getFunctionByCompOrder(k);
fn[k] = sirF.getName();
if (cMng.evalPreConstraints(fn[k], varValueList)) {
funcVector[k] = evalFormula2(sirF.getEquation(), varValueList);
if (sirF.getValue() != null) {
var currentVariable = vMng.getVariableByName(sirF.getValue());
if ((currentVariable != null) && (currentVariable.getType() == 'cumulative')) {
var variableStore = currentVariable.getStore();
if (variableStore != null) {
var cumOp = currentVariable.getCumOp();
var variableCumOp = '+';
if (cumOp != null) {
if (cumOp === 'add') {
variableCumOp = '+';
}
else if (cumOp === 'multiply') {
variableCumOp = '*';
}
else if (cumOp === 'subtract') {
variableCumOp = '-';
}
else if (cumOp === 'divide') {
variableCumOp = '/';
}
}
persistentVarDB.updateElement(variableStore, funcVector[k], variableCumOp);
funcVector[k] = persistentVarDB.getElementValue(variableStore);
}
}
else if ((currentVariable != null) && (currentVariable.getType() == 'persistent')) {
var variableStore = currentVariable.getStore();
if (variableStore != null) {
persistentVarDB.updateElement(variableStore, funcVector[k], 'overwrite');
}
}
if (sirF.getScoreable() !== 'no') {
scoringTable().setValue(fn[k], null, funcVector[k]);
}
varFuncVars[k] = { 'name': sirF.getValue(), 'value': funcVector[k] };
fEval = fEval && cMng.evalPostConstraints(fn[k], varValueList, varFuncVars);
if (!fEval) {
fLastIteration = true;
}
if (currentVariable != null) {
if ((currentVariable.getType() == 'cumulative') || (currentVariable.getType() == 'persistent')) {
for (var l=0; l<varValueList.length; l++) {
if (varValueList[l].name === sirF.getValue()) {
varValueList[l].value = funcVector[k];
break;
}
}
}
else {
varValueList.push({ 'name': sirF.getValue(), 'value': funcVector[k] });
}
}
}
}
else {
var currentVariable = vMng.getVariableByName(sirF.getValue());
if ((currentVariable != null) && (currentVariable.getType() == 'cumulative')) {
var variableStore = currentVariable.getStore();
if (variableStore != null) {
funcVector[k] = persistentVarDB.getElementValue(variableStore);
}
if (sirF.getScoreable() !== 'no') {
scoringTable().setValue(fn[k], null, funcVector[k]);
}
varFuncVars[k] = { 'name': sirF.getValue(), 'value': funcVector[k] };
fEval = fEval && cMng.evalPostConstraints(fn[k], varValueList, varFuncVars);
if (!fEval) {
fLastIteration = true;
}
for (var l=0; l<varValueList.length; l++) {
if (varValueList[l].name === sirF.getValue()) {
varValueList[l].value = funcVector[k];
break;
}
}
}
}
}
result.push({ 'functions': evUtils.packFunctionforWhiteboard(fn, funcVector), 'variables': evUtils.packVariablesforWhiteboard(varValueList) });
if (fLastIteration || !cMng.evalPostConstraints('', varValueList, varFuncVars)) {
break;
}
}
}
if (result.length === 0) {
result.push({ 'functions': undefined, 'variables': undefined});
}
var lr = fMng.evaluateLFunctions(varValueList, varNames, varValues);
if (result.length >= 0) {
var r = result[0].functions;
if (r) {
for (p in lr) {
r[p] = lr[p];
}
}
}
var jr = fMng.evaluateJFunctions(varNames, varValues);
if (result.length >= 0) {
var r = result[0].functions;
if (r) {
for (var p in jr) {
r[p] = jr[p];
}
}
}
var fe = new SimParser.FilterEvaluation(evUnit);
result = fe.run(result);
if (result.length >= 0) {
var r = result[0].functions;
if (r) {
for (var p in r) {
if (p != 'undefined') {
scoringTable().setValue(p, null, r[p]);
}
}
}
}
return result;
}
function doEnd () {
var r = [], r1 = '', rs = evalResult, str, strCopy;
var fMng = evUnit.getFunctionManager();
for (var k = 0; k < rs.length; k++) {
str = rs[k].functions;
strCopy = {};
if (str !== undefined) {
for (var p in str) {
if (str.hasOwnProperty(p)) {
strCopy[p] = str[p];
if (str[p]) {
var sirF = fMng.getFunctionByName(p);
var prName = sirF.getProxyName();
if (prName) {
if (typeof str[p] === 'string') {
strCopy[prName] = str[p].replace(/:/g, '\\0x1G\\').replace(/,/g, '\\0x1H\\');
}
else {
strCopy[prName] = str[p];
}
if (p !== prName) delete strCopy[p];
}
}
}
}
r.push(JSON.stringify(strCopy).replace(/:/g, '\\0x1F\\').replace(/,/g, '\\0x1E\\') + '\\0x1D\\');
}
}
r1 = r.join('');
r1 = r1.replace(/\\0x1H\\/g, ',').replace(/\\0x1G\\/g, ':');
r1 = r1.replace(/{/g, '').replace(/}/g, '').replace(/;;/g, '');
r1 = unescape(r1);
if ((r1.length > 6)  && (r1.substring(r1.length-6, r1.length) === '\\0x1D\\')) {
r1 = r1.substring(0, r1.length-6);
}
key = evUtils.writeDataOnWhiteBoard(r1, key, 'evaluationOutput', 'output');
}
}

// FILE: EvaluationUnit.js (d78d7b2b) 3/7/2014 11:24:13 AM

SimParser.EvaluationUnit = function (sim) {
var source = 'EvaluationUnit';
var root;
var vMng = new SimParser.VariableManager(this);
var cMng = new SimParser.ConstraintManager(this);
var rMng = new SimParser.RangeManager(this);
var simInstance = sim;
var dbg = function() { return sim.getDebug(); };
var isRunning = false;
var eventElement = new Simulator.SimElement(sim);
this.getVariableManager = function () {
return vMng;
}
this.getConstraintManager = function () {
return cMng;
}
this.getRangeManager = function () {
return rMng;
}
this.getSimInstance = function () {
return simInstance;
}
var fMng = new SimParser.FunctionManager(this);
this.getFunctionManager = function () {
return fMng;
}
var fEvaluation = new SimParser.FunctionEvaluation(this);
this.evaluateFunction = function (funcName) {
var func = fMng.getFunctionByName(funcName);
var vars = func.getVarList();
var valueList = [];
var results = [];
for (var i = 0; i < vars.length; i++) {
valueList.push(vars[i].getValues());
}
var permList = SimParser.Permutation(valueList);
for (var i = 0; i < permList.length; i++) {
for (var j = 0; j < vars.length; j++) {
vars[j].setValue(permList[i][j]);
}
results.push({
params: permList[i],
result: func.evaluateEquation()
});
}
return results;
};
var runEvaluation = function () {
var result = false;
var d1 = new Date();
if (isRunning) {
return;
}
isRunning = true;
try {
try {
if (!root) {
Simulator.showAlertWarning('Evaluation Unit is not loaded');
}
else {
var fCount = fMng.getFunctions().length + fMng.getLFunctions().length + fMng.getJFunctions().length;
if (fCount > 0) {
fEvaluation.process('greedy');
result = true;
}
}
}
catch (e) {
EU.debug(e.message);
}
}
finally {
isRunning = false;
}
return result;
};
this.load = function (source) {
var d1 = new Date();
root = source;
rMng.setRanges(root);
vMng.setVariables(root);
fMng.setFunctions(root);
cMng.setConstraints(root);
this.setupEvents();
};
eventElement.handleEvent = function (event) {
var simulationMgr = sim.getSimulationManager();
var eventMgr = sim.getEventManager();
switch (event.type) {
case 'info':
if(simulationMgr.trialLimitReached()) {
return;
}
if (event.context === 'inputAvailable' || event.context === 'animationThreadFinished') {
if (runEvaluation()) {
eventMgr.postEvent(new Simulator.Event(this, 'info', 'outputAvailable', null, false));
}
break;
}
case 'command':
if(simulationMgr.trialLimitReached()) {
return;
}
if ((event.context === 'startTrial') || (event.context === 'startAnimation')) {
if (runEvaluation()) {
eventMgr.postEvent(new Simulator.Event(this, 'info', 'outputAvailable', null, false));
}
break;
}
default:
debug(this.getName() + ': Unhandled event type received: ' + event.toString());
return;
}
};
this.setupEvents = function () {
var r = root.getElementsByTagName('unit').item(0);
if (r !== undefined && r !== null) {
setEvents(eventElement, r);
}
};
this.getEvents = function () {
return eventElement;
};
function setEvents(element, node) {
var events = [];
var attributes;
var children = node.childNodes;
if (children != null && children != undefined) {
for ( var j = 0; j < children.length; j++) {
var id = children[j].nodeName;
if (id === 'event') {
attributes = children[j].attributes;
var eventInfo = createEvent(element, attributes);
element.addEvent(eventInfo['theEvent'], eventInfo['direction']);
}
}
}
return events;
}
function createEvent(obj, attributes) {
var response = [];
var data = '';
var ctx = '';
var dir = '';
var type = '';
var postOnChange = 'no';
var  completeWithoutOutput = false;
for ( var k = 0; k < attributes.length; k++) {
switch (attributes[k].nodeName) {
case 'direction':
dir = attributes[k].nodeValue;
break;
case 'data':
data = attributes[k].nodeValue;
break;
case 'context':
ctx = attributes[k].nodeValue;
break;
case 'type':
type = attributes[k].nodeValue;
break;
case 'postOnChange':
postOnChange = attributes[k].nodeValue;
break;
case 'completeWithoutOutput':
completeWithoutOutput = attributes[k].nodeValue === 'yes' ? true : false;
break;
}
}
response['theEvent'] = new Simulator.Event(obj, type, ctx, data, postOnChange, completeWithoutOutput); response['direction'] = dir;
return response;
}
function debug(str1, str2, trace) {
dbg().debug(source, str1, str2, trace);
}
function debugf(str1, str2, trace) {
dbg().debugf(source, str1, str2, trace);
}
};

// FILE: SimulationLoader2.js (017b4c08) 3/7/2014 11:24:14 AM

SimulationLoader = function(xmlText, callback)
{
this._xmlText = xmlText;
this._callback = callback;
};
SimulationLoader.prototype.start = function()
{
var imageFiles = SimulationLoader.parseImages(this._xmlText);
var flashFiles = SimulationLoader.parseFlash(this._xmlText);
this._callback(this._xmlText);
};
SimulationLoader._regex_images1 = /image[\s]*=[\s]*".*"/g;
SimulationLoader._regex_images2 = /src[\s]*=[\s]*".*(.jpg | .png | .gif)\s*"/g;
SimulationLoader._regex_flash1 = /flash[\s]*=[\s]*\".*\"/g;
SimulationLoader._regex_flash2 = /src[\s]*=[\s]*\".*(swf)\s*\"/g;
SimulationLoader._regex_flash3 = /altSrc[\s]*=[\s]*\".*(swf)\s*\"/g;
SimulationLoader._parse = function(xmlText, regex)
{
var values = [];
var matches = xmlText.match(regex);
if (matches != null)
{
var extractFile = function(str)
{
var index = str.indexOf('"');
var cleanStr = str.substring(index + 1);
index = cleanStr.indexOf('"');
cleanStr = cleanStr.substring(0, index);
return cleanStr;
}
for(var i = 0; i < matches.length; i++)
{
values.push(extractFile(matches[i]));
}
}
return values;
};
SimulationLoader.parseImages = function(xmlText)
{
var imageFiles = [];
imageFiles = imageFiles.concat(this._parse(xmlText, this._regex_images1));
imageFiles = imageFiles.concat(this._parse(xmlText, this._regex_images2));
for (var i = 0; i < imageFiles.length; i++)
{
imageFiles[i] = SimulationLoader.resolveUrl(imageFiles[i]);
}
return imageFiles;
};
SimulationLoader.parseFlash = function(xmlText)
{
var flashFiles = [];
flashFiles = flashFiles.concat(this._parse(xmlText, this._regex_flash1));
flashFiles = flashFiles.concat(this._parse(xmlText, this._regex_flash2));
flashFiles = flashFiles.concat(this._parse(xmlText, this._regex_flash3));
for (var i = 0; i < flashFiles.length; i++)
{
flashFiles[i] = SimulationLoader.resolveUrl(flashFiles[i]);
}
return flashFiles;
};
SimulationLoader.fixPaths = function(xmlText, baseUrl)
{
xmlText = xmlText.replace(/src=\"/g, 'src="' + baseUrl);
xmlText = xmlText.replace(/altSrc=\"/g, 'altSrc="' + baseUrl);
xmlText = xmlText.replace(/image=\"/g, 'image="' + baseUrl);
xmlText = xmlText.replace(/deleteRowImage=\"/g, 'deleteRowImage="' + baseUrl);
xmlText = xmlText.replace(/flash=\'"/g, 'flash="' + baseUrl);
return xmlText;
};
SimulationLoader.resolveUrl = function(url)
{
url = url.replace(/&amp;/g, '&');
url = url.split('&').join('&amp;').split('<').join('&lt;').split('"').join('&quot;');
var el = document.createElement('div');
el.innerHTML = '<a href="' + url + '">x</a>';
return el.firstChild.href;
};

// FILE: module_simulator2.js (8c355c81) 5/2/2014 12:55:57 PM

ContentManager.onItemEvent('available', function (page, item) {
if (!item.isResponseType('simulator')) return;
var pageDoc = page.getDoc();
var simContainer = pageDoc.getElementById('SimContainer_' + item.position);
var simXml = item.rendererSpec;
var createSimComponent = function (simulator, simContainer) {
var simComponent =
{
id: 'SIM_' + item.position,
focus: function () { Util.Dom.focus(simContainer); },
blur: function () { Util.Dom.blur(simContainer); }
};
item.addComponent(simComponent);
YUE.on(simContainer, 'click', function () {
item.setActiveComponent(simComponent);
});
};
var simImageFiles = SimulationLoader.parseImages(simXml);
for (var i = 0; i < simImageFiles.length; i++) {
var loaderImage = new ResourceLoader.Image(simImageFiles[i]);
page.addResourceLoader(loaderImage);
}
var simSWFFiles = SimulationLoader.parseFlash(simXml);
for (var i = 0; i < simSWFFiles.length; i++) {
var loaderBinary = new ResourceLoader.Binary(simSWFFiles[i]);
page.addResourceLoader(loaderBinary);
}
var responseXml;
if (typeof (window.TestShell) == 'object' && typeof (window.TestShell.PageManager) == 'object') {
var response = window.TestShell.PageManager.getResponse(item.position);
responseXml = response.getLastValue();
}
else {
responseXml = item.value;
}
var simulator = new Simulator.Simulator(simContainer, ContentManager.isAccessibilityEnabled());
Simulator.Animation.FlashAnimationInterface.MapInstance(simulator);
simulator.setAnimationShellPath(ContentManager.resolveBaseUrl('Scripts/Simulator2/Renderer/SWF/SimulationShell.swf'));
simulator.setAnimationExternalScriptsPath(ContentManager.resolveBaseUrl('Scripts/Libraries'));
simulator.loadXml(simXml, responseXml);
item.simulator = simulator;
var simWin = simulator.getWin();
var simDoc = simulator.getDoc();
createSimComponent(simulator);
var simZoomUpdate = function () {
var zoomInfo = page.getZoom();
zoomInfo._setDocumentLevel(simDoc, zoomInfo.currentLevel, true);
};
var zoomImage = function (img) {
YUD.addClass(img, 'Image');
simZoomUpdate();
};
YUD.batch(simDoc.getElementsByTagName('img'), function (img) {
if (Util.Dom.isImgLoaded(img)) {
zoomImage(img);
}
else {
YUE.on(img, 'load', function () {
zoomImage(img);
});
}
});
simulator.subscribe('info', 'imageEmbedded', function (evt) {
if (evt.data) YUD.addClass(evt.data, 'Image');
simZoomUpdate();
});
simulator.subscribe('info', 'animationEmbedded', function (evt) {
simZoomUpdate();
VideoManager.SWF.stopRightClick(evt.data);
});
simulator.subscribe('info', 'simulatorStateChange', function (evt) {
if (YAHOO.lang.isString(evt.data)) {
var eventType = evt.data.toUpperCase();
if (eventType == "READY") {
if (ContentManager.isReadOnly()) {
simulator.setReadOnlyState(true);
}
YUD.removeClass(simContainer, 'loading');
}
else if (eventType == "ERROR") {
YUD.addClass(simContainer, 'failed');
}
}
});
if (typeof TDS.Diagnostics == 'object') {
TDS.Diagnostics.addErrorHandler(simWin);
}
});
ContentManager.onItemEvent('zoom', function(page, item)
{
if (item.simulator == null) return;
var zoomInfo = page.getZoom();
var zoomFactor = (zoomInfo == null) ? 1 : zoomInfo.levels[zoomInfo.currentLevel].factor;
item.simulator.zoom(zoomFactor);
});
ContentManager.onItemEvent('show', function (page, item) {
if (!item.simulator) return;
item.simulator.setVisibilityAndAttachEvents(true);
});
ContentManager.onItemEvent('hide', function (page, item) {
if (!item.simulator) return;
item.simulator.setVisibilityAndAttachEvents(false);
});
ContentManager.onItemEvent('focus', function (page, item) {
if (item.simulator) {
item.simulator.focus();
}
});
ContentManager.onItemEvent('blur', function (page, item) {
if (item.simulator) {
item.simulator.blur();
}
});
(function()
{
var getter = function(item, response)
{
if (item.simulator == null) return;
response.value = item.simulator.getResponseXml();
response.isValid = item.simulator.isValid();
response.isSelected = response.isValid;
};
var setter = function(item, value)
{
if (item.simulator == null) return;
item.simulator.loadResponseXml(value);
};
ContentManager.registerResponseHandler('simulator', getter, setter);
})();

// FILE: main.js (4554fcdd) 3/7/2014 11:24:13 AM

TDS = window.TDS || {};
TDS.Notes = {
Store: {},
Debug: true,
Sequence: { id: 0 },
_Factory:  null,
Events: {
Load: new YAHOO.util.CustomEvent('load'),
Save: new YAHOO.util.CustomEvent('save')
},
Types: {
Global: 'global',
DropDown: 'DropDown',
TextArea: 'TextArea',
ScratchPad: 'ScratchPad',
Equation: 'Equation'
},
close: function(obj){
var id = TDS.Notes.getIdFromObj(obj);
if(id){
var notes = TDS.Notes.Store[id];
if(notes){
notes.close();
}
}
},
get: function(id){
return TDS.Notes.Store[id];
},
open: function(obj){
var id = TDS.Notes.getIdFromObj(obj);
var notes = null;
if(id){
notes = TDS.Notes.Store[id];
if(!notes){
notes = TDS.Notes.getInstance(obj, id);
TDS.Notes.Store[id] = notes;
}
if(notes){
notes.open();
}else{
console.error('This object type could note create a valid notes instance?', obj);
}
}
return notes;
},
closeAll: function(){
for(var key in TDS.Notes.Store){
var notes = TDS.Notes.Store[key];
if(notes && notes.close && typeof notes == 'object'){
notes.close();
}
}
},
getInstance: function(obj, id){
return TDS.Notes.getFactory().buildNotes(obj, id);
},
setFactoryConfig: function(cfg){
this.getFactory().setConfig(cfg);
},
getFactory: function(){
if(!TDS.Notes._Factory){
TDS.Config = window.TDS.Config || {};
var fact   = new TDS.Notes.Factory();
fact.setConfig(TDS.Config.NotesConfig);
TDS.Notes._Factory = fact;
}
return TDS.Notes._Factory;
},
setFactory: function(factory){
TDS.Notes._Factory = factory;
},
getIdFromObj: function(obj){
if(!obj){
return TDS.Notes.Types.Global;
}else if(typeof obj == 'string'){
return obj;
}else if (typeof obj == 'number'){
return obj + '';
}else if(obj.id){
return obj.id + '_notes';
}else if(obj.position){
return obj.position + '_notes';
}
}
};

// FILE: dialog.js (a31296e9) 3/7/2014 11:24:13 AM

TDS.Notes.Dialog = function(args) {
args = args || {};
this.dom = args.dom;
this.cfg = args.cfg;
this._yuiDialog = null;
this._impl = args.impl;
};
Messages = window.Messages || { get: function(str) { return str; } };
TDS.Notes.Dialog.prototype.setInstance = function(impl) {
this._impl = impl;
};
TDS.Notes.Dialog.prototype._onShow = function() {
};
TDS.Notes.Dialog.prototype.loading = function() {
};
TDS.Notes.Dialog.prototype.loadingComplete = function() {
};
TDS.Notes.Dialog.prototype._onBeforeShow = function() {
};
TDS.Notes.Dialog.prototype._onHide = function() {
};
TDS.Notes.Dialog.prototype.loadCb = function(response) {
TDS.Notes.Debug && console.log("Load Callback for (this, response)", this, response);
this.loadingComplete();
if (this._impl.unserialize(response)) {
this._impl.saveState(response);
}
};
TDS.Notes.Dialog.prototype.load = function() {
var args = {
id: this.getId(),
data: {
type: this._impl.type,
id: this.getId()
},
cb: this.loadCb.bind(this)
};
TDS.Notes.Debug && console.log('Loading information for this Notes instance', this, args);
TDS.Notes.Events.Load.fire(args);
return args;
};
TDS.Notes.Dialog.prototype.preSave = function(args){
return true;
};
TDS.Notes.Dialog.prototype.submit = function() {
var args = {
id: this.getId(),
data: {
type: this._impl.type,
comment: this._impl.serialize()
},
cb: this.saveCb.bind(this)
};
if(this.preSave(args)){
this._impl.saveState(args.data.comment);
TDS.Notes.Debug && console.log('Saving information for this Notes instance', this, args);
TDS.Notes.Events.Save.fire(args);
this.close(true);
}
return args;
};
TDS.Notes.Dialog.prototype.saveCb = function(response) {
TDS.Notes.Debug && console.log('Save cb for the notes has been called, (this, response)', this, response);
};
TDS.Notes.Dialog.prototype.close = function (preventRevert) {
if (this._yuiDialog) {
this._yuiDialog.hide();
}
if (typeof this.preClose == 'function') {
this.preClose();
}
if (preventRevert !== true) {
this._impl.revertState();
}
};
TDS.Notes.Dialog.prototype.open = function() {
if (!this._yuiDialog) {
this.create();
}
this._yuiDialog.render(document.body);
this._yuiDialog.show();
if(this._impl){
this._impl.focus();
}
};
TDS.Notes.Dialog.prototype.getId = function() {
if (this.dom) {
return this.dom.id;
}
};
TDS.Notes.Dialog.prototype.create = function() {
var id = this.getId();
if (!id) {
console.error('Cannot create a dialog without a valid dom element (id, this): ', id, this);
return;
}
var dialog = new YAHOO.widget.Dialog(id, {
visible: true,
draggable: false,
modal: true,
close: false,
fixedcenter: true,
width: this.cfg.width,
height: this.cfg.height,
zIndex: 1,
postmethod: 'none'
});
dialog.setHeader(this.cfg.label || 'Comments');
dialog.beforeShowEvent.subscribe(this._onBeforeShow, this, true);
dialog.showEvent.subscribe(this._onShow, this, true);
dialog.hideEvent.subscribe(this._onHide, this, true);
var buttons = [
{ text: Messages.get('Cancel'), handler: { fn: this.close, scope: this } },
{ text: Messages.get('Submit and Close'), handler: { fn: this.submit, scope: this }, isDefault: true }
];
dialog.cfg.queueProperty('buttons', buttons);
YAHOO.util.Dom.addClass(dialog.element, 'TDS_Notes_dialog');
YAHOO.util.Dom.addClass(dialog.innerElement, 'comment');
YAHOO.util.Dom.addClass(dialog.header, 'comment-header');
YAHOO.util.Dom.addClass(dialog.body, 'comment-body');
YAHOO.util.Dom.addClass(dialog.form, 'comment-form');
this._yuiDialog = dialog;
return dialog;
};

// FILE: base.js (1e3060f9) 3/7/2014 11:24:13 AM

TDS.Notes.Base = function(){
this._saveState = ' ';
};
TDS.Notes.Base.prototype.create = function(){
TDS.Notes.Debug && console.log("Notes.Base class method, should be overriden: create");
};
TDS.Notes.Base.prototype.serialize   = function(){
TDS.Notes.Debug && console.log("Notes.Base class method, should be overriden: serialize");
};
TDS.Notes.Base.prototype.unserialize = function(response){
TDS.Notes.Debug && console.log("Notes.Base class method, should be overriden: unserialize");
};
TDS.Notes.Base.prototype.saveState = function(state){
this._saveState = state;
};
TDS.Notes.Base.prototype.getState = function(){
return this._saveState;
};
TDS.Notes.Base.prototype.revertState = function(){
this.unserialize(this.getState());
};
TDS.Notes.Base.prototype.focus = function(){
};
TDS.Notes.Base.prototype.unfocus = function(){
};

// FILE: textarea.js (1291c0c9) 3/7/2014 11:24:13 AM

TDS.Notes.TextArea = function(args){
args = args || {};
this.dom = args.dom;
this.type = TDS.Notes.Types.TextArea;
};
YAHOO.lang.extend(TDS.Notes.TextArea, TDS.Notes.Base);
TDS.Notes.TextArea.prototype.serialize = function(){
return this.note.value;
};
TDS.Notes.TextArea.prototype.unserialize = function(response){
if(typeof response != 'string'){return;}
return (this.note.value = response);
};
TDS.Notes.TextArea.prototype.create = function()
{
var ta = document.createElement('textarea');
ta.className = 'comment-input comment-textbox';
ta.rows = 4;
YAHOO.util.Dom.setStyle(ta, 'resize', 'none');
document.getElementById('note_container_' + this.dom.id).appendChild(ta);
this.note = ta;
return this.note;
};
TDS.Notes.TextArea.prototype.unfocus = function()
{
if(this.note){
this.note.unfocus();
}
}
TDS.Notes.TextArea.prototype.focus = function()
{
if(this.note){
this.note.focus();
}
};

// FILE: scratchpad.js (805022dd) 3/7/2014 11:24:13 AM

TDS.Notes.ScratchPad = function(args){
args = args || {};
this.dom = args.dom;
this.type = TDS.Notes.Types.ScratchPad;
};
YAHOO.lang.extend(TDS.Notes.ScratchPad, TDS.Notes.Base);
TDS.Notes.ScratchPad.prototype.serialize = function(){
return this.note.save();
};
TDS.Notes.ScratchPad.prototype.unserialize = function(response){
if(!response){return;}
if(typeof response == 'string' && response){
response = JSON.parse(response);
}
if(response){
this.note.load('list', response);
}
return true;
};
TDS.Notes.ScratchPad.prototype.create = function(){
var SPF = ScratchPad.Factory.getInstance();
var cId = 'note_container_' + this.dom.id;
this.note = SPF.getOrCreateScratchPadById(cId);
return this.note;
};

// FILE: dropdown.js (5aab6ee6) 3/7/2014 11:24:13 AM

TDS.Notes.DropDown = function(args){
args = args || {};
this.comments = args.DropComments || TDS.Comments || [];
this.dom = args.dom;
this.type = TDS.Notes.Types.DropDown;
};
YAHOO.lang.extend(TDS.Notes.DropDown, TDS.Notes.Base);
TDS.Notes.DropDown.prototype.serialize = function(){
return this.note.value;
};
TDS.Notes.DropDown.prototype.unserialize = function(response){
if(typeof response != 'string'){return;}
return (this.note.value = response);
};
TDS.Notes.DropDown.prototype.create = function()
{
var selectBox = document.createElement('select');
selectBox.className = 'comment-input comment-selectbox';
for(var i = 0; i < this.comments.length; ++i){
var commentLine = this.comments[i];
var option = document.createElement('option');
option.text  = commentLine;
option.value = commentLine;
selectBox.appendChild(option);
}
document.getElementById('note_container_' + this.dom.id).appendChild(selectBox);
this.note = selectBox;
if (this.comments.length > 0) {
this.saveState(this.comments[0]);
}
return selectBox;
};

// FILE: equation.js (a1770d4d) 3/7/2014 11:24:13 AM

TDS.Notes.Equation = function(args){
args = args || {};
this.dom = args.dom;
this.type = TDS.Notes.Types.Equation;
};
YAHOO.lang.extend(TDS.Notes.Equation, TDS.Notes.Base);
TDS.Notes.Equation.prototype.serialize = function(){
TDS.Notes.Debug && console.log("What save callback exists here?");
return this.note.serializeSettings();
};
TDS.Notes.Equation.prototype.unserialize = function(response){
if(!response){return;}
if(typeof response == 'string'){
response = JSON.parse(response);
}
TDS.Notes.Debug && console.log("What is in the response?", response);
if(this.note && response){
this.note.remove();
response.containerId = 'note_container_' + this.dom.id;
this.note = new MathJax.Editor.Widget(response);
}
return true;
};
TDS.Notes.Equation.prototype.create = function(){
this.note = new MathJax.Editor.Widget({
containerId: 'note_container_' + this.dom.id,
RestrictKeysToContent: true,
tabs: true,
tabConfig: {
Order: ['Algebra', 'Basic']
}
});
};

// FILE: factory.js (4ae1fd5a) 3/7/2014 11:24:13 AM

TDS.Notes.TypeConfig = TDS.Notes.TypeConfig || {
Default: {
width: '450px',
height: '150px'
},
ScratchPad: {
width: '790px',
height: '780px'
},
Equation: {
width: '500px',
height: '331px',
label: 'Equation Editor'
}
};
TDS.Notes.Factory = function(cfg) {
this.setConfig(cfg);
};
TDS.Notes.Factory.prototype.setConfig = function(cfg) {
cfg = cfg || {};
cfg.GlobalClass = cfg.GlobalClass || TDS.Notes.Types.TextArea;
cfg.GlobalLabel = cfg.GlobalLabel || "Global Comments";
TDS.Notes['global'] = TDS.Notes[cfg.GlobalClass];
cfg.DefaultClass = cfg.DefaultClass || TDS.Notes.Types.TextArea;
cfg.DefaultLabel = cfg.DefaultLabel || "Comments";
TDS.Notes.Debug && console.log("Setting the Notes Factory config with cfg:", cfg);
this.cfg = cfg;
};
TDS.Notes.Factory.prototype.getConfig = function() {
return this.cfg;
};
TDS.Notes.Factory.prototype.getDialogConfigForType = function(type) {
var cfg = JSON.parse(JSON.stringify(TDS.Notes.TypeConfig[type] || TDS.Notes.TypeConfig.Default));
cfg.label = (type == TDS.Notes.Types.Global) ? this.cfg.GlobalLabel : (cfg.label ? cfg.label : this.cfg.DefaultLabel);
return cfg;
};
TDS.Notes.Factory.prototype.getNotesType = function(obj) {
if (obj && obj.NotesType && TDS.Notes.Types[obj.NotesType]) {
return TDS.Notes.Types[obj.NotesType];
}
return this.cfg.DefaultClass || TDS.Notes.Types.TextArea;
};
TDS.Notes.Factory.prototype.buildNotes = function(obj, id) {
var type = null;
if(!obj){
type = TDS.Notes.Types.Global;
}else if(typeof obj == 'string') {
type = obj;
}else if (obj) {
type = this.getNotesType(obj);
}
if (typeof TDS.Notes[type] == 'function') {
TDS.Notes.Debug && console.log("Building notes for (obj, id, type)", id, type);
return this.createNotesType(id, type);
}else{
console.error("Cannot build notes with this type: ", type);
}
};
TDS.Notes.Factory.prototype.createNotesType = function(id, type) {
var dom = this.getContainer(id, type);
var notes = new TDS.Notes[type]({ dom: dom });
notes.saveState('');
var dialog = new TDS.Notes.Dialog({
cfg: this.getDialogConfigForType(type),
dom: dom,
impl: notes
});
TDS.Notes.Debug && console.log("Creating an instance of this notes (id, type, dialog, notes)", id, type, dialog, notes);
dialog.create();
notes.create();
return dialog;
};
TDS.Notes.Factory.prototype.getContainer = function(id, type) {
var dom = document.getElementById(id);
if (!dom) {
dom = document.createElement('form');
dom.id = id;
dom.className += 'notes_dialog_form notes_dialog_form_' + type;
document.body.appendChild(dom);
}
var cId = 'note_container_' + id;
var c = document.getElementById(cId);
if (!c) {
c = document.createElement('div');
c.className = 'notes_dialog_container';
c.id = cId;
dom.appendChild(c);
}
return dom;
};

// FILE: mc.group.js (e26207eb) 3/7/2014 11:24:13 AM

var ContentMCGroup = function(item)
{
this._item = item;
this._options = [];
this._optionHash = {};
};
ContentMCGroup.prototype.getItem = function() { return this._item; };
ContentMCGroup.prototype.addOption = function(option)
{
this._options.push(option);
this._optionHash[option.key] = option;
};
ContentMCGroup.prototype.getOptions = function() { return this._options; };
ContentMCGroup.prototype.getOption = function(optionKey)
{
var option = null;
if (YLang.isString(optionKey))
{
optionKey = optionKey.toUpperCase();
option = this._optionHash[optionKey] || null;
}
else if (YLang.isNumber(optionKey))
{
option = this._options[optionKey - 1] || null;
}
return option;
};
ContentMCGroup.prototype.getSelected = function()
{
for (var i = 0; i < this._options.length; i++)
{
if (this._options[i].isSelected()) return this._options[i];
}
return null;
};
ContentMCGroup.prototype.clear = function() {
var selected = this.getSelected();
if (selected != null) selected.deselect();
};
ContentMCGroup.prototype.getValue = function()
{
var option = this.getSelected();
return (option) ? option.key : null;
};
ContentMCGroup.prototype.setValue = function(optionKey)
{
var option = this.getOption(optionKey);
if (!option) return false;
option.select();
return true;
};
ContentMCGroup.prototype.getFocusedOption = function()
{
var focusedComponent = this.getItem().getActiveComponent();
for (var i = 0; i < this._options.length; i++)
{
var option = this._options[i];
if (option.getElement() == focusedComponent) return option;
}
return null;
};

// FILE: mc.option.js (22ed4919) 3/7/2014 11:24:13 AM

var ContentMCOption = function(options, key)
{
this._options = options;
this.key = key;
this.audioLink = null;
this.tts = null;
this.feedback = null;
};
ContentMCOption.prototype.toString = function() { return this.key; };
ContentMCOption.prototype.getElement = function()
{
var item = this._options.getItem();
var doc = item.getPage().getDoc();
return doc.getElementById('Item_OptionContainer_Response_MC_' + item.position + '_' + this.key);
};
ContentMCOption.prototype.getRadioGroup = function()
{
var item = this._options.getItem();
var form = item.getPage().getForm();
return form['Item_Response_MC_' + item.position];
};
ContentMCOption.prototype.getRadioButton = function()
{
var item = this._options.getItem();
var form = item.getPage().getForm();
return form['Item_Response_MC_' + item.position + '_' + this.key];
};
ContentMCOption.prototype.getSoundLink = function()
{
var item = this._options.getItem();
var doc = item.getPage().getDoc();
var soundDIV = doc.getElementById('Item_OptionSound_Response_MC_' + item.position + '_' + this.key);
if (soundDIV == null) return null;
var soundLink = soundDIV.getElementsByTagName('a')[0];
return soundLink;
};
ContentMCOption.prototype.getContentElement = function()
{
var optionElement = this.getElement();
return YUD.getElementsByClassName('optionContent', 'div', optionElement);
};
ContentMCOption.prototype.getFeedbackElement = function()
{
var optionElement = this.getElement();
return Util.Dom.getElementByClassName('optionFeedback', 'div', optionElement);
};
ContentMCOption.prototype.showFeedback = function()
{
var feedbackElement = this.getFeedbackElement();
if (feedbackElement != null)
{
YUD.addClass(feedbackElement, 'showing');
}
};
ContentMCOption.prototype.hideFeedback = function()
{
var feedbackElement = this.getFeedbackElement();
if (feedbackElement != null)
{
YUD.removeClass(feedbackElement, 'showing');
}
};
ContentMCOption.prototype.select = function(force)
{
var currentSelection = this._options.getSelected();
if (currentSelection == this && force !== true) return false;
if (force)
{
var options = this._options.getOptions();
Util.Array.each(options, function(option)
{
option.deselect();
});
}
else if (currentSelection)
{
currentSelection.deselect();
}
var radioButton = this.getRadioButton();
if (!radioButton.checked)
{
radioButton.checked = true;
}
YUD.addClass(this.getElement(), 'optionSelected');
var page = this._options._item.getPage();
var pageAccProps = page.getAccommodationProperties();
if (pageAccProps != null && pageAccProps.showFeedback()) this.showFeedback();
if (typeof (window.tdsUpdateItemResponse) == 'function')
{
var position = this._options._item.position;
window.tdsUpdateItemResponse(position, this.key);
}
return true;
};
ContentMCOption.prototype.deselect = function()
{
var optionElement = this.getElement();
YUD.removeClass(optionElement, 'optionSelected');
var radioButton = this.getRadioButton();
radioButton.checked = false;
this.hideFeedback();
};
ContentMCOption.prototype.isSelected = function()
{
var radioButton = this.getRadioButton();
return (radioButton && radioButton.checked === true);
};
ContentMCOption.prototype.hasStrikethrough = function()
{
var element = this.getElement();
return (element && YUD.hasClass(element, 'strikethrough'));
};
ContentMCOption.prototype.toggleStrikethrough = function()
{
var element = this.getElement();
if (element) YUD.toggleClass(element, 'strikethrough');
};
ContentMCOption.prototype.toString = function() { return this.key; };

// FILE: ms.group.js (131c3035) 3/7/2014 11:24:13 AM

var ContentMSGroup = function(item)
{
this._minChoices = 0;
this._maxChoices = 0;
ContentMSGroup.superclass.constructor.call(this, item);
};
YAHOO.lang.extend(ContentMSGroup, ContentMCGroup);
ContentMSGroup.prototype.setMinChoices = function(num) {
this._minChoices = num;
};
ContentMSGroup.prototype.getMinChoices = function () {
return this._minChoices;
};
ContentMSGroup.prototype.setMaxChoices = function (num) {
this._maxChoices = num;
};
ContentMSGroup.prototype.getMaxChoices = function () {
return this._maxChoices;
};
ContentMSGroup.prototype.getSelected = function()
{
var selectedOptions = [];
for (var i = 0; i < this._options.length; i++)
{
if (this._options[i].isSelected()) {
selectedOptions.push(this._options[i]);
}
}
return selectedOptions;
};
ContentMSGroup.prototype.clear = function() {
var selected = this.getSelected();
for (var i = 0; i < selected.length; i++) {
selected[i].deselect();
}
};
ContentMSGroup.prototype.getValue = function()
{
var options = this.getSelected();
return options.join(',');
};
ContentMSGroup.prototype.setValue = function(value) {
this.clear();
if (value == null) {
return false;
}
var optionKeys = value.split(',');
for (var i = 0; i < optionKeys.length; i++) {
var optionKey = optionKeys[i];
var option = this.getOption(optionKey);
if (option != null) option.select();
}
return true;
};

// FILE: ms.option.js (5083e379) 3/7/2014 11:24:13 AM

var ContentMSOption = function(options, key)
{
ContentMSOption.superclass.constructor.call(this, options, key);
};
YAHOO.lang.extend(ContentMSOption, ContentMCOption);
ContentMSOption.prototype._validateSelection = function() {
var maxChoices = this._options.getMaxChoices();
var selected = this._options.getSelected();
var selectedCount = selected.length;
if (maxChoices == 1 && selectedCount > 0) {
selected[0].deselect();
} else if (maxChoices > 0 && maxChoices <= selectedCount) {
return false;
}
return true;
};
ContentMSOption.prototype.select = function()
{
var checkbox = this.getRadioButton();
if (checkbox.checked) {
this.deselect();
} else {
if (!this._validateSelection()) {
return false;
}
checkbox.checked = true;
YUD.addClass(this.getElement(), 'optionSelected');
var page = this._options._item.getPage();
var pageAccProps = page.getAccommodationProperties();
if (pageAccProps != null && pageAccProps.showFeedback()) this.showFeedback();
}
return true;
};

// FILE: module_mc.js (93681727) 5/2/2014 12:55:57 PM

ContentManager.onItemEvent('init', function(page, item, itsItem) {
if (item.isResponseType('Scaffolding')) return;
var format = item.format.toUpperCase();
if ((format != 'MS') && (format != 'MC') && (format != 'SI')) return;
if (itsItem.options == null) return;
var options;
if (item.format != null && item.format.toUpperCase() == 'MS') {
options = new ContentMSGroup(item);
options.setMinChoices(itsItem.optionsConfig.minChoices);
options.setMaxChoices(itsItem.optionsConfig.maxChoices);
} else {
options = new ContentMCGroup(item);
}
Util.Array.each(itsItem.options, function(itsOption)
{
var optionKey = itsOption.key.toUpperCase();
var option;
if (item.format != null && item.format.toUpperCase() == 'MS') {
option = new ContentMSOption(options, optionKey);
} else {
option = new ContentMCOption(options, optionKey);
}
options.addOption(option);
option.tts = itsOption.tts;
option.feedback = itsOption.feedback;
});
item.MC = options;
});
ContentManager.onItemEvent('available', function(page, item)
{
if (item.MC == null) return;
if (page.layout == 'wai' && item.format == 'MS') {
var itemDiv = item.getElement();
YUD.addClass(itemDiv, 'multipleChoiceItem format_ms');
}
var options = item.MC.getOptions();
Util.Array.each(options, function(option)
{
var optionContainer = option.getElement();
var radioButton = option.getRadioButton();
var radioButtonGroup = option.getRadioGroup();
if (ContentManager.enableARIA)
{
radioButton.setAttribute('aria-label', 'Option ' + option.key);
}
item.addComponent(optionContainer);
if (option.feedback != null)
{
var pageAccProps = page.getAccommodationProperties();
if (pageAccProps != null && pageAccProps.showFeedback())
{
var doc = item.getPage().getDoc();
var feedbackElement = doc.createElement('div');
YUD.addClass(feedbackElement, 'optionFeedback');
feedbackElement.innerHTML = option.feedback;
optionContainer.appendChild(feedbackElement);
if (option.isSelected()) option.showFeedback();
else option.hideFeedback();
}
}
YUE.on(radioButton, 'click', function(ev)
{
option.select(true);
});
YUE.on(radioButton, 'focus', function(ev)
{
YUD.setStyle(optionContainer, 'background-color', 'orange');
});
YUE.on(radioButton, 'blur', function(ev)
{
YUD.setStyle(optionContainer, 'background-color', '');
});
var clickType = (YAHOO.env.ua.webkit > 0 && YAHOO.env.ua.webkit <= 419.3) ? 'mousedown' : 'click';
YUE.on(optionContainer, clickType, function(clickEvent)
{
if (item.isReadOnly()) return;
if (clickEvent.altKey) return;
option.select();
});
});
});
ContentManager.onItemEvent('keyevent', function(page, item, evt)
{
if (!item.MC) return;
if (evt.type != 'keydown') return;
if (evt.ctrlKey || evt.altKey) return;
var options = item.MC;
if (evt.key == 'Enter')
{
if (ContentManager.isReadOnly()) return;
var option = options.getFocusedOption();
if (option) option.select();
}
});
ContentManager.onItemEvent('menushow', function(page, item, menu, evt)
{
if (!item.MC) return;
var optionGroup = item.MC;
var focusedOption = optionGroup.getFocusedOption();
if (!focusedOption) return;
var accProps = page.getAccommodationProperties();
if (accProps.hasStrikethrough())
{
var strikedthrough = YUD.hasClass(focusedOption.getElement(), 'strikethrough');
var menuLabel = { text: (focusedOption.hasStrikethrough() ? Messages.get('TDSMC.MenuLabel.UndoStrikethrough') : Messages.get('TDSMC.MenuLabel.Strikethrough')), classname: 'strikethrough' };
menu.addMenuItem('component', menuLabel, function()
{
focusedOption.toggleStrikethrough();
});
}
});
(function()
{
var getter = function(item, response)
{
var value = item.MC.getValue();
if (!value) return;
response.value = value;
response.isAvailable = true;
response.isSelected = true;
response.isValid = true;
};
var setter = function(item, value)
{
item.MC.setValue(value);
};
ContentManager.registerResponseHandler('vertical', getter, setter);
ContentManager.registerResponseHandler('vertical MS', getter, setter);
ContentManager.registerResponseHandler('horizontal', getter, setter);
ContentManager.registerResponseHandler('stacked', getter, setter);
ContentManager.registerResponseHandler('stackedB', getter, setter);
})();

// FILE: ebsr.js (5face77d) 3/7/2014 11:24:06 AM

var EBSR = function (xmlString, item) {
this._xmlString = xmlString;
var ebsrItem = this;
this._position = item.position;
var nodes = Util.Xml.parseFromString(xmlString);
var docElement = nodes.documentElement;
this.interactionsXml = docElement.getElementsByTagName('choiceInteraction');
this._interactions = [];
this._interactionHash = {};
$.each(this.interactionsXml, function (i, interactionXml) {
var contentOptionClass = [];
contentOptionClass["MS"] = EBSR.MSOption;
contentOptionClass["MC"] = EBSR.MCOption;
var interaction = new EBSR.QTI(interactionXml, item.position, contentOptionClass, i + 1);
interaction.options.getItem = function () {
return item;
};
ebsrItem.addInteraction(interaction);
});
};
EBSR.prototype.addInteraction = function(interaction) {
this._interactions.push(interaction);
this._interactionHash[interaction.responseId] = interaction;
};
EBSR.prototype.getInteractions = function() {
return this._interactions;
};
EBSR.prototype.getPrompts = function() {
var interactions = this.getInteractions();
var prompts = [];
Util.Array.each(interactions, function(interaction) {
var prompt = interaction.getPrompt();
if (prompt && prompt.length == 1) {
prompts.push(prompt[0]);
}
});
return prompts;
};
EBSR.prototype.getInteractionByKey = function (key) {
var interactions = this.getInteractions();
var targetInteraction = {};
Util.Array.each(interactions, function(interaction) {
if (interaction.key == key) {
targetInteraction = interaction;
}
});
return targetInteraction;
};
EBSR.prototype.getInteraction = function (key) {
return this._interactionHash[key];
};
EBSR.prototype.getFocusedOption = function (focusedComponent) {
for (var i = 0; i< this._interactions.length; i++) {
var options = this._interactions[i].getOptions();
for (var j = 0; j < options.length; j++) {
var option = options[j];
if (option.getElement() == focusedComponent) return option;
}
}
};
EBSR.prototype.populateStem = function () {
if (this._xmlString == null) return;
var xmlDoc = Util.Xml.parseFromString(this._xmlString);
var docEl = xmlDoc.documentElement;
var stemContent = $(docEl).children().not('choiceInteraction');
$("#Stem_" + this._position).html(stemContent.contents());
};
EBSR.prototype.generateHTML = function (answerContainer) {
var interactions = this.getInteractions();
Util.Array.each(interactions, function (interaction) {
interaction.generateInteractionHTML(answerContainer);
});
};
EBSR.prototype.getAllComponentLists = function () {
var componentList = [];
var interactions = this.getInteractions();
Util.Array.each(interactions, function (interaction) {
var interactionComponentList = interaction.getComponentList();
componentList = componentList.concat(interactionComponentList);
});
return componentList;
};
EBSR.prototype.getAllRadioButtons = function () {
var radioButtons = [];
var interactions = this.getInteractions();
Util.Array.each(interactions, function (interaction) {
var interactionRadioButtons = interaction.getRadioButtons();
radioButtons = radioButtons.concat(interactionRadioButtons);
});
return radioButtons;
};
EBSR.prototype.setValue = function (value) {
if (typeof value != 'string' ||
value.indexOf('<itemResponse>') == -1) {
return false;
}
var ebsr = this;
var nodes = Util.Xml.parseFromString(value);
var docElement = nodes.documentElement;
$('response', docElement).each(function (responseIdx, responseNode) {
var responseId = responseNode.getAttribute('id');
var interaction = ebsr.getInteraction(responseId);
if (interaction && interaction.options) {
interaction.options.clear();
$('value', responseNode).each(function (valueIdx, valueNode) {
var optionId = $(valueNode).text();
if (optionId) {
var option = interaction.options.getOption(optionId);
if (option) {
option.select(true);
}
}
});
}
});
return true;
};
EBSR.prototype.getResponse = function() {
var responseEl = ['<itemResponse>'];
var interactions = this.getInteractions();
var createSelectedNode = function (selected) {
if (selected) {
responseEl.push('<value>');
responseEl.push(selected);
responseEl.push('</value>');
}
};
Util.Array.each(interactions, function(interaction) {
responseEl.push('<response id="' + interaction.responseId + '">');
var selected = interaction.options.getSelected();
if (interaction.type.toUpperCase() == "MS") {
for (var i = 0; i < selected.length; i++) {
createSelectedNode(selected[i]);
}
} else {
createSelectedNode(selected);
}
responseEl.push('</response>');
});
responseEl.push('</itemResponse>');
return responseEl.join('');
};
EBSR.prototype.isValid = function() {
var interactions = this.getInteractions();
var response = true;
Util.Array.each(interactions, function (interaction) {
var selected = interaction.options.getSelected();
if (!selected || selected.length == 0) {
response = false;
}
});
return response;
};
EBSR.MCOption = function (options, key, interactionKey) {
EBSR.MCOption.superclass.constructor.call(this, options, key);
this._interactionKey = interactionKey;
};
YAHOO.lang.extend(EBSR.MCOption, ContentMCOption);
EBSR.MCOption.prototype.getElement = function () {
var item = this._options.getItem();
var doc = item.getPage().getDoc();
return doc.getElementById('Item_OptionContainer_Response_EBSR_' +
item.position + '_Part' + this._interactionKey + '_' + this.key);
};
EBSR.MCOption.prototype.getRadioGroup = function () {
var item = this._options.getItem();
var form = item.getPage().getForm();
return form['Item_Response_EBSR_' + item.position + '_Part' + this._interactionKey];
};
EBSR.MCOption.prototype.getRadioButton = function () {
var item = this._options.getItem();
var form = item.getPage().getForm();
return form['Item_Response_EBSR_' + item.position + '_Part' + this._interactionKey +
'_' + this.key];
};
EBSR.MCOption.prototype.getSoundLink = function () {
var item = this._options.getItem();
var doc = item.getPage().getDoc();
var soundDIV = doc.getElementById('Item_OptionSound_Response_EBSR_' + item.position +
'_Part' + this._interactionKey + '_' + this.key);
if (soundDIV == null) return null;
var soundLink = soundDIV.getElementsByTagName('a')[0];
return soundLink;
};
EBSR.MCOption.prototype.select = function (force) {
var currentSelection = this._options.getSelected();
if (currentSelection == this && force !== true) {
return false;
}
if (force) {
var options = this._options.getOptions();
Util.Array.each(options, function (option) {
option.deselect();
});
}
else if (currentSelection) {
currentSelection.deselect();
}
var radioButton = this.getRadioButton();
if (!radioButton.checked) {
radioButton.checked = true;
}
$(this.getElement()).addClass('optionSelected');
var page = this._options.getItem().getPage();
var pageAccProps = page.getAccommodationProperties();
if (pageAccProps != null && pageAccProps.showFeedback()) this.showFeedback();
return true;
};
EBSR.MSOption = function (options, key, interactionKey) {
EBSR.MSOption.superclass.constructor.call(this, options, key, interactionKey);
};
YAHOO.lang.extend(EBSR.MSOption, EBSR.MCOption);
EBSR.MSOption.prototype.select = function (force) {
var checkbox = this.getRadioButton();
if (checkbox.checked && !force) {
this.deselect();
} else {
checkbox.checked = true;
$(this.getElement()).addClass('optionSelected');
var page = this._options.getItem().getPage();
var pageAccProps = page.getAccommodationProperties();
if (pageAccProps != null && pageAccProps.showFeedback()) this.showFeedback();
}
return true;
};

// FILE: ebsr.qti.js (d03cebd7) 3/7/2014 11:24:06 AM

EBSR.QTI = function (interactionXml, itemKey, contentOptionClass, interactionKey) {
this._componentList = [];
if (contentOptionClass == null) {
contentOptionClass = [];
contentOptionClass["MS"] = ContentMSOption;
contentOptionClass["MC"] = ContentMCOption;
}
var options;
this.responseId = interactionXml.getAttribute('responseIdentifier');
this.maxChoice = interactionXml.getAttribute('maxChoice');
if (this.maxChoice && (this.maxChoice != "1")) {
this.type = "MS";
options = new ContentMSGroup();
} else {
this.type = "MC";
options = new ContentMCGroup();
};
this.itemKey = itemKey;
this.key = interactionKey;
var prompt = interactionXml.getElementsByTagName('prompt')[0];
var promptToHtml = Util.Xml.serializeToString(prompt);
this.promptText = $(promptToHtml).html();
var optionsXml = interactionXml.getElementsByTagName('simpleChoice');
var optionsArray = [];
var contentOption = contentOptionClass[this.type];
Util.Array.each(optionsXml, function (optionXml) {
var optionKey = optionXml.getAttribute('identifier').toUpperCase();
var option = new contentOption(options, optionKey, interactionKey);
options.addOption(option);
var parsedOption = {};
parsedOption.key = optionKey;
var optionToHtml = Util.Xml.serializeToString(optionXml);
parsedOption.innerHTML = $(optionToHtml).html();
optionsArray[optionKey] = parsedOption;
});
this.options = options;
this.parsedOptions = optionsArray;
};
EBSR.QTI.prototype.getOptions = function () {
return this.options.getOptions();
};
EBSR.QTI.prototype.getPrompt = function () {
return this._prompt;
};
EBSR.QTI.prototype.getHeader = function () {
return this._header;
};
EBSR.QTI.prototype.getComponentList = function () {
return this._componentList;
};
EBSR.QTI.prototype.generateInteractionHTML = function (answerContainer) {
var interactionHTML = $('<div></div')
.attr('id', 'Item_Container_EBSR_' + this.itemKey + '_' + this.key)
.addClass('interactionContainer')
.appendTo(answerContainer);
this.generatePromptHTML(interactionHTML);
this._componentList.push(this._prompt[0]);
var interaction = this;
var options = this.getOptions();
if (options && options.length > 0) {
Util.Array.each(options, function (option) {
var optionContainer = interaction.generateOptionHTML(interactionHTML, option);
interaction._componentList.push(optionContainer);
$(optionContainer).find('input')
.attr('aria-label', 'Option ' + option.key)
.bind('click', function(ev) {
option.select(true);
})
.bind('focus', function(ev) {
$(optionContainer).css({ 'background-color': 'orange' });
})
.bind('blur', function(ev) {
$(optionContainer).css({ 'background-color': '' });
});
var clickType = (YAHOO.env.ua.webkit > 0 && YAHOO.env.ua.webkit <= 419.3) ? 'mousedown' : 'click';
$(optionContainer).bind(clickType, function (clickEvent) {
if (clickEvent.altKey) return;
option.select();
});
});
}
};
EBSR.QTI.prototype.generatePromptHTML = function (parent) {
var headerKey = 'EBSR.Header.Part' + this.key;
var ttsKey = 'TDSTTS.Speak.EBSR.Part' + this.key;
var headerText = Messages.get(headerKey);
this._header = $('<h3>' + headerText + '</h3>').appendTo(parent);
if (Messages.has(ttsKey)) {
var ttsText = Messages.get(ttsKey);
this._header.attr('ssml', 'sub')
.attr('ssml_alias', ttsText)
.addClass('TTS')
.addClass('speakAs');
}
this._prompt = $('<div></div>')
.attr('id', 'Item_InteractionPrompt_Response_EBSR_' + this.itemKey + '_' + this.key)
.addClass('interactionPrompt')
.html(this.promptText)
.appendTo(parent);
};
EBSR.QTI.prototype.generateOptionHTML = function (parent, option) {
var optionIdString = this.itemKey + '_Part' + this.key;
var nodeId = 'Item_OptionContainer_Response_EBSR_' + optionIdString + '_' + option.key;
var nodeClass = "EBSR_" + this.type.toLowerCase();
var node = $('<div></div>')
.attr('id', nodeId)
.attr('title', Messages.get('EBSR.Header.Part' + this.key) + ' Option ' + option.key)
.addClass('optionContainer option' + option.key + ' ' + nodeClass)
.append('<span class="striked"></span>')
.append('<span class="optionClicker"></span>')
.appendTo(parent);
var inputButton = $('<input></input')
.attr('name', 'Item_Response_EBSR_' + optionIdString)
.attr('value', option.key)
.attr('id', 'Item_Response_EBSR_' + optionIdString + '_' + option.key)
.addClass('option')
.appendTo(node);
if (this.type.toUpperCase() == "MS") {
var type = 'checkbox';
inputButton.attr('data-tts-prefix', 'TDSTTS.Speak.Select' + option.key);
} else {
type = 'radio';
}
inputButton.prop('type', type);
$('<div></div>')
.addClass('optionContent')
.html(this.parsedOptions[option.key].innerHTML)
.appendTo(node);
return node[0];
};

// FILE: module_ebsr.js (8e8f1777) 7/23/2014 4:30:36 PM

(function(CM) {
CM.onItemEvent('available', function (page, item) {
if (!item.isResponseType('EBSR')) return;
var qtiXml = (item.qti) ? item.qti.xml : null;
if (qtiXml == null) {
console.warn('EBSR: Could not find QTI for item ' + item.getID());
return;
}
var ebsr = new EBSR(qtiXml, item);
item.EBSR = ebsr;
var ebsrEl = document.getElementById('EBSR_' + item.position);
ebsr.generateHTML(ebsrEl);
ebsr.populateStem();
var componentList = ebsr.getAllComponentLists();
if (componentList && componentList.length) {
for (var i = 0; i < componentList.length; i++) {
item.addComponent(componentList[i]);
}
}
if (item.value) {
ebsr.setValue(item.value);
}
});
CM.onItemEvent('keyevent', function (page, item, evt) {
var ebsr = item.EBSR;
if (!ebsr) return;
if (evt.type != 'keydown') return;
if (evt.ctrlKey || evt.altKey) return;
if (evt.key == 'Enter') {
if (CM.isReadOnly()) return;
var focusedComponent = item.getActiveComponent();
var option = ebsr.getFocusedOption(focusedComponent);
if (option) {
option.select();
}
}
});
function onMenuShowStrikethrough(page, item, menu, ebsr, interaction) {
var focusedComponent = item.getActiveComponent();
var focusedOption = ebsr.getFocusedOption(focusedComponent);
if (!focusedOption) return;
var accProps = page.getAccommodationProperties();
if (accProps && accProps.hasStrikethrough()) {
var menuText = focusedOption.hasStrikethrough() ? Messages.get('TDSMC.MenuLabel.UndoStrikethrough') : Messages.get('TDSMC.MenuLabel.Strikethrough');
var menuItem = { text: menuText, classname: 'strikethrough' };
menu.addMenuItem('component', menuItem, function () {
focusedOption.toggleStrikethrough();
});
}
};
function onMenuShowTTS(page, item, menu, ebsr, interaction, selection) {
var accProps = page.getAccommodationProperties();
if (!accProps.hasTTSItem()) return;
if (TDS.Audio.isActive()) return;
var pageWin = page.getActiveWin();
var languages = CM.getLanguage() == 'ESN' ? ['ESN', 'ENU'] : ['ENU'];
var focusedComponent = item.getActiveComponent();
var focusedOption = ebsr.getFocusedOption(focusedComponent);
var domToParse = [];
domToParse.push(interaction.getHeader()[0]);
domToParse.push(interaction.getPrompt()[0]);
var ttsMenu = new TTS.Menu(languages);
var menuCfg = ttsMenu.getMenuCfg(domToParse, selection, pageWin, item.stemTTS, page, item);
for (var i = 0; i < interaction.getOptions().length; ++i) {
var element = (interaction.getOptions())[i].getElement();
var testCfg = null;
var testMenu = new TTS.Menu(languages);
testCfg = testMenu.addFocusedOption(testCfg, element);
if (testCfg.PRI.cb) {
domToParse.push(element);
}
}
if (domToParse.length > 2) {
ttsMenu.addOptions(menuCfg, domToParse);
}
if (focusedOption && focusedOption.key) {
menuCfg.SEL_PRI = false;
menuCfg.SEL_SEC = false;
menuCfg.PRI.level = 'component';
menuCfg.SEC.level = 'component';
menuCfg.STOP.level = 'component';
menuCfg.PAUSE.level = 'component';
menuCfg.RESUME.level = 'component';
ttsMenu.addFocusedOption(menuCfg, item.getActiveComponent());
}
TTS.MenuSystem.addMenuSetup(menu, menuCfg);
TTS.Config.Debug && console.log("TTS On Item Menushow config", menuCfg);
}
function onMenuShowASL(page, item, menu, ebsr, interaction) {
var attachments = item.getAslAttachments();
if (attachments && attachments.length > 0) {
for (var i = 0; i < attachments.length; ++i) {
var at = attachments[i];
if (at.subType.toLowerCase() == 'targeted') {
var target = at.target;
if (interaction.responseId == target) {
var menuItem = {
text: Messages.get('TDSContentEventJS.Label.ASLItem'),
classname: 'ASL',
onclick: {
fn: function () {
AslModule.showImageDialog(at.url,page.getZoomFactor());
}
}
};
menu.addMenuItem('component', menuItem);
return;
}
}
}
}
}
function onMenuShowStemTTS(page, item, menu, ebsr, stem, selection) {
var accProps = page.getAccommodationProperties();
if (!accProps.hasTTSItem()) return;
if (TDS.Audio.isActive()) return;
var pageWin = page.getActiveWin();
var languages = CM.getLanguage() == 'ESN' ? ['ESN', 'ENU'] : ['ENU'];
var domToParse = [];
domToParse.push(stem);
var ttsMenu = new TTS.Menu(languages);
var menuCfg = ttsMenu.getMenuCfg(domToParse, selection, pageWin, item.stemTTS, page, item);
var interactions = ebsr.getInteractions();
for (var i = 0; i < interactions.length; i++) {
var interaction = interactions[i];
domToParse.push(interaction.getHeader()[0]);
domToParse.push(interaction.getPrompt()[0]);
for (var j = 0; j < interaction.getOptions().length; ++j) {
domToParse.push((interaction.getOptions())[j].getElement());
}
}
ttsMenu.addOptions(menuCfg, domToParse);
TTS.MenuSystem.addMenuSetup(menu, menuCfg);
TTS.Config.Debug && console.log("TTS On Item Menushow config", menuCfg);
}
CM.onItemEvent('menushow', function (page, item, menu, evt, selection) {
var ebsr = item.EBSR;
if (!ebsr) return;
function getClosestInteraction (target) {
var pageEl = page.getElement();
var $closestInteraction = $(target).closest('div.interactionContainer', pageEl);
return $closestInteraction;
};
var interaction = null;
var $interactionContainer = getClosestInteraction(evt.target);
if ($interactionContainer && $interactionContainer.length == 0) {
var componentEl = item.getActiveComponent();
$interactionContainer = getClosestInteraction(componentEl);
}
if ($interactionContainer.length > 0) {
var interactionId = $interactionContainer.attr('id');
if (interactionId) {
var interactionKey = interactionId.split('_').pop();
if (interactionKey) {
interaction = ebsr.getInteractionByKey(interactionKey);
}
}
}
if (interaction != null) {
onMenuShowStrikethrough(page, item, menu, ebsr, interaction);
onMenuShowTTS(page, item, menu, ebsr, interaction, selection);
onMenuShowASL(page, item, menu, ebsr, interaction);
}
var $stemContainer = $(evt.target).closest('div.stemContainer');
if ($stemContainer.length > 0) {
onMenuShowStemTTS(page, item, menu, ebsr, $stemContainer[0], selection);
}
});
function responseGetter(item, response) {
if (item.EBSR) {
response.value = item.EBSR.getResponse();
response.isValid = item.EBSR.isValid();
response.isSelected = response.isValid;
response.isAvailable = true;
} else {
response.isAvailable = false;
}
}
function responseSetter(item, value) {
if (item.EBSR) {
item.EBSR.setValue(value);
}
}
CM.registerResponseHandler('EBSR', responseGetter, responseSetter);
})(ContentManager);

// FILE: wl_item.js (9503d043) 5/2/2014 12:55:58 PM

WordListItem.tagType = ["div", "span"];
WordListItem.attributeName = "data-word-index";
WordListItem.groupAttributeName = "data-wl-group";
WordListItem.ClassNameString = "TDS_WORD_LIST";
WordListItem.ClassNameStringHover = "TDS_WORD_LIST_HOVER";
WordListItem.CTag = 0;
WordListItem.GTag = 0;
function WordListItem () {
var myPageSpans = [];
var myPageZOrders = {
current: -1,
total: 0
};
var spanCount = 0;
this.getSpanCount = function() { return spanCount;};
this.TagSingleSpan = function (span) {
YUD.addClass(span, WordListItem.ClassNameString);
var spanid = 'word-list-' + WordListItem.CTag;
WordListItem.CTag++;
YUD.setAttribute(span, 'id', spanid);
YAHOO.util.Event.addListener(span, 'mouseenter', WordListItem.mouseOver, this);
YAHOO.util.Event.addListener(span, 'mouseleave', WordListItem.mouseOut, this);
YAHOO.util.Event.addListener(span, 'click', WordListItem.clickHandler, this);
myPageSpans[spanCount] = span;
++spanCount;
myPageZOrders.total = spanCount;
};
this.TagSpans = (function (elements) {
var spans = [];
var dupSpans = [];
var tmpSpanCount = 0;
for (var i = 0; i < WordListItem.tagType.length; ++i) {
var divs = elements.getElementsByTagName(WordListItem.tagType[i]);
for (var j = 0; divs != null && j < divs.length; ++j) {
var div = divs[j];
if (YUD.getAttribute(div, WordListItem.attributeName) != null) {
spans[tmpSpanCount] = div;
++tmpSpanCount;
}
}
for (j = 0; j < spans.length; ++j) {
spans[j].setAttribute(WordListItem.groupAttributeName, "" + WordListItem.GTag);
var fff = new Retagger(spans[j]);
fff.Retag();
WordListItem.GTag++;
}
}
var itemKey = this.wl_res.itemKey;
var baseKey = this.wl_res.bankKey + '-' + this.wl_res.itemKey + '-';
WordListPanel.requestQ[itemKey] = [];
for (var i = 0; i < WordListItem.tagType.length; ++i) {
divs = elements.getElementsByTagName(WordListItem.tagType[i]);
for (var j = 0; divs != null && j < divs.length; ++j) {
div = divs[j];
var index = YUD.getAttribute(div, WordListItem.attributeName);
if (index != null) {
var key = baseKey + index.toString();
WordListPanel.requestQ[itemKey].push({ wl_item: this, span: div, key: key });
if (!dupSpans[parseInt(index)]) {
var indexString = WordListPanel.indexHdr + "=" + index.toString();
if (WordListPanel.indices == "") WordListPanel.indices = indexString;
else WordListPanel.indices = WordListPanel.indices + '&' + indexString;
dupSpans[parseInt(index)] = true;
}
}
}
}
WordListPanel.sendRequest(this);
WordListPanel.indices = '';
});
this.HandleKey = function (evt) {
var isHandled = false;
if ((evt.type == 'keyup') && (!evt.ctrlKey)) {
if (myPageZOrders != null) {
zo = myPageZOrders;
spans = myPageSpans;
if (zo.current >= 0) {
var div = spans[zo.current];
var entry = { wl_item: this, span: div };
WordListPanel.processClick(entry,
this.getGroupHtml(div));
this.AddClassToGroup(div,
WordListItem.ClassNameString, WordListItem.ClassNameStringHover);
isHandled = true;
}
}
}
if (evt.keyCode == 27)
{
if (WordListPanel.panel != null)
WordListPanel.panel.hide();
return isHandled;
}
if (!(evt.type == 'keydown'))
return isHandled;
if (!evt.ctrlKey) return;
if (evt.keyCode != 88)
return isHandled;
isHandled = true;
if ((WordListPanel.panel != null)  &&
(WordListPanel.panel.cfg.getProperty('visible') == true) &&
(WordListPanel.tabView != null) &&
(WordListPanel.tabCount > 0)) {
WordListPanel.tabCurrent = (WordListPanel.tabCurrent + 1) % WordListPanel.tabCount;
WordListPanel.tabView.selectTab(WordListPanel.tabCurrent);
return isHandled;
}
var spanGroupAttr = "";
if (myPageZOrders != null) {
var zo = myPageZOrders;
var spans = myPageSpans;
if (zo.current >= 0) {
spanGroupAttr = YUD.getAttribute(spans[zo.current],WordListItem.groupAttributeName);
this.AddClassToGroup(
spans[zo.current],WordListItem.ClassNameString, WordListItem.ClassNameStringHover);
}
zo.current = zo.current + 1;
while ((zo.current < zo.total) &&
(YUD.getAttribute(spans[zo.current],WordListItem.groupAttributeName) == spanGroupAttr)) {
zo.current = zo.current + 1;
}
if (zo.current == zo.total) {
zo.current = -1;
return isHandled;
}
this.AddClassToGroup(spans[zo.current],WordListItem.ClassNameStringHover, WordListItem.ClassNameString);
ContentManager.log("wordlist: focus span " + zo.current + " out of " + zo.total + " evt is " + evt.type);
}
return isHandled;
};
this.AddClassToGroup = function(div, classToAdd, classToRemove) {
var groupTag = YAHOO.util.Dom.getAttribute(div,WordListItem.groupAttributeName);
for (var j = 0; j < myPageSpans.length; ++j) {
if (YAHOO.util.Dom.getAttribute(myPageSpans[j],WordListItem.groupAttributeName) == groupTag) {
YAHOO.util.Dom.removeClass(myPageSpans[j], classToRemove);
YAHOO.util.Dom.addClass(myPageSpans[j], classToAdd);
}
}
};
this.getGroupHtml = function(div) {
var groupTag = YAHOO.util.Dom.getAttribute(div, WordListItem.groupAttributeName);
var rv = "";
for (var j = 0; j < myPageSpans.length; ++j) {
if (YAHOO.util.Dom.getAttribute(myPageSpans[j], WordListItem.groupAttributeName) == groupTag) {
rv = rv + myPageSpans[j].innerHTML;
}
}
return rv;
};
};
WordListItem.mouseOver = (function (event, wl) {
var div = this;
wl.AddClassToGroup(div,
WordListItem.ClassNameStringHover, WordListItem.ClassNameString);
});
WordListItem.mouseOut = (function (event, wl) {
var div = this;
wl.AddClassToGroup(div,
WordListItem.ClassNameString, WordListItem.ClassNameStringHover);
});
WordListItem.clickHandler = (function(event, wl) {
var div = this;
var entry = { wl_item: wl, span: div };
var headerText = wl.getGroupHtml(div);
WordListPanel.processClick(entry, headerText);
});

// FILE: wl_panel.js (d84d3da0) 7/23/2014 4:30:37 PM

function WordListPanel() {
}
WordListPanel.queryName = "key";
WordListPanel.bankKeyHdr = "bankKey";
WordListPanel.itemKeyHdr = "itemKey";
WordListPanel.indexHdr = "index";
WordListPanel.AccType = "Word List";
WordListPanel.AccNoAccs = "TDS_WL0";
WordListPanel.AccHdr = "TDS_ACCS";
WordListPanel.divId = "WordListTool";
WordListPanel.toolDiv = null;
WordListPanel.panel = null;
WordListPanel.tabView = null;
WordListPanel.tabCount = 0;
WordListPanel.tabCurrent = 0;
WordListPanel.requestQ = [];
WordListPanel.indices = '';
WordListPanel.LoadingPageString = "<div id=\"word-list-list-div\" class=\"yui-navset\">\r\n<ul class=\"yui-nav\"> " +
"<li class=\"selected\"><a href=\"#word-list-tab1\"><em>Loading</em></a></li></ul>\r\n" +
"   <div class=\"yui-content\"> " +
"<div id=\"word-list-tab1\"><p>Please Wait</p></div> </div> ";
WordListPanel.ErrorPageString = "<div id=\"word-list-list-div\" class=\"yui-navset\">\r\n<ul class=\"yui-nav\"> " +
"<li class=\"selected\"><a href=\"#word-list-tab1\"><em>Information</em></a></li></ul>\r\n" +
"   <div class=\"yui-content\"> " +
"<div id=\"word-list-tab1\"><p>Content Not Found.</p></div> </div> ";
WordListPanel.xhrUrl = "Pages/API/WordList.axd";
WordListPanel.xhrMethod = "resolve";
WordListPanel.tabbedDivName = "word-list-list-div";
WordListPanel.splitter = new RegExp("(\\d+):(\\w+)");
WordListPanel.contentWordCache = [];
WordListPanel.headerWordCache = [];
WordListPanel.message = [];
WordListPanel.failedRequest = [];
WordListPanel.getKeyFromQEntry = function(entry) {
var keyIndex = YUD.getAttribute(entry.span, WordListItem.attributeName);
var bankKey = entry.wl_item.wl_res.bankKey;
var itemKey = entry.wl_item.wl_res.itemKey;
return bankKey + '-' + itemKey + '-' + keyIndex;
};
WordListPanel.postCallback = {
success: (function (resp) {
var messages = YAHOO.lang.JSON.parse(resp.responseText);
for (var i = 0; messages != null && i < messages.length; ++i) {
var tabString = WordListPanel.RenderHtmlTabs(messages[i]);
var key = messages[i].EntryKey;
var itemKey = key.split('-')[1];
WordListPanel.contentWordCache[key] = tabString;
WordListPanel.message[key] = messages[i];
}
if (WordListPanel.requestQ[itemKey] == null) {
console.log("word list: server returned empty response, returning.");
return;
}
for (i = 0; i < WordListPanel.requestQ[itemKey].length; ++i) {
var entry = WordListPanel.requestQ[itemKey][i];
var cacheEntry = WordListPanel.message[entry.key];
if (cacheEntry && cacheEntry.EntryFound) {
entry.wl_item.TagSingleSpan(entry.span);
}
}
}),
argument: []
};
WordListPanel.processClick = (function (entry, headerText) {
if (entry != null) {
if ((WordListPanel.panel != null) && (WordListPanel.toolDiv != null)) {
var cacheKey = WordListPanel.getKeyFromQEntry(entry);
if (WordListPanel.contentWordCache[cacheKey] != null) {
WordListPanel.headerWordCache[cacheKey] = headerText;
WordListPanel.setPanel(WordListPanel.headerWordCache[cacheKey], WordListPanel.contentWordCache[cacheKey]);
} else {
ContentManager.log("WordList: errantly tagged span");
}
}
}
});
WordListPanel.sendRequest = (function (wl_item) {
var bankKey = wl_item.wl_res.bankKey;
var itemKey = wl_item.wl_res.itemKey;
if (typeof(WordListPanel.indices) != "string" || WordListPanel.indices.length < 1)
return;
var str = WordListPanel.bankKeyHdr + "=" + bankKey.toString();
str = str + "&" + WordListPanel.itemKeyHdr + "=" + itemKey.toString();
str = str + "&" + WordListPanel.indices;
var wlCodes = Accommodations.Manager.getCurrent().getType(WordListPanel.AccType).getCodes(true);
for (var i = 0, ii = wlCodes.length; i < ii; i++) {
var wlInner = wlCodes[i].split('&');
for (var j = 0; j < wlInner.length; ++j) {
str += "&" + WordListPanel.AccHdr + "=" + wlInner[j];
}
}
var urlString = TDS.baseUrl + WordListPanel.xhrUrl + "/" + WordListPanel.xhrMethod;
if (/^http/.test(WordListPanel.xhrUrl))
urlString = WordListPanel.xhrUrl + "/" + WordListPanel.xhrMethod;
YAHOO.util.Connect.asyncRequest('POST', urlString, WordListPanel.postCallback, str);
});
WordListPanel.IsWordListEnabled = (function () {
var atype = Accommodations.Manager.getCurrent().getType(WordListPanel.AccType);
if ((atype == null) || (atype.getValues().length == 0))
return false;
for (var i = 0; i < atype.getValues().length; ++i) {
var codes = atype.getValues()[i].getCodes();
for (var j = 0; j < codes.length; ++j) {
if (codes[j] == WordListPanel.AccNoAccs) {
return false;
}
}
}
return true;
});
WordListPanel.setPanel = function (hd, bd) {
if ((WordListPanel.panel != null) && (WordListPanel.toolDiv != null)) {
if (hd != null) {
WordListPanel.panel.setHeader(hd);
}
WordListPanel.panel.setBody(bd);
WordListPanel.panel.show();
WordListPanel.tabView = new YAHOO.widget.TabView(WordListPanel.tabbedDivName);
WordListPanel.tabCount = 0;
while (WordListPanel.tabView.getTab(WordListPanel.tabCount) != null) {
WordListPanel.tabCount++;
}
WordListPanel.tabCurrent = 0;
setTimeout(function () {
WordListPanel.postProcessAudioTags();
}.bind(this), 1);
}
};
WordListPanel.InitializePane = (function () {
YAHOO.widget.Tab.prototype.ACTIVE_TITLE = '';
var toolDiv = document.getElementById("tools");
if (toolDiv != null) {
WordListPanel.toolDiv = document.createElement("div");
YUD.addClass(WordListPanel.toolDiv, "yui-dialog focused");
YUD.setAttribute(WordListPanel.toolDiv, 'id', WordListPanel.divId);
var clink = document.createElement("link");
YUD.setAttribute(clink, 'type', 'text/css');
YUD.setAttribute(clink, 'rel', 'stylesheet');
YUD.setAttribute(clink, 'media', 'screen');
YUD.setAttribute(clink, 'href', ContentManager.resolveBaseUrl('Scripts/Libraries/YUI/tabview/assets/skins/sam/tabview.css'));
WordListPanel.toolDiv.appendChild(clink);
toolDiv.appendChild(WordListPanel.toolDiv);
WordListPanel.panel = new YAHOO.widget.Panel("wordListPanel", { width: "320px", zindex: 1004, visible:false, constraintoviewport: true });
WordListPanel.panel.render(WordListPanel.toolDiv);
}
});
WordListPanel.RenderHtmlTabs = function (messages) {
var tabString = "<div id=\"" + WordListPanel.tabbedDivName + "\" class=\"yui-navset\"> \r\n";
tabString = tabString + "<ul class=\"yui-nav\">\r\n";
var contentString = " <div class=\"yui-content\">\r\n";
var i;
for (i = 0; i < messages.Entries.length; ++i) {
tabString = tabString + "<li";
if (i == 0) {
tabString = tabString + " class=\"selected\"";
}
tabString = tabString + "> <a href=\"#word-list-" + i.toString();
var wlTypeTranslation = Messages.get('TDS.WordList.' + messages.Entries[i].wlType);
tabString = tabString + "\">" + wlTypeTranslation + "</a></li>\r\n";
contentString = contentString + "<div id=\"word-list-" + i.toString() + "\"><p>" + messages.Entries[i].wlContent + "</p></div>";
}
tabString = tabString + "</ul>";
tabString = tabString + contentString + "</div>";
return tabString;
};
WordListPanel.postProcessAudioTags = function () {
if (!window.TDS || !window.TDS.Audio || !window.TDS.Audio.Widget) { return; }
var bd = WordListPanel.panel.body;
try {
if (!bd) { return; }
var audioEls = YAHOO.util.Selector.query('a', bd) || [];
for (var i = 0; i < audioEls.length; ++i) {
var span = audioEls[i];
if ((span) && (span.href)) {
var href = span.href;
if (href.indexOf('.ogg') != -1 || (href.indexOf('.m4a') != -1)) {
YUD.addClass(span, 'sound_repeat');
href = href.replace(/&amp;/gmi, '&');
span.href = href;
TDS.Audio.Widget.createPlayer(span);
}
}
}
} catch (e) {
console.error("Error creating players in the word list panel (error, dom).", e, bd);
}
};

// FILE: wl_retag.js (e570cfb3) 3/7/2014 11:24:14 AM

function Retagger(astartElement) {
var endSibling = null;
var _startElement = astartElement;
this.Retag = function () {
debugLog(0, _startElement, "Retagging entry")
RetagSiblings(astartElement, false, 0);
};
var consumeInners = function (startElement, innerElements, level) {
if ((startElement == null) ||
(innerElements.length == 0)) {
return;
}
debugLog(level, startElement, "consumeInners: make sibs children of ");
for (var i = 0; i < innerElements.length; ++i) {
var newNode = innerElements[i].cloneNode(true);
debugLog(level, newNode, "consumeInners: adding child ");
startElement.appendChild(newNode);
innerElements[i].parentNode.removeChild(innerElements[i]);
}
};
var doesChildContainEnd = function (startElement,peerElement) {
var child = YUD.getFirstChild(peerElement);
if (child == null)
return false;
while (child) {
if (isEndElement(startElement, child)) {
return true;
}
if (doesChildContainEnd(startElement, child)) {
return true;
}
child = child.nextSibling;
}
return false;
};
var debugLog = function (level, obj, str) {
if (Retagger.verboseDebug) {
var props = ["outerHTML", "nodeType", "nodeName", "nodeValue"];
var op = "";
if ((typeof(obj) == "object") && (obj != null)) {
for (var i = 0; i < props.length; ++i) {
var pp = props[i];
if ((obj[pp] != undefined) && (obj[pp] != null)) {
op = op + " " + pp + ":" + obj[pp];
}
}
}
if (str != null) {
op = str + ":" + op;
}
console.log("lvl: " + level + " " + op);
}
};
var isEndElement = function (startElement, endElementTest) {
if ((YUD.getAttribute(endElementTest,"data-tag-boundary") == "end") &&
(YUD.getAttribute(endElementTest,"data-tag-ref") == YUD.getAttribute(startElement,"id"))) {
return true;
}
return false;
};
var RetagSiblings = function (startElement, endFound, level) {
var isParentElement = false;
var innerElements = [];
if (startElement == null)
return;
var sib = startElement.nextSibling;
while (sib != null) {
debugLog(level, sib, "Iterating");
if (isEndElement(startElement,sib)) {
debugLog(level, sib, "Found end span in sib");
endSibling = sib;
break;
}
if ((level >= 0) && (doesChildContainEnd(startElement,sib))) {
debugLog(level, sib, "Found end span in child");
isParentElement = true;
endSibling = sib;
break;
}
debugLog(level, sib, "Sib neither child nor parent, pushing");
innerElements.push(sib);
sib = sib.nextSibling;
}
if (endSibling != null) {
if (isParentElement) {
var newStartElem = startElement.cloneNode(false);
var child = endSibling.firstChild;
endSibling.insertBefore(newStartElem, child);
debugLog(level, newStartElem, "recursively calling retag on child");
RetagSiblings(newStartElem, true, level + 1);
}
consumeInners(startElement, innerElements, level);
if (!isParentElement) {
debugLog(level, endSibling, "End tag found at this level, removing.");
endSibling.parentNode.removeChild(endSibling);
}
}
else if (endFound == false) {
consumeInners(startElement, innerElements, level);
sib = startElement.parentNode;
if ((sib == null) || (sib.parentNode == null) ||
((sib.nodeName != undefined && (sib.nodeName == 'FORM') ||
(sib.nodeName == 'BODY'))
)
){
debugLog(level, sib, " endtag not found");
return;
}
newStartElem = startElement.cloneNode(false);
sib.parentNode.insertBefore(newStartElem,sib.nextSibling);
debugLog(level, sib, "End tag not found, looking in sibling of parent");
RetagSiblings(newStartElem, false, level - 1);
}
};
}
Retagger.verboseDebug = false;

// FILE: module_wordlist.js (61e8a0c5) 5/2/2014 12:55:57 PM

(function(CM) {
function processEntity(page, entity) {
if (WordListPanel.IsWordListEnabled() == false) {
return;
}
var wordListResource = entity.getResource('wordList');
if (wordListResource == null) {
return;
}
var inst = new WordListItem();
inst.wl_res = wordListResource;
entity.wordList = inst;
var elements = entity.getElement();
inst.TagSpans(elements);
if (WordListPanel.toolDiv == null) {
WordListPanel.InitializePane();
}
}
CM.onPassageEvent('available', processEntity);
CM.onItemEvent('available', processEntity);
CM.onEntityEvent('keyevent', function (page, entity, evt) {
var inst = entity.wordList;
if (inst) {
if (inst.HandleKey(evt)) {
YUE.stopEvent(evt);
}
}
});
CM.onEntityEvent('hide', function (page, entity) {
if (WordListPanel && WordListPanel.panel) {
WordListPanel.panel.hide();
}
});
})(ContentManager);

// FILE: module_attachment.js (f5478686) 3/7/2014 11:24:06 AM

ContentManager.onPageEvent('available', function(page)
{
var pageDoc = page.getDoc();
var pageWin = page.getWin();
var pageLinks = pageDoc.getElementsByTagName('a');
for (var i = 0; i < pageLinks.length; i++)
{
var pageLink = pageLinks[i];
if (pageLink.href.toLowerCase().indexOf('.pdf') != -1  ||
pageLink.href.toLowerCase().indexOf('.rtf') != -1)
{
pageLink.target = '_blank';
}
}
});

// FILE: module_plaintext.js (20b7d64f) 3/7/2014 11:24:06 AM

ContentManager.onItemEvent('focus', function(page, item)
{
if (!item.isResponseType('plaintext')) return;
var doc = page.getDoc();
var textArea = doc.getElementById('Item_Response_' + item.position);
if (!Util.Browser.isTouchDevice()) {
ContentManager.focus(textArea);
}
});
ContentManager.onItemEvent('blur', function(page, item)
{
if (!item.isResponseType('plaintext')) return;
var doc = page.getDoc();
var textArea = doc.getElementById('Item_Response_' + item.position);
textArea.blur();
});
ContentManager.onItemEvent('available', function(page, item)
{
if (!item.isResponseType('plaintext')) return;
var doc = page.getDoc();
var textArea = doc.getElementById('Item_Response_' + item.position);
if ((textArea) && (ContentManager.isAccessibilityEnabled())) {
textArea.setAttribute('tabindex', '0');
}
var tabFunc = function(type, args)
{
var event = args[1];
var oS = textArea.scrollTop;
var sS = textArea.selectionStart;
var sE = textArea.selectionEnd;
textArea.value = textArea.value.substring(0, sS) + '\t' + textArea.value.substr(sE);
textArea.setSelectionRange(sS + 1, sS + 1);
ContentManager.focus(textArea);
textArea.scrollTop = oS;
YUE.stopEvent(event);
};
ContentManager.setReadOnlyKeyEvent(item, textArea);
});
(function()
{
var getter = function(item, response)
{
var pageDoc = item.getPage().getDoc();
var textArea = pageDoc.getElementById('Item_Response_' + item.position);
response.value = textArea.value;
response.isValid = (response.value.length > 0);
response.isSelected = response.isValid;
if (response.value)
{
response.value = response.value.replace(/]]>/g, ']]&gt;');
}
};
var setter = function(item, value)
{
var pageDoc = item.getPage().getDoc();
var textArea = pageDoc.getElementById('Item_Response_' + item.position);
textArea.value = value;
};
ContentManager.registerResponseHandler('plaintext', getter, setter);
})();

// FILE: module_wordbuilder.js (40f33bd8) 3/7/2014 11:24:06 AM

function KeyboardWidget(keyboardDiv, textfield) {
this._keyboard = keyboardDiv;
this._textfield = textfield;
this._keyLinkToValueMap = new Object();
this._allowedKeyCodesMap = new Object();
this._allowedCharCodesMap = new Object();
this._allowedKeyCodesMap['8']="OK";
this._allowedKeyCodesMap['9']="OK";
this._allowedKeyCodesMap['46']="OK";
this._allowedKeyCodesMap['37']="OK";
this._allowedKeyCodesMap['38']="OK";
this._allowedKeyCodesMap['39']="OK";
this._allowedKeyCodesMap['40']="OK";
this.activate = function()
{
if (!this._textfield) this._textfield = this._getAssociatedTextField();
var keyContainers = this._keyboard.getElementsByTagName('li');
for (var i = 0; i < keyContainers.length; i++) {
var keyValue = this._getText(YAHOO.util.Dom.getElementsByClassName('keyvalue', 'span', keyContainers[i])[0]);
var keyLink = keyContainers[i].getElementsByTagName('a')[0];
var keyDisplay = this._getText(keyLink);
var success = YAHOO.util.Event.addListener(keyLink, 'click', this._keyboardClick, null, this);
this._keyLinkToValueMap[keyLink.id] = keyValue;
if (keyDisplay.length == 1) {
this._allowedCharCodesMap[keyDisplay.toUpperCase().charCodeAt()+'']="OK";
this._allowedCharCodesMap[keyDisplay.toLowerCase().charCodeAt()+'']="OK";
}
if (keyDisplay.toLowerCase() == 'space') {
this._allowedCharCodesMap['32']="OK";
this._allowedKeyCodesMap['32']="OK";
}
}
YAHOO.util.Event.addListener(this._textfield, 'keypress', this._keyboardClick2, this, true);
};
this._getAssociatedTextField = function() {
var containerDiv = YAHOO.util.Dom.getAncestorByClassName(this._keyboard, 'multipleChoiceItem');
var textfields = YAHOO.util.Dom.getElementsByClassName('inputCloze', 'input', containerDiv);
return textfields[0];
};
this._simulate_key = function(type, ctrlKey, altKey, shiftKey, keyCode, charCode) {
var textFieldValueBeforeKeyPress = this._textfield.value;
try {
YAHOO.util.UserAction.simulateKeyEvent(this._textfield, type, true, true, null, ctrlKey, altKey, shiftKey, false, keyCode, charCode);
} catch (ex) {
return false;
}
return (this._textfield.value != textFieldValueBeforeKeyPress);
};
this._keyboardClick = function(event)
{
YAHOO.util.Event.stopEvent(event);
var linkClicked = YAHOO.util.Event.getTarget(event);
var value = this._keyLinkToValueMap[linkClicked.id];
if (ContentManager.isReadOnly()) return;
if (value.toLowerCase() == "delete")
{
if (!this._simulate_key('keypress', false, false, false, 8, 0))
{
this._deleteFromTextField();
}
}
else
{
if (parseInt(this._textfield.maxLength) == 1) {
this._textfield.value = "";
}
if (!this._simulate_key('keypress', false, false, false, null, value.charCodeAt()))
{
this._appendToTextField(value);
}
}
};
this._keyboardClick2 = function(key) {
var charCode = key.charCode;
if (!charCode || charCode == 0) {
charCode = String.fromCharCode(key.keyCode).charCodeAt();
}
if (key.ctrlKey
|| this._allowedCharCodesMap[charCode + '']
|| (key.charCode == 0 && this._allowedKeyCodesMap[key.keyCode + '']))
{
return true;
}
if ((!key.shiftKey && key.keyCode == 190)                                   || (key.keyCode == 110 && charCode == 46)                  ) {
if (this._allowedKeyCodesMap['46']) {
return true;
}
}
YAHOO.util.Event.stopEvent(key);
return false;
};
this._appendToTextField = function(valueToInsert) {
if (valueToInsert) {
var cursorPosition = this._getCursorPosition();
if ((parseInt(this._textfield.maxLength) != -1) && (this._textfield.value.length >= parseInt(this._textfield.maxLength))) {
this._textfield.value = this._textfield.value.substr(0, this._textfield.value.length - 1) + valueToInsert;
this._setCursorPosition(this._textfield.value.length);
} else {
this._textfield.value = this._textfield.value.substr(0, cursorPosition)
+ valueToInsert
+ this._textfield.value.substr(cursorPosition, this._textfield.value.length);
if(cursorPosition == this._textfield.value.length-1)
{
this._setCursorPosition(this._textfield.value.length);
} else
{
this._setCursorPosition(cursorPosition+1);
}
}
}
ContentManager.focus(this._textfield);
};
this._deleteFromTextField = function() {
if (this._textfield.value.length > 0) {
var cursorPosition = this._getCursorPosition();
this._textfield.value = this._textfield.value.substr(0, cursorPosition-1) + this._textfield.value.substr(cursorPosition, this._textfield.value.length);
if(cursorPosition-1 < this._textfield.value.length)
{
this._setCursorPosition(cursorPosition-1);
}
}
ContentManager.focus(this._textfield);
};
this._getText = function(element) {
if (element.text) {
return element.text;
} else if (element.innerText) {
return element.innerText;
}
return element.innerHTML;
};
this._getCursorPosition = function() {
var CaretPos = 0;
if (document.selection) {
this._textfield.focus ();
var Sel = document.selection.createRange ();
var SelLength = document.selection.createRange().text.length;
Sel.moveStart ('character', -this._textfield.value.length);
CaretPos = Sel.text.length - SelLength;
}
else if (this._textfield.selectionStart || this._textfield.selectionStart == '0')
{
CaretPos = this._textfield.selectionStart;
}
return (CaretPos);
};
this._setCursorPosition = function(pos)
{
ContentManager.focus(this._textfield);
if (this._textfield.setSelectionRange) {
this._textfield.setSelectionRange(pos, pos);
}
else if (this._textfield.createTextRange) {
var range = this._textfield.createTextRange();
range.collapse(true);
range.moveEnd('character', pos);
range.moveStart('character', pos);
range.select();
}
};
}
ContentManager.onItemEvent('available', function(page, item)
{
if (!item.isResponseType('keyboard custom') && !item.isResponseType('keyboard alphabetical')) return;
var pageDoc = page.getDoc();
var keyboardDiv = pageDoc.getElementById('keyboard_' + item.position);
var textKeyboard = pageDoc.forms['contentForm']['textbox1_item_' + item.itemKey];
if (keyboardDiv == null || textKeyboard == null) return;
var keyboardControl = new KeyboardWidget(keyboardDiv, textKeyboard);
keyboardControl.activate();
ContentManager.setReadOnlyKeyEvent(item, textKeyboard);
if (item.value != null) textKeyboard.value = item.value;
var ariaTag = textKeyboard.getAttribute('data-desc');
if (ariaTag) {
textKeyboard.removeAttribute('data-desc');
textKeyboard.setAttribute('aria-label', ariaTag);
}
});
ContentManager.onItemEvent('focus', function(page, item)
{
if (!item.isResponseType('keyboard custom') && !item.isResponseType('keyboard alphabetical')) return;
var pageDoc = page.getDoc();
var textKeyboard = pageDoc.forms['contentForm']['textbox1_item_' + item.itemKey];
ContentManager.focus(textKeyboard);
});
(function()
{
var getter = function(item, response)
{
var pageDoc = item.getPage().getDoc();
var textKeyboard = pageDoc.forms['contentForm']['textbox1_item_' + item.itemKey];
if (textKeyboard) {
response.value = textKeyboard.value;
response.isSelected = (response.value.length > 0) ? true : false;
response.isValid = response.isSelected;
} else {
response.value = null;
response.isSelected = false;
response.isValid = false;
}
};
var setter = function(item, value)
{
var pageDoc = item.getPage().getDoc();
var textKeyboard = pageDoc.forms['contentForm']['textbox1_item_' + item.itemKey];
if (textKeyboard) {
textKeyboard.value = value;
}
};
ContentManager.registerResponseHandler('keyboard alphabetical', getter, setter);
ContentManager.registerResponseHandler('keyboard custom', getter, setter);
})();

// FILE: module_menu.js (dbd1102b) 3/7/2014 11:24:06 AM

ContentManager.onEntityEvent('menushow', function(page, entity, menu, evt)
{
if (!evt.keyCode) return false;
var isPassage = (entity instanceof ContentPassage);
var isStem = (entity instanceof ContentItem) && (entity.getStemElement() == entity.getActiveComponent());
if (!isPassage && !isStem) return false;
var allowedAccommodation = false;
var accProps = page.getAccommodationProperties();
if (accProps.hasHighlighting()) allowedAccommodation = true;
else if (isPassage && accProps.hasTTSStimulus()) allowedAccommodation = true;
else if (isStem && accProps.hasTTSItem()) allowedAccommodation = true;
if (!allowedAccommodation) return false;
if (!Mozilla.execPrivileged()) return;
if (Mozilla.inCaretMode())
{
var menuFunc = function()
{
ContentManager.enableCaretMode(false);
};
var menuItem =
{
text: Messages.get('TDSContentEventsJS.Link.DisableTextSelection'),
classname: 'caretMode',
onclick: { fn: menuFunc }
};
menu.addMenuItem('entity', menuItem);
}
else
{
var menuFunc = function()
{
var focusedComponent = entity.getActiveComponent();
if (focusedComponent && focusedComponent.focus)
{
entity.clearComponent();
entity.setActiveComponent(focusedComponent);
ContentManager.enableCaretMode(true);
}
};
var menuItem =
{
text: Messages.get('TDSContentEventsJS.Link.EnableTextSelection'),
classname: 'caretMode',
onclick: { fn: menuFunc }
};
menu.addMenuItem('entity', menuItem);
}
});
ContentManager.onPassageEvent('menushow', function(page, passage, menu, evt)
{
var addMenu = function(messageKey, menuClass, menuFunc)
{
var menuItem = {
text: Messages.get(messageKey),
classname: menuClass,
onclick: { fn: menuFunc }
};
menu.addMenuItem('entity', menuItem);
};
if (typeof (tdsPassagePrint) != 'function') return;
if (YUD.hasClass(document.body, 'unproctored')) return;
if (!ContentManager.isVisible('btnPrint')) return;
addMenu('TDSContentEventsJS.Label.PrintPassage', 'printPassage', function()
{
tdsPassagePrint();
});
});
ContentManager.onItemEvent('menushow', function(page, item, menu, evt)
{
var activeComp = item.getActiveComponent();
var isEbsrPrompt = function () {
if (!item.EBSR) {
return false;
}
var prompts = item.EBSR.getPrompts();
if (prompts.indexOf(activeComp) < 0) {
return false;
} else {
return true;
}
};
var isActiveStem = activeComp == item.getStemElement();
if (item == null || (!isActiveStem && !isEbsrPrompt())) {
return;
}
var addMenu = function(messageKey, menuClass, menuFunc)
{
var menuItem = {
text: Messages.get(messageKey),
classname: menuClass,
onclick: { fn: menuFunc }
};
menu.addMenuItem('entity', menuItem);
};
if (item.hasMarkLink())
{
var messageKey = item.isMarked() ? 'TDSContentEventsJS.Label.UnmarkForReview' : 'TDSContentEventsJS.Label.MarkForReview';
addMenu(messageKey, 'markReview', function()
{
item.toggleMark();
});
}
if (item.hasCommentLink())
{
var messageLabel = ContentManager.getCommentLabel();
addMenu(messageLabel, 'comment', function()
{
item.toggleComment();
});
}
if (item.hasPrintLink())
{
addMenu('TDSContentEventsJS.Label.PrintItem', 'printItem', function()
{
item.print();
});
}
if (item.hasGTRLink())
{
var menuName = Messages.getAlt('TDSContentEventsJS.Label.GTRItem', 'Guide to Revision');
addMenu(menuName, 'gtrItem', function()
{
item.openGTR();
});
}
if (item.hasHelpLink())
{
addMenu('TDSContentEventsJS.Label.HelpItem', 'helpItem', function()
{
item.openHelp();
});
}
if(TDS.LineReaderControl){
TDS.LineReaderControl.off();
}
});

// FILE: module_highlighter.js (f498460e) 7/23/2014 4:30:36 PM

(function(rangy) {
if (!rangy) return;
if(rangy.config){
rangy.config.alertOnFail = false;
rangy.config.alertOnWarn = false;
}
var globalClassApplier;
function getSelfOrAncestorWithClass(node, cssClass) {
while (node) {
if (YUD.hasClass(node, cssClass)) {
return node;
}
node = node.parentNode;
}
return null;
};
function checkMathML(node) {
var mathTypes = /mfrac|msup|mfenced|msqrt|msubsup|msub|mover|munder|msubsup|mlongdiv|munderover|mroot/;
if (mathTypes.test(node)) {
return true;
}
return false;
};
function createCSSClassApplier() {
var cssClassApplier = rangy.createCssClassApplier('highlight', {
ignoreWhiteSpace: true,
useExistingElements: false,
removeEmptyElements: false,
tagNames: ['span']
});
cssClassApplier.isModifiable = function(textNode) {
if (getSelfOrAncestorWithClass(textNode.parentNode, 'no-highlight') != null || checkMathML(textNode.parentNode.nodeName)){
return false;
}
return true;
};
return cssClassApplier;
}
function getCSSClassApplier() {
if (!globalClassApplier) {
globalClassApplier = createCSSClassApplier();
}
return globalClassApplier;
}
function setHighlight(selection) {
if (selection.rangeCount > 0) {
var cssClassApplier = getCSSClassApplier();
cssClassApplier.applyToRanges(selection.getAllRanges());
selection.collapseToStart();
}
}
function clearHighlighting(el) {
var range = rangy.createRange();
range.selectNode(el);
var cssClassApplier = getCSSClassApplier();
cssClassApplier.undoToRange(range);
}
function hasSelection(selection) {
var text = selection.toString();
text = YAHOO.lang.trim(text);
return (text.length > 0);
}
function onMenuShow(page, entity, menu, evt, selection) {
var accProps = page.getAccommodationProperties();
if (!accProps.hasHighlighting()) return;
var hasSelectedText = hasSelection(selection);
if (hasSelectedText) {
var lblHighlightText = ContentManager.getLabel('HIGHLIGHT_TEXT');
menu.addMenuItem('entity', lblHighlightText, function() {
setHighlight(selection);
ContentManager.enableCaretMode(false);
});
}
var activeDoc = page.getActiveDoc();
var highlightedElement = entity.getElement();
if (highlightedElement && highlightedElement.ownerDocument != activeDoc) {
highlightedElement = activeDoc.body;
}
var highlightedNodes = YAHOO.util.Dom.getElementsByClassName(ContentManager.CSS.HIGHLIGHT, null, highlightedElement);
var hasHighlightedText = (highlightedNodes.length > 0);
if (hasHighlightedText) {
var lblHighlightClr = ContentManager.getLabel('HIGHLIGHT_CLEAR');
menu.addMenuItem('entity', lblHighlightClr, function() {
clearHighlighting(highlightedElement);
}, !hasHighlightedText);
}
}
ContentManager.onEntityEvent('menushow', onMenuShow);
})(window.rangy);

// FILE: module_tts.js (825d23d7) 5/2/2014 12:55:57 PM

(function(){
TTS.MenuSystem = {
Last: null,
addMenuSetup: function(menu, playCfg){
try{
if(!menu || !playCfg || !playCfg.ORDER){
return;
}
TTS.MenuSystem.Last = playCfg;
var order = playCfg.ORDER;
for(var i=0; i<order.length; ++i){
var entryName = order[i];
var entry = playCfg[entryName];
if(entry && (typeof entry.cb == 'function' || entry.allowDisabled)){
menu.addMenuItem(entry.level || 'entity', {
text: Messages.get(entry.Label || 'TTS'),
onclick: {fn: entry.cb},
disabled:  typeof entry.cb == 'function' ? false : entry.allowDisabled,
classname: entry.css || 'speaksection'
});
}
}
}catch(e){
console.error("Failed to create menu item.", e);
}
}
};
TTS.Config.isTrackingEnabled = function () {
return window.ContentManager != null && window.ContentManager.getAccommodationProperties().isTTSTrackingEnabled();
};
YAHOO.util.Event.onDOMReady(function () {
setTimeout(function () {
TTS.getInstance();
}, 500);
});
ContentManager.onPassageEvent('menushow', function(page, passage, menu, evt, selection){
if (!TTS.Manager.isAvailable()) return;
var accProps = page.getAccommodationProperties();
if (!accProps.hasTTSStimulus()) return;
if (TDS.Audio.isActive()) return;
var languages  = ContentManager.getLanguage() != 'ENU' ? ['ESN', 'ENU'] : ['ENU'];
var ttsMenu    = new TTS.Menu(languages);
var menuCfg = ttsMenu.getMenuCfg(
passage.getElement(),
selection,
page.getActiveWin(),
passage.stemTTS,
page,
passage
);
TTS.Config.Debug && console.log("Passage menu show.", menuCfg);
TTS.MenuSystem.addMenuSetup(menu, menuCfg);
});
ContentManager.onItemEvent('menushow', function(page, item, menu, evt, selection){
var ctrl = TTS.getInstance();
if (!ctrl.isAvailable()) return;
var accProps = page.getAccommodationProperties();
if (!accProps.hasTTSItem()) return;
if (TDS.Audio.isActive()) return;
if (item.EBSR) return;
if (item.getActiveComponent() != item.getStemElement() &&
item.getActiveComponent() != item.getIllustrationElement() && !item.MC){
return;
}
var pageWin    = page.getActiveWin();
var languages  = ContentManager.getLanguage() != 'ENU' ? ['ESN', 'ENU'] : ['ENU'];
var domToParse = [];
var stem = item.getStemElement();
if(stem){
domToParse.push(stem);
}
var illustration = item.getIllustrationElement();
if(illustration){
domToParse.push(illustration);
}
var ttsMenu    = new TTS.Menu(languages);
var menuCfg   = ttsMenu.getMenuCfg(domToParse, selection, pageWin, item.stemTTS, page, item);
if (item.MC){
var optionGroup = item.MC;
if (TTS.version < 2.0) {
for (var i = 0; i < optionGroup.getOptions().length; ++i){
domToParse.push((optionGroup.getOptions())[i].getElement());
}
ttsMenu.addOptions(menuCfg, domToParse);
}
var focusedOption = optionGroup.getFocusedOption();
if (focusedOption && focusedOption.key){
menuCfg.SEL_PRI = false;
menuCfg.SEL_SEC = false;
menuCfg.PRI.level    = 'component';
menuCfg.SEC.level    = 'component';
menuCfg.STOP.level   = 'component';
menuCfg.PAUSE.level  = 'component';
menuCfg.RESUME.level = 'component';
ttsMenu.addFocusedOption(menuCfg, item.getActiveComponent());
}
}
TTS.MenuSystem.addMenuSetup(menu, menuCfg);
TTS.Config.Debug && console.log("TTS On Item Menushow config", menuCfg);
});
function ttsNotSpeaking () {
var ttsInstance = TTS.getInstance();
if (ttsInstance && ttsInstance.isPlaying()) {
return false;
} else {
return true;
}
}
TDS.Audio.Player.onBeforePlay.subscribe(function() {
return ttsNotSpeaking();
});
TDS.Audio.Player.onBeforeResume.subscribe(function () {
return ttsNotSpeaking();
});
ContentManager.onPageEvent('hide', function(page){
TTS.getInstance().stop();
});
})();

// FILE: module_audioplayer.js (efcc050c) 5/2/2014 12:55:57 PM

(function (Audio) {
var Player = Audio.Player;
var Recorder = Audio.Recorder;
var Widget = Audio.Widget;
function onItemAudioAvailable(page, item) {
var itemEl = item.getElement();
if (itemEl == null) {
return;
}
YUD.batch(itemEl.getElementsByTagName('a'), function (linkEl) {
if (!YUD.hasClass(linkEl, 'sound_explicit') &&
!YUD.hasClass(linkEl, 'sound_repeat') &&
!YUD.hasClass(linkEl, 'sound_cue')) {
return;
}
if (YUD.hasClass(linkEl, 'sound_explicit')) {
YUD.addClass(linkEl, 'sound_repeat');
}
ContentManager.preventFocus(linkEl);
var audioID;
var accProps = page.getAccommodationProperties();
if (accProps && accProps.isAudioRewindEnabled()) {
audioID = Widget.createPlayerRewind(linkEl);
} else {
audioID = Widget.createPlayer(linkEl);
}
if (audioID) {
item.audioLinks.push(audioID);
if (!ContentManager.isAccessibilityEnabled()) {
var autoplay = YUD.getAttribute(linkEl, 'autoplay');
autoplay = (autoplay) ? (autoplay.toLowerCase() == 'true') : false;
if (autoplay) {
page.autoPlayQueue.append(audioID);
}
}
} else {
YUD.addClass(linkEl, 'disabled');
}
});
}
function onItemAudioContextMenuPlayer(page, item, menu) {
if (Recorder.isCapturing() || Recorder.isPlaying()) {
return;
}
var addPlayerLink = function (level, title, linkEl) {
if (linkEl == null) {
return;
}
var isLinkPlaying = YUD.hasClass(linkEl, 'playing_start');
if (Player.isPlaying() && !isLinkPlaying) {
return;
}
var menuLabel = (isLinkPlaying ? Messages.get('TDSAudioJS.Label.Stop') : Messages.get('TDSAudioJS.Label.Play')) + ' ' + title;
var menuFunc = function () {
if (isLinkPlaying) {
Player.stop(linkEl.id);
} else {
Player.play(linkEl.id);
}
};
var menuClass = isLinkPlaying ? 'stopquestion' : 'playquestion';
var menuItem = {
text: menuLabel,
onclick: { fn: menuFunc },
classname: menuClass
};
menu.addMenuItem(level, menuItem);
};
var addPlayerElement = function (title, el) {
if (el == null) {
return;
}
var linkEls = el.getElementsByTagName('a');
var audioCount = 0;
YUD.batch(linkEls, function (linkEl) {
if (!YUD.hasClass(linkEl, 'sound_explicit') && !YUD.hasClass(linkEl, 'sound_repeat')) {
return;
}
audioCount++;
addPlayerLink('entity', title, linkEl);
});
};
if (item.getActiveComponent() == item.getStemElement() ||
item.getActiveComponent() == item.getIllustrationElement()) {
addPlayerElement(Messages.get('TDSAudioJS.Label.AddMenuQuestion'), item.getStemElement());
addPlayerElement(Messages.get('TDSAudioJS.Label.AddMenuQuestion'), item.getIllustrationElement());
}
if (item.MC) {
var optionGroup = item.MC;
var focusedOption = optionGroup.getFocusedOption();
if (focusedOption) {
addPlayerLink('component', Messages.get('TDSAudioJS.Label.AddMenuOption') + ' ' + focusedOption.key, focusedOption.getSoundLink());
}
}
}
ContentManager.onPassageEvent('available', onItemAudioAvailable);
ContentManager.onItemEvent('available', onItemAudioAvailable);
ContentManager.onItemEvent('menushow', onItemAudioContextMenuPlayer);
ContentManager.onPageEvent('hide', function (page) {
if (Player.isPlaying()) {
Player.stopAll();
}
});
})(TDS.Audio);

// FILE: module_audiorecorder.js (22c83743) 3/7/2014 11:24:06 AM

(function(Audio) {
var Player = Audio.Player;
var Recorder = Audio.Recorder;
var Widget = Audio.Widget;
function _onItemRecorderAvailable(page, item) {
if (!item.isResponseType('microphone')) {
return;
}
if (!Recorder.isInitialized()) {
Recorder.initialize();
}
var recorderID = 'elicited_' + item.position;
var duration = (item.format.toUpperCase() == 'SER') ? 120 : 30;
Widget.createRecorder(recorderID, duration);
item.recorder = recorderID;
if (item.value && item.value.length > 0) {
Recorder.onDeviceReady.subscribeOnce(function() {
Recorder.loadBase64Audio(recorderID, item.value);
});
}
}
function _onItemAudioContextMenuRecorder(page, item, menu) {
if (!item.isResponseType('microphone')) {
return;
}
if (Player.isPlaying()) {
return;
}
var micDiv = YUD.get('elicited_' + item.position);
var id = micDiv.id;
var recorderMenuItems = [];
if (Recorder.isCapturing()) {
var menuLabel = Messages.get('TDSAudioJS.Label.StopRecording');
recorderMenuItems.push({ text: menuLabel, classname: 'stoprecording', onclick: {
fn: function() {
Recorder.stopCapture(id);
}
}});
} else {
if (Recorder.isPlaying()) {
if (YUD.hasClass(micDiv, 'playing_start')) {
var menuLabel = Messages.get('TDSAudioJS.Label.StopPlayRecording');
recorderMenuItems.push({ text: menuLabel, classname: 'stopquestion', onclick: {
fn: function() {
Recorder.stopAudio(id);
}
}});
}
} else {
var menuLabel = Messages.get('TDSAudioJS.Label.StartRecording');
recorderMenuItems.push({ text: menuLabel, classname: 'startrecording', onclick: {
fn: function() {
Recorder.startCapture(id);
}
}});
if (YUD.hasClass(micDiv, 'decode_complete') ||
YUD.hasClass(micDiv, 'recording_done') ||
YUD.hasClass(micDiv, 'playing_done') ||
YUD.hasClass(micDiv, 'playing_stopped')) {
var menuLabel = Messages.get('TDSAudioJS.Label.PlayRecording');
recorderMenuItems.push({ text: menuLabel, classname: 'playrecording', onclick: {
fn: function() {
Recorder.playAudio(id);
}
}});
}
}
}
for (var i = 0; i < recorderMenuItems.length; i++) {
menu._entity.push(recorderMenuItems[i]);
}
}
ContentManager.onItemEvent('available', _onItemRecorderAvailable);
ContentManager.onItemEvent('menushow', _onItemAudioContextMenuRecorder);
ContentManager.onPageEvent('hide', function(page) {
if (Recorder.isPlaying()) {
Recorder.stopAudio();
}
if (Recorder.isCapturing()) {
Recorder.stopCapture();
}
});
})(TDS.Audio);
(function(Recorder) {
var getter = function(item, response) {
var id = 'elicited_' + item.position;
response.isAvailable = true;
response.value = Recorder.retrieveBase64Audio(id);
if (response.value != null) {
response.isSelected = (response.value.length > 0);
response.isValid = response.isSelected;
}
return response;
};
var setter = function(item, value) {
var id = 'elicited_' + item.position;
Recorder.loadBase64Audio(id, value);
};
ContentManager.registerResponseHandler('microphone', getter, setter);
})(TDS.Audio.Recorder);

// FILE: module_video.js (e2795b33) 7/23/2014 4:30:36 PM

(function() {
ContentManager.onPageEvent('available', function(page) {
var pageWin = page.getWin();
if (typeof pageWin.jwplayer == 'function') {
VideoManager.patchJWPlayer(pageWin.jwplayer);
}
});
ContentManager.onPageEvent('available', function(page) {
var pageEl = page.getElement();
var pageWin = page.getWin();
var pageLinks = pageEl.getElementsByTagName('a');
YUD.batch(pageLinks, function(pageLink) {
var animData = VideoManager.SWF.parseData(pageLink);
if (animData.flash) {
var videoLoader = new ResourceLoader.Binary(pageLink.href, 180000, 2);
videoLoader.subscribe(ResourceLoader.Status.COMPLETE, function() {
VideoManager.SWF.embed(pageWin, pageLink);
});
page.addResourceLoader(videoLoader);
}
else if (VideoManager.canPlay(pageLink.href)) {
var videoData = VideoManager.parseData(pageLink);
if (videoData.dialog) {
YUE.on(pageLink, 'click', VideoManager.openDialog, pageLink);
} else {
VideoManager.embed(pageWin, pageLink,page.getZoomFactor());
}
}
});
});
ContentManager.onPageEvent('show', function(page) {
VideoManager.SWF.forEach(page, function(swfAPI) {
if (swfAPI.autoplay()) {
swfAPI.play();
}
});
});
ContentManager.onPageEvent('hide', function(page) {
VideoManager.stop(page);
});
ContentManager.onPageEvent('zoom', function(page) {
if (page.getWin().jwplayer) {
var players = page.getWin().jwplayer.getPlayers();
for (var i = 0; i < players.length; i++) {
var player = players[i];
if (!player.config.width) {
player.config.width = player.getWidth();
}
if (!player.config.height) {
player.config.height = player.getHeight();
}
var zoomFactor = page.getZoomFactor();
if ((player.config.width > 0) && (player.config.height > 0)) {
var zoomWidth = (player.config.width * zoomFactor);
var zoomHeight = (player.config.height * zoomFactor);
player.resize(zoomWidth, zoomHeight);
}
}
}
});
VideoManager.SWF.Events.subscribe('loaded', function(swfAPI) {
var currentPage = ContentManager.getCurrentPage();
if (currentPage == null) {
return;
}
VideoManager.SWF.forEach(currentPage, function(pageSwfAPI) {
if (swfAPI == pageSwfAPI && swfAPI.autoplay()) {
swfAPI.play();
}
});
});
ContentManager.Dialog.onLoad.subscribe(function(frame) {
var frameWin = frame.getWindow();
var frameDoc = frame.getDocument();
if (Util.String.contains(frame.id, 'help')) {
var flashLinks = YUD.getElementsByClassName('flashvideo', 'a', frameDoc);
for (var i = 0; i < flashLinks.length; i++) {
if (flashLinks[i].parentNode) {
VideoManager.SWF.embed(frameWin, flashLinks[i], true, true);
}
}
}
});
ContentManager.Dialog.onShow.subscribe(function(dialogFrame) {
var dialogDoc = Util.Dom.getFrameContentDocument(dialogFrame);
YUD.batch(dialogDoc.getElementsByTagName('embed'), function(embed) {
if (typeof embed.Play == 'function') {
embed.Play();
}
});
});
ContentManager.Dialog.onHide.subscribe(function(dialogFrame) {
var dialogDoc = Util.Dom.getFrameContentDocument(dialogFrame);
YUD.batch(dialogDoc.getElementsByTagName('embed'), function(embed) {
if (typeof embed.Rewind == 'function') {
embed.Rewind();
}
});
});
VideoManager.SWF.Events.subscribe('playing', function() {
TTS.getInstance().stop();
});
})();

// FILE: module_asl.js (7a2701b3) 7/23/2014 4:30:36 PM

ContentManager.onItemEvent('menushow', function (page, item, menu, evt) {
if (!item)
return;
var accProps = TDS.getAccommodationProperties();
if (!accProps.hasASL())
return;
var menuType = 'entity';
var optionGroup = item.MC;
var subType = 'STEM';
if (optionGroup) {
var focusedOption = optionGroup.getFocusedOption();
if (focusedOption) {
menuType = 'component';
subType = 'Option ' + focusedOption.key;
}
}
AslModule.addEntityToMenu(item, subType, menu, menuType);
});
ContentManager.onPassageEvent('menushow', function (page, item, menu, evt) {
var accProps = TDS.getAccommodationProperties();
if (!accProps.hasASL())
return;
var menuType = 'entity';
var subType = null;
AslModule.addEntityToMenu(item, subType, menu, menuType);
});
AslModule = {};
AslModule.addEntityToMenu = function (entity, subtype, menu, menuType) {
var addMenu = function(messageKey, menuClass, menuFunc) {
var menuItem = {
text: Messages.get(messageKey),
classname: menuClass,
onclick: { fn: menuFunc }
};
menu.addMenuItem(menuType, menuItem);
};
if (entity.hasAslAttachments(subtype)) {
addMenu('TDSContentEventJS.Label.ASLItem', 'ASL', function() {
var att = entity.getAslAttachments()[0];
var link = att['url'];
AslModule.showImageDialog(link,entity.getPage().getZoomFactor());
});
}
};
AslModule.showImageDialog = function(url,zoomFactor) {
var anchor = document.createElement('a');
anchor.href = url;
VideoManager.openDialog(null, anchor, zoomFactor);
};
ContentEntity.prototype.getAslAttachments = function (st) {
var rv = [];
Util.Array.each(this.attachments, function (att) {
if ((att['type']) && (att['type'] == 'ASL')) {
if ((st == null) || (st.length == 0) ||
(att['subType'] == null) || (st == att['subType']))
rv.push(att);
}
});
return rv;
};
ContentEntity.prototype.hasAslAttachments = function (st) {
return this.getAslAttachments(st).length != 0;
};

// FILE: module_pagination.js (7a3dc3ef) 5/2/2014 12:55:57 PM

(function (CM) {
var CSS_WIDGET = 'multi-page';
var CSS_ITEMACTIVE = 'page-active';
var CSS_ITEMANSWERED = 'page-answered';
var CSS_ITEMSHOW = 'page-item-show';
var CSS_ITEMHIDE = 'page-item-hidden';
var paginatedPages = [];
function getTabEl(item) {
return document.getElementById('itemTab-' + item.position);
}
function createTabEl(item) {
var itemTabEl = document.createElement('li');
itemTabEl.setAttribute('id', 'itemTab-' + item.position);
var itemLinkEl = document.createElement('a');
itemLinkEl.setAttribute('href', '#');
itemLinkEl.setAttribute('tabindex', '0');
var tabData = { item: item };
$(itemLinkEl).on('click', tabData, onTabClick);
$(itemLinkEl).text(item.position);
itemTabEl.appendChild(itemLinkEl);
return itemTabEl;
}
function createWidgetEl(items) {
var containerEl = document.createElement('ul');
containerEl.className = CSS_WIDGET;
items.forEach(function(item) {
var itemTabEl = createTabEl(item);
containerEl.appendChild(itemTabEl);
});
return containerEl;
}
function onTabClick(evt) {
var item = evt.data.item;
item.setActive();
}
function updateItemAnswered(item) {
var itemEl = item.getElement();
var tabEl = getTabEl(item);
var response = item.getResponse();
if (response && response.isValid) {
YUD.addClass(tabEl, CSS_ITEMANSWERED);
} else {
YUD.removeClass(tabEl, CSS_ITEMANSWERED);
}
}
function allowPagination(page) {
if (ContentManager.isAccessibilityEnabled()) {
return false;
}
var compoundEl = page.getCompoundElement();
if (compoundEl) {
return false;
}
var passage = page.getPassage();
var items = page.getItems();
if (passage == null || items.length < 2) {
return false;
}
var accProps = page.getAccommodationProperties();
if (accProps == null || !accProps.isPaginatedItemGroupsEnabled()) {
return false;
}
return true;
}
function isPaginated(page) {
return (paginatedPages.length > 0 &&
paginatedPages.indexOf(page) != -1);
}
function getItems(page) {
var items = page.getItems();
if (page.layout == '28' ||
page.layout == '29') {
items = items.filter(function(item) {
return item.format.toUpperCase() != 'SIM';
});
}
return items;
}
function processPage(page) {
if (!isPaginated(page)) {
paginatedPages.push(page);
}
var items = getItems(page);
if (items.length == 0) return;
var firstItem = items[0];
var widgetEl = createWidgetEl(items);
$(firstItem.getElement()).before(widgetEl);
processItemFocus(page, firstItem);
}
function processItemFocus(page, currentItem) {
if (!isPaginated(page)) return;
var items = getItems(page);
if (items.indexOf(currentItem) == -1) return;
items.forEach(function (item) {
if (item == currentItem) {
onItemShow(page, item);
} else {
onItemHide(page, item);
}
});
}
function onItemShow(page, item) {
var itemEl = item.getElement();
var tabEl = getTabEl(item);
YUD.removeClass(itemEl, CSS_ITEMHIDE);
YUD.addClass(itemEl, CSS_ITEMSHOW);
YUD.addClass(tabEl, CSS_ITEMACTIVE);
var scrollEl = page.getScrollableElement();
if (scrollEl) {
scrollEl.scrollTop = 0;
scrollEl.scrollLeft = 0;
}
}
function onItemHide(page, item) {
var itemEl = item.getElement();
var tabEl = getTabEl(item);
YUD.addClass(itemEl, CSS_ITEMHIDE);
YUD.removeClass(itemEl, CSS_ITEMSHOW);
YUD.removeClass(tabEl, CSS_ITEMACTIVE);
updateItemAnswered(item);
}
CM.onPageEvent('available', function (page) {
if (allowPagination(page)) {
processPage(page);
}
});
CM.onItemEvent('focus', processItemFocus);
})(ContentManager);

// FILE: testshell.js (0cc38dc8) 7/22/2014 5:26:22 PM

"use strict";
var TestShell =
{
name: null,
initializing: true,
testLengthMet: false,
testFinished: false,
idleTimer: null,
autoSaveTimer: null,
autoSaveInterval: 120,
enableKeyEvents: true,
xhrManager: null,
muted: false,
allowUnloading: false
};
TestShell.Config =
{
urlBase: './',
reviewPage: 0,
hasAudio: false,
testName: 'Unknown',
testLength: 0,
startPosition: 1,
contentLoadTimeout: 120,
interfaceTimeout: 20,
interfaceTimeoutDialog: 30,
requestInterfaceTimeout: 40,
oppRestartMins: 20,
autoSaveInterval: 120,
forbiddenAppsInterval: 60,
environmentCheckInterval: 30,
disableSaveWhenInactive: false,
disableSaveWhenForbiddenApps: false,
disableSaveWhenEnvironmentCompromised: false,
allowSkipAudio: false,
showSegmentLabels: false,
audioTimeout: 180,
enableLogging: false
};
TestShell.Events = new Util.EventManager(TestShell);
TestShell.SaveRequest =
{
Manual: 0,
Implicit: 1,
Auto: 2
};
TestShell.load = function()
{
try {
TestShell.init();
} catch(ex) {
TDS.Diagnostics.report(ex);
}
};
TestShell.unload = function(event)
{
if (!TestShell.allowUnloading) {
return Messages.getAlt('TestShell.Label.leavingPageAlert', 'You are attempting to leave the test. If you select OK, the test will be paused. Select cancel to continue your test.');
}
TTS.Manager.stop();
if (TDS.isProxyLogin)
{
TDS.CLS.LogoutComponent.PageUnloadEvent.fire(arguments);
}
if (TestShell.muted &&  Util.SecureBrowser.isMuted()) {
Util.SecureBrowser.unmute();
}
};
TestShell.init = function () {
TestShell.UI.showLoading(Messages.getAlt('TestShell.Label.Initializing', 'Initializing'));
this.xhrManager = new TestShell.XhrManager();
TDS.init();
TestShell.UI.init();
ContentManager.Dialog.urlFrame = TestShell.Config.urlBase + 'Pages/DialogFrame.xhtml';
this.subscribeDomEvents();
KeyManager.init();
if (TestShell.checkForbiddenApps()) return;
if (TestShell.checkForEnvironmentSecurity()) return;
ContentManager.init(TDS.baseUrl);
ContentManager.setReadOnly(TDS.isReadOnly);
ContentManager.Renderer.setClient(TDS.clientStylePath);
var flashPath = TDS.resolveBaseUrl('Scripts/Libraries/soundmanager2/swf/');
TDS.Audio.Player.setup(flashPath);
YAHOO.lang.JSON.dateToString = function (d) {
return '\/Date(' + d.getTime() + ')\/';
};
var idleTimeout = function () {
TestShell._pauseInternal(true, 'timeout', TestShell.Config.disableSaveWhenInactive);
};
this.idleTimer = new TimeoutIdle(TestShell.Config.interfaceTimeout, TestShell.Config.interfaceTimeoutDialog, idleTimeout);
this.idleTimer.start();
TestShell.SegmentManager.init();
TestShell.Tools.init();
TestShell.ResponseManager.ping();
if (TDS.isProxyLogin) TDS.CLS.LogoutComponent.init();
TestShell.Events.fire('init');
};
TestShell.subscribeDomEvents = function()
{
TestShell.UI.Events.btnZoomIn.subscribe(function() { TestShell.UI.zoomIn(); });
TestShell.UI.Events.btnZoomOut.subscribe(function() { TestShell.UI.zoomOut(); });
TestShell.UI.Events.btnLineReader.subscribe(function() { TestShell.UI.toggleLineReader(); });
TestShell.UI.Events.btnFormula.subscribe(function() { TestShell.Tools.toggleFormula(); });
TestShell.UI.Events.btnPeriodic.subscribe(function() { TestShell.Tools.togglePeriodicTable(); });
TestShell.UI.Events.btnCalculator.subscribe(function() { TestShell.Calculator.toggle(); });
TestShell.UI.Events.btnPrint.subscribe(function() { TestShell.Print.passage(); });
TestShell.UI.Events.btnSave.subscribe(function() { TestShell.save(TestShell.SaveRequest.Manual); });
TestShell.UI.Events.btnPause.subscribe(function() { TestShell.pause(); });
TestShell.UI.Events.btnBack.subscribe(function() { TestShell.Navigation.back(); });
TestShell.UI.Events.btnNext.subscribe(function() { TestShell.Navigation.next(); });
TestShell.UI.Events.btnEnd.subscribe(function() { TestShell.complete(); });
TestShell.UI.Events.btnResults.subscribe(function() { TestShell.testResults(); });
TestShell.UI.Events.btnHelp.subscribe(function() { TestShell.Tools.toggleHelp(); });
YUE.on(TestShell.UI.Nodes.ddlNavigation, 'change', function() { TestShell.Navigation.change(); });
};
TestShell.getHandlersUrl = function(handler)
{
var urlBuilder = [];
urlBuilder.push(TDS.baseUrl);
urlBuilder.push('Pages/API/');
if (handler) urlBuilder.push(handler);
return urlBuilder.join('');
};
TestShell.isTestCompleted = function()
{
if (TestShell.testLengthMet && TestShell.PageManager.hasPages())
{
return TestShell.PageManager.isCompleted();
}
return false;
};
TestShell.pause = function()
{
var taskWorkflow = new Util.TaskWorkflow();
taskWorkflow.add(TestShell.Validation.checkDirtyResponses);
taskWorkflow.add(TestShell.Validation.checkIfPromptSelected);
taskWorkflow.add(TestShell.Validation.checkSimulatorPlaying, 'SimulatorPlayingWhileNavigating');
taskWorkflow.add(TestShell.save, this, true);
taskWorkflow.add(TestShell.Validation.checkBlockPausing);
taskWorkflow.start(this._pauseInternal, this);
};
TestShell._pauseInternal = function(silent, reason, disableSave)
{
if (TDS.isProxyLogin) TDS.CLS.LogoutComponent.PageUnloadEvent.unsubscribeAll();
if (!disableSave) this.save();
var sendPause = function()
{
if (!YAHOO.lang.isString(reason)) reason = 'manual';
TestShell.xhrManager.queueAction('pause', { reason: reason }, function()
{
if (TDS.isProxyLogin) {
TestShell.redirectProxyLogout();
} else {
TestShell.redirectLogin();
}
});
};
if (silent === true)
{
sendPause();
}
else
{
var pauseMessage = (TestShell.Frame.getWriting()) ? ErrorCodes.get('WritingPause') : ErrorCodes.get('Pause', [TestShell.Config.oppRestartMins]);
TestShell.UI.showWarningPrompt(pauseMessage,
{
yes: sendPause
});
}
};
TestShell.complete = function () {
var taskWorkflow = new Util.TaskWorkflow();
taskWorkflow.add(TestShell.Validation.checkAudioPlaying);
taskWorkflow.add(TestShell.Validation.checkDirtyResponses);
taskWorkflow.add(TestShell.Validation.checkAudioRecording);
taskWorkflow.add(TestShell.Validation.checkRecorderQuality);
taskWorkflow.add(TestShell.Validation.checkIfPromptSelected);
taskWorkflow.add(TestShell.Validation.checkSimulatorPlaying, 'SimulatorPlayingWhileNavigating');
if (TDS.isProxyLogin) {
TDS.CLS.LogoutComponent.PageUnloadEvent.unsubscribeAll();
if (TDS.isSIRVE)
{
TestShell.redirectLogin();
return;
}
}
taskWorkflow.start(this._completeInternal, this);
};
TestShell.testResults = function()
{
TDS.redirect('Pages/ReviewShell.xhtml');
};
TestShell._completeInternal = function()
{
var btn = YUD.getStyle('btnEnd', 'display');
if (btn == 'none') return;
this.save();
var hasUnanswered = false;
Util.Array.each(TestShell.PageManager.getGroups(), function(group)
{
if (!group.isCompleted())
{
TestShell.UI.showWarning(ErrorCodes.get('EndUnanswered'));
hasUnanswered = true;
}
});
if (hasUnanswered) return;
TestShell.UI.showWarningPrompt('Complete',
{
yes: function()
{
TestShell.xhrManager.queueAction('complete', null, function()
{
TestShell.redirectReview();
});
}
});
};
TestShell.save = function (saveRequest) {
if (TDS.isSIRVE) return;
if (saveRequest == null) saveRequest = TestShell.SaveRequest.Implicit;
if (saveRequest == TestShell.SaveRequest.Manual)
{
var taskWorkflow = new Util.TaskWorkflow();
taskWorkflow.add(TestShell.Validation.checkAudioRecording);
taskWorkflow.add(TestShell.Validation.checkRecorderQuality);
taskWorkflow.add(TestShell.Validation.checkSimulatorPlaying, 'SimulatorPlayingWhileSaving');
taskWorkflow.add(TestShell.Validation.checkIfPromptSelected);
taskWorkflow.start(function () { this._saveInternal(saveRequest); }, this);
}
else
{
this._saveInternal(saveRequest);
}
};
TestShell._saveInternal = function(saveRequest)
{
var currentGroup = TestShell.PageManager.getCurrent();
if (currentGroup == null) return;
if (saveRequest == TestShell.SaveRequest.Auto && TestShell.xhrManager.hasAction()) return;
var saveResponses = [];
Util.Array.each(currentGroup.responses, function(response)
{
var item = response.getItem();
if (item == null) return;
if (saveRequest == TestShell.SaveRequest.Manual && !item.saveOptions.explicit) return;
if (saveRequest == TestShell.SaveRequest.Auto && !item.saveOptions.auto) return;
if (saveRequest == TestShell.SaveRequest.Implicit && !item.saveOptions.implicit) return;
if (item.spellCheck && item.spellCheck.isEnabled())
{
if (saveRequest == TestShell.SaveRequest.Auto) return;
item.spellCheck.disable();
}
if (!response.isDirty()) return;
if (item.grid)
{
item.grid.canvas.stopAction();
item.grid.canvas.clearFocused();
}
var itemResponse = item.getResponse();
if (!itemResponse)
{
Util.log('There is no item response.');
return;
}
if (item.recorder) {
var recorderObj = TDS.Audio.Widget.getRecorder(item.recorder);
if (recorderObj) {
recorderObj.dirty = false;
}
}
response.value = itemResponse.value;
response.isSelected = itemResponse.isSelected;
response.isValid = itemResponse.isValid;
saveResponses.push(response);
});
if (saveResponses.length > 0)
{
TestShell.ResponseManager.sendResponses(saveResponses);
}
TestShell.autoSaveStart();
};
TestShell.autoSaveStart = function()
{
if (this.autoSaveTimer != null) this.autoSaveTimer.cancel();
if (TestShell.Config.autoSaveInterval == 0) return;
var autoSaveMillis = (TestShell.Config.autoSaveInterval * 1000);
this.autoSaveTimer = YAHOO.lang.later(autoSaveMillis, this, function()
{
this.save(TestShell.SaveRequest.Auto);
});
};
TestShell.redirectProxyLogout = function () {
TestShell.allowUnloading = true;
TDS.logoutProctor(false);
};
TestShell.redirectLogin = function()
{
TestShell.allowUnloading = true;
TestShell.UI.showLoading('');
var url = TDS.baseUrl + 'Pages/LoginShell.xhtml?logout=true';
top.location.href = url;
};
TestShell.redirectReview = function()
{
TestShell.allowUnloading = true;
TestShell.UI.showLoading('');
var url = TDS.baseUrl + 'Pages/ReviewShell.xhtml';
top.location.href = url;
};
TestShell.redirectError = function(text)
{
TestShell.allowUnloading = true;
var url = TDS.baseUrl + 'Pages/Notification.xhtml';
if (YAHOO.util.Lang.isString(text))
{
url += '?message=' + encodeURIComponent(text);
}
top.location.href = url;
};
TestShell.checkForbiddenApps = function()
{
if (TDS.Debug.ignoreForbiddenApps) return false;
if (!(TestShell.Config.forbiddenAppsInterval > 0)) return false;
if (Util.Browser.readCookie('TDS-Student-ExcludeSchool') == 'True') return false;
var forbiddenApps = Util.SecureBrowser.getForbiddenApps();
if (forbiddenApps.length > 0)
{
var message = Messages.get('ForbiddenApps') + forbiddenApps[0].desc;
TestShell.UI.showAlert('Error', message, function()
{
TestShell._pauseInternal(true, 'forbiddenApps', TestShell.Config.disableSaveWhenForbiddenApps);
});
return true;
}
var forbiddenAppsMillis = (TestShell.Config.forbiddenAppsInterval * 1000);
YAHOO.lang.later(forbiddenAppsMillis, this, TestShell.checkForbiddenApps);
return false;
};
TestShell.checkForEnvironmentSecurity = function () {
if (!Util.SecureBrowser.isEnvironmentSecure()) {
var error = Messages.getAlt('TestShell.Alert.EnvironmentInsecure', 'Environment is not secure. Your test will be paused.');
TestShell.UI.showAlert('Error', error, function () {
TestShell._pauseInternal(true, 'Environment Security', TestShell.Config.disableSaveWhenEnvironmentCompromised);
});
return true;
}
var timerMillis = (TestShell.Config.environmentCheckInterval * 1000);
YAHOO.lang.later(timerMillis, this, TestShell.checkForEnvironmentSecurity);
return false;
};
function onFrameLogout()
{
if (top._frameLoggedOut) return;
top._frameLoggedOut = true;
var logoutError = Messages.get('TDSShellJS.Label.FrameLogout');
TestShell.redirectError(logoutError);
}

// FILE: testshell_UI.js (93dcd8b3) 7/22/2014 5:26:22 PM

var NotificationType =
{
none: 0,
success: 1,
notice: 2,
error: 3
};
TestShell.UI =
{
zoom: null,
defaultBodyCSS: null,
CSS: {
dialogShowing: 'showingDialog',
popupShowing: 'showingPopup',
loading: 'showingLoading'
},
Nodes: {},
Events: {}
};
TestShell.UI.Notification =
{
None: 0,
Success: 1,
Notice: 2,
Error: 3
};
TestShell.UI.addClick = function(id, callback)
{
var target = YUD.get(id);
if (target == null) return false;
if (ContentManager.enableARIA === false)
{
target.setAttribute('tabindex', '-1');
if (target.tagName != 'SELECT')
{
YUE.on(target, 'mousedown', function(evt) { YUE.stopEvent(evt); });
YUE.on(target, 'mouseup', function(evt) { YUE.stopEvent(evt); });
}
}
YUE.on(target, 'click', function(evt)
{
if (target.nodeName == 'A' || target.nodeName == 'SELECT')
{
YUE.stopEvent(evt);
}
if (YUD.getAttribute(target, 'disabled') != 'disabled')
{
callback.call(this, evt);
}
}, this, true);
return true;
};
TestShell.UI.createEvent = function(name)
{
this.Events[name] = new YAHOO.util.CustomEvent(name, this, false, YAHOO.util.CustomEvent.FLAT);
};
TestShell.UI.init = function()
{
this.defaultBodyCSS = document.body.className;
this.zoom = new ContentZoom(document);
this.zoom.contentImages = false;
this.loadDomNodes();
this.createDomEvents();
this.enableContextMenuButton();
this.enableRedrawFix();
TDS.Button.init();
TDS.ARIA.createLog();
};
TestShell.UI.loadDomNodes = function()
{
this.Nodes.ddlNavigation = YUD.get('ddlNavigation');
this.Nodes.btnDebug = YUD.get('btnDebug');
this.Nodes.btnHelp = YUD.get('btnHelp');
this.Nodes.btnZoomIn = YUD.get('btnZoomIn');
this.Nodes.btnZoomOut = YUD.get('btnZoomOut');
this.Nodes.btnLineReader = YUD.get('btnLineReader');
this.Nodes.btnCalculator = YUD.get('btnCalculator');
this.Nodes.btnFormula = YUD.get('btnFormula');
this.Nodes.btnPeriodic = YUD.get('btnPeriodic');
this.Nodes.btnPrint = YUD.get('btnPrint');
this.Nodes.btnPrintPractice = YUD.get('btnPrintPractice');
this.Nodes.btnGlobalNotes = YUD.get('btnGlobalNotes');
this.Nodes.lblStatus = YUD.get('lblStatus');
this.Nodes.btnSave = YUD.get('btnSave');
this.Nodes.btnPause = YUD.get('btnPause');
this.Nodes.btnBack = YUD.get('btnBack');
this.Nodes.btnNext = YUD.get('btnNext');
this.Nodes.btnEnd = YUD.get('btnEnd');
this.Nodes.btnResults = YUD.get('btnResults');
this.Nodes.testName = YUD.get('lblTestName');
this.Nodes.tools = YUD.get('studentTools');
this.Nodes.controls = YUD.get('studentControls');
};
TestShell.UI.createDomEvents = function()
{
Util.Array.each(Util.Object.keys(this.Nodes), function(key)
{
var element = TestShell.UI.Nodes[key];
TestShell.UI.createEvent(key);
TestShell.UI.addClick(element, function()
{
TestShell.UI.Events[key].fire(element);
});
});
};
TestShell.UI.isLoading = function()
{
return YUD.hasClass(document.body, TestShell.UI.CSS.loading);
};
TestShell.UI.showLoading = function(message)
{
if (YAHOO.lang.isString(message))
{
if (YUD.get('loadingMessage'))
{
YUD.get('loadingMessage').innerHTML = message;
}
}
else
{
}
if (this.isLoading()) return false;
return YUD.addClass(document.body, TestShell.UI.CSS.loading);
};
TestShell.UI.hideLoading = function()
{
if (!this.isLoading()) return false;
return YUD.removeClass(document.body, TestShell.UI.CSS.loading);
};
TestShell.UI.enableControl = function(id, enabled)
{
var control = YUD.get(id);
if (control == null || control.parentNode == null) return;
if (enabled)
{
YUD.addClass(control.parentNode, 'active');
YUD.removeClass(control.parentNode, 'inactive');
control.removeAttribute('disabled');
}
else
{
YUD.removeClass(control.parentNode, 'active');
YUD.addClass(control.parentNode, 'inactive');
control.setAttribute('disabled', 'disabled');
}
};
TestShell.UI.updateControls = function()
{
TestShell.UI.enableControl('btnPause', true);
var currentGroup = TestShell.PageManager.getCurrent();
if (currentGroup != null)
{
TestShell.UI.enableControl('btnBack', !TestShell.PageManager.isFirst(currentGroup));
TestShell.UI.enableControl('btnNext', true);
}
else
{
TestShell.UI.enableControl('btnBack', false);
TestShell.UI.enableControl('btnNext', false);
}
TestShell.UI.enableControl('btnEnd', TestShell.isTestCompleted());
if (TestShell.testFinished)
{
TestShell.UI.showNotification(TestShell.UI.Notification.Success, Messages.get('TestCompleted'));
}
if (TDS.showItemScores)
{
TestShell.UI.enableControl('btnPause', false);
TestShell.UI.enableControl('btnEnd', false);
TestShell.UI.enableControl('btnResults', true);
TestShell.UI.showNotification(TestShell.UI.Notification.Success, Messages.get('TestItemScores'));
}
TestShell.Navigation.update();
var responsesSoFar = 0;
var firstGroup = TestShell.PageManager.getFirstGroup();
if (firstGroup && firstGroup.responses) responsesSoFar = firstGroup.responses[0].position - 1;
var allGroups = TestShell.PageManager.getGroups();
Util.Array.each(allGroups, function(group)
{
responsesSoFar += group.getNumAnswered();
});
var testLabel = TestShell.Config.testName + ' (' + responsesSoFar + ' ' + Messages.get('TDSShellUIJS.Label.OutOf') + ' ' + TestShell.Config.testLength + ')';
TestShell.UI.Nodes.testName.innerHTML = testLabel;
};
TestShell.UI.showSave = function(group)
{
var enable = false;
if (group && group.responses)
{
enable = Util.Array.find(group.responses, function(response)
{
return (response.getItem().saveOptions.explicit);
});
}
if (enable) YUD.addClass('btnSave', 'enable');
else YUD.removeClass('btnSave', 'enable');
TestShell.UI.enableControl('btnSave', enable);
return enable;
};
TestShell.UI.showNotification = function(type, message)
{
var notificationsContainer = YUD.getElementsByClassName('notificationsContainer', 'div');
if (notificationsContainer == null || notificationsContainer.length == 0) return false;
if (type == null || type == 0)
{
YUD.get('pnlNotifySuccess').style.display = 'none';
YUD.get('pnlNotifyNotice').style.display = 'none';
YUD.get('pnlNotifyError').style.display = 'none';
}
else if (type == 1)
{
YUD.get('pnlNotifySuccess').style.display = '';
YUD.get('pnlNotifySuccess').innerHTML = message;
}
else if (type == 2)
{
YUD.get('pnlNotifyNotice').style.display = '';
YUD.get('pnlNotifyNotice').innerHTML = message;
}
else if (type == 3)
{
YUD.get('pnlNotifyError').style.display = '';
YUD.get('pnlNotifyError').innerHTML = message;
}
return true;
};
TestShell.UI.reload = function()
{
TestShell.UI.showLoading();
var currentGroup = TestShell.PageManager.getCurrent();
if (currentGroup) currentGroup.requestContent(true);
};
TestShell.UI.showContentError = function()
{
TestShell.UI.hideLoading();
TestShell.UI.showErrorPrompt('ContentTimeout',
{
yes: function()
{
TestShell.UI.reload();
var group = TestShell.PageManager.getCurrent();
if (group)
{
TDS.Diagnostics.logServerError('CONTENT ' + group.id + ': Reload');
}
},
no: function()
{
TestShell._pauseInternal(true);
}
});
};
TestShell.UI.zoomIn = function()
{
var currentPage = ContentManager.getCurrentPage();
if (currentPage) currentPage.zoomIn();
};
TestShell.UI.zoomOut = function()
{
var currentPage = ContentManager.getCurrentPage();
if (currentPage) currentPage.zoomOut();
};
TestShell.UI.toggleLineReader = function()
{
TDS.LineReaderControl.toggle();
};
TestShell.UI.clearScreen = function()
{
while (true)
{
try { document.body.removeChild(document.body.firstChild); }
catch(ex) { break; }
}
};
TestShell.UI.enableContextMenuButton = function() {
var btnContext = YUD.get('btnContext');
if (btnContext == null) return;
YUE.on(btnContext, Util.Event.Mouse.start, function(ev) {
YUE.stopEvent(ev);
var btnRegion = YUD.getRegion(btnContext);
ContentManager.Menu.show(ev, null, [btnRegion.left, btnRegion.bottom]);
});
};
TestShell.UI.showGlobalContextMenu = function(ev)
{
if (TestShell.Comments.isShowing()) return;
var contentMenu = new ContentMenu();
var getText = function(id)
{
var el = YUD.get(id);
return el.innerText ? el.innerText : el.textContent;
};
var addLinkToMenu = function(link, menuClass, alternateText)
{
link = YUD.get(link);
if (link == null) return;
if (YUD.getStyle(link, 'display') == 'none') return;
if (YUD.hasClass(link, 'excludeMenu')) return;
var menuFunc = function()
{
setTimeout(function() { Util.Event.selectLink(link); }, 0);
};
var menuItem =
{
text: YAHOO.lang.isString(alternateText) ? alternateText : getText(link.id),
classname: menuClass,
onclick: { fn: menuFunc }
};
contentMenu.addMenuItem('global', menuItem);
};
var addLinksToMenu = function(parentID)
{
var parent = YUD.get(parentID);
var links = parent.getElementsByTagName('a');
YUD.batch(links, function(link)
{
addLinkToMenu(link, link.className);
});
};
var currentPage = ContentManager.getCurrentPage();
if (currentPage && currentPage.soundCue)
{
var linkEl = YUD.get(currentPage.soundCue.id);
if (linkEl != null && !TDS.Audio.isActive()) {
addLinkToMenu(linkEl, 'sound_instructions', Messages.getAlt('TDSAudioJS.Label.AddMenuPlayInstruction', 'Play Instructions'));
}
}
addLinksToMenu(this.Nodes.controls);
addLinksToMenu(this.Nodes.tools);
addLinkToMenu(this.Nodes.btnHelp, 'help');
ContentManager.Menu.show(ev, contentMenu.getMenuItems());
};
TestShell.UI.enableRedrawFix = function() {
var navigationEl = YUD.get('navigation');
if (navigationEl == null) return;
YUE.on(navigationEl, Util.Event.Mouse.start, function(ev) {
var targetEl = YUE.getTarget(ev);
if (navigationEl == targetEl) {
ContentManager.applyRedrawFix();
}
});
};
(function(UI) {
function createButton(parentId, id, label, className, fn) {
var topBarEl = YUD.get(parentId);
if (topBarEl == null) return null;
var ulEl = YUD.getFirstChild(topBarEl);
if (ulEl == null) return null;
var liEl = document.createElement('li');
var linkEl = document.createElement('a');
if (id) {
linkEl.id = id;
}
YUD.setAttribute(linkEl, 'href', '#');
YUD.setAttribute(linkEl, 'tabindex', '-1');
if (className) {
YUD.addClass(linkEl, className);
}
liEl.appendChild(linkEl);
var spanEl = document.createElement('span');
spanEl.className = 'icon';
if (label) {
spanEl.innerHTML = label;
}
linkEl.appendChild(spanEl);
if (YAHOO.lang.isFunction(fn)) {
UI.addClick(linkEl, fn);
}
ulEl.appendChild(liEl);
return liEl;
};
UI.addButtonTool = function(id, label, className, fn) {
return createButton('studentTools', id, label, className, fn);
};
UI.addButtonControl = function (id, label, className, fn) {
return createButton('studentControls', id, label, className, fn);
};
})(TestShell.UI);
(function(UI) {
function showAlert(textHeader, textMessage, funcOk) {
ContentManager.Menu.hide();
UI.hideLoading();
var handleOk = function() {
this.hide();
top.focus();
if (funcOk) {
funcOk();
}
};
var buttons = [
{ text: Messages.get('Global.Label.OK'), handler: handleOk }
];
TDS.Dialog.show(textHeader, textMessage, buttons);
}
UI.showAlert = showAlert;
UI.showWarning = function(textMessage, funcOk) {
var textHeader = Messages.get('TDSShellUIJS.Label.Warning');
showAlert(textHeader, textMessage, funcOk);
};
UI.showError = function(textMessage, funcOk) {
var textHeader = Messages.get('TDSShellUIJS.Label.Error');
showAlert(textHeader, textMessage, funcOk);
};
function showPrompt(textHeader, textMessage, obj)
{
ContentManager.Menu.hide();
obj.noLabel = Messages.get(obj.noLabel ? obj.noLabel : 'Global.Label.No');
obj.yesLabel = Messages.get(obj.yesLabel ? obj.yesLabel : 'Global.Label.Yes');
var yesHandler = function()
{
this.hide();
top.focus();
if (obj.yes)
{
if (obj.scope) obj.yes.call(obj.scope);
else obj.yes();
}
};
var noHandler = function()
{
this.hide();
top.focus();
if (obj.no)
{
if (obj.scope) obj.no.call(obj.scope);
else obj.no();
}
};
var buttons = [
{ text: obj.noLabel, handler: noHandler, isDefault: true },
{ text: obj.yesLabel, handler: yesHandler }
];
if (obj.logout)
{
var logoutHandler = function()
{
this.hide();
UI.clearScreen();
TestShell.redirectLogin();
};
var logoutLabel = Messages.getAlt('Global.Label.Logout', 'Logout');
buttons.push({ text: logoutLabel, handler: logoutHandler });
}
TDS.Dialog.show(textHeader, textMessage, buttons);
}
UI.showWarningPrompt = function(textMessage, obj) {
var textHeader = Messages.get('TDSShellUIJS.Label.Warning');
textMessage = ErrorCodes.get(textMessage);
showPrompt(textHeader, textMessage, obj);
};
UI.showErrorPrompt = function(textMessage, obj) {
var textHeader = Messages.get('TDSShellObjectsJS.Label.Error');
textMessage = ErrorCodes.get(textMessage);
showPrompt(textHeader, textMessage, obj);
};
})(TestShell.UI);

// FILE: testshell_Keyboard.js (25374db8) 7/22/2014 5:26:22 PM

function onkeyevent(e, type, key, keyCode, charCode, target)
{
if (!TestShell.enableKeyEvents) return KeyEventResult.Allow;
if (type == 'keydown' && keyCode == 27)
{
TDS.ToolManager.hideAll();
ContentManager.Dialog.hide();
}
if (ContentManager.Dialog.isShowing())
{
if (keyCode == 77 && e.ctrlKey) ContentManager.Dialog.hide();
if (keyCode == 13          ) return KeyEventResult.Allow;
if (ContentManager.Dialog.containsElement(target))
{
if (keyCode >= 37 && keyCode <= 40) return KeyEventResult.Allow;
}
return KeyEventResult.Stop;
}
if (keyCode >= 37 && keyCode <= 40 && e.shiftKey && !Util.Event.inTextInput(e) && !Mozilla.inCaretMode())
{
return KeyEventResult.Stop;
}
try
{
if (e.ctrlKey && e.altKey && e.shiftKey && type == 'keyup' && keyCode == 68)
{
return KeyEventResult.Matched;
}
}
catch (ex) { }
if (e.ctrlKey && !e.shiftKey && type == 'keypress')
{
if (keyCode == 0 && navigator.userAgent.indexOf('PPC Mac OS X') != -1)
{
if (charCode == 61) { TestShell.UI.zoomIn(); return KeyEventResult.Matched; }
if (charCode == 31) { TestShell.UI.zoomOut(); return KeyEventResult.Matched; }
}
}
else if (e.ctrlKey && !e.shiftKey && type == 'keyup')
{
if (keyCode == 107 || keyCode == 61        ) { TestShell.UI.zoomIn(); return KeyEventResult.Matched; }
if (keyCode == 109) { TestShell.UI.zoomOut(); return KeyEventResult.Matched; }
switch (key)
{
case 'Left': TestShell.Navigation.back(); return KeyEventResult.Matched;
case 'Right': TestShell.Navigation.next(); return KeyEventResult.Matched;
case 'G': TestShell.UI.showGlobalContextMenu(e); return KeyEventResult.Matched;
}
}
return KeyEventResult.Ignored;
}

// FILE: testshell_CoverPages.js (8db2bee2) 7/22/2014 5:26:22 PM

TestShell.CoverPages =
{
_collection: new Util.Structs.Map()
};
TestShell.CoverPages.add = function(coverPage)
{
this._collection.set(coverPage.id, coverPage);
};
TestShell.CoverPages.list = function()
{
return this._collection.getValues();
};
TestShell.CoverPages.contains = function(id)
{
return this._collection.containsKey(id);
};
TestShell.CoverPages.get = function(id)
{
return this._collection.get(id);
};
ContentManager.onPageEvent('rendering', function(contentPage)
{
var page = TestShell.PageManager.get(contentPage.id);
if (!(page instanceof TestShell.PageGroup)) return;
var cpInfo = page.getCoverPageInfo();
if (cpInfo == null) return;
var coverPage = TestShell.CoverPages.get(cpInfo.id);
if (coverPage == null)
{
coverPage = new TestShell.PageResource(cpInfo.bankKey, cpInfo.itemKey, contentPage.segmentID);
TestShell.CoverPages.add(coverPage);
}
});
ContentManager.onPageEvent('beforeShow', function(contentPage)
{
var currentPage = TestShell.PageManager.get(contentPage.id);
if (!(currentPage instanceof TestShell.PageGroup)) return true;
var currentCoverPage = currentPage.getCoverPage();
if (currentCoverPage == null) return true;
if (TestShell.PageManager.contains(currentCoverPage)) return true;
var navState = TestShell.Navigation.getState();
if (currentPage == TestShell.PageManager.getFirst())
{
TestShell.PageManager.insertPage(currentCoverPage, currentPage);
}
if (navState == TestShell.Navigation.State.Initializing)
{
var isReviewing = (TestShell.Config.reviewPage > 0);
if (!isReviewing && currentPage.getPrevious() != null && !currentPage.isVisited())
{
TestShell.Navigation._backInternal();
TestShell.PageManager.History.pop();
return false;
}
}
if (navState == TestShell.Navigation.State.Next)
{
var previousPage = currentPage.getPrevious();
var previousCoverPage = previousPage.getCoverPage();
if (previousCoverPage == null ||
previousCoverPage != currentCoverPage)
{
TestShell.PageManager.insertPage(currentCoverPage, currentPage);
TestShell.PageManager.swapCurrent(currentCoverPage);
return false;
}
}
if (navState == TestShell.Navigation.State.Back)
{
var nextPage = currentPage.getNext();
var nextCoverPage = nextPage.getCoverPage();
if (nextCoverPage != null &&
nextCoverPage != currentCoverPage)
{
TestShell.PageManager.insertPage(nextCoverPage, nextPage);
TestShell.PageManager.swapCurrent(nextCoverPage);
return false;
}
}
return true;
}, true);

// FILE: testshell_ContentManager.js (03f2b788) 7/22/2014 5:26:22 PM

ContentManager.onPageEvent('Rendered', function(contentPage)
{
var contentDoc = contentPage.getDoc();
if (contentDoc == null) return;
var contentBody = contentDoc.body;
if (document.body != contentBody)
{
contentBody.className = TestShell.UI.defaultBodyCSS;
YUD.removeClass(contentBody, 'showingLoading');
var contentWin = contentPage.getWin();
TDS.Diagnostics.addErrorHandler(contentWin);
}
});
ContentManager.onItemEvent('available', function(contentPage, item)
{
var pageHeader = contentPage.getHeader();
if (pageHeader) pageHeader.setAttribute('tabindex', '-1');
});
ContentManager.onItemEvent('available', function(contentPage, item)
{
var group = TestShell.PageManager.get(contentPage.id);
if (group instanceof TestShell.PageGroup)
{
var response = group.getResponse(item.position);
if (response && item.printed)
{
TestShell.Print.itemComplete(group, response);
}
}
});
ContentManager.onPassageEvent('available', function(contentPage, passage)
{
var group = TestShell.PageManager.get(contentPage.id);
if (group instanceof TestShell.PageGroup && passage.printed)
{
TestShell.Print.passageComplete(group);
}
});
ContentManager.onPageEvent('loaded', function(contentPage)
{
var group = TestShell.PageManager.get(contentPage.id);
var pageWin = contentPage.getWin();
var pageDoc = contentPage.getDoc();
group.createSoundCue();
if (window != pageWin) {
KeyManager.attachListener((YAHOO.env.ua.gecko) ? pageWin : pageDoc);
TestShell.idleTimer.addListeners(pageWin);
}
TestShell.Navigation.requestPage();
});
ContentManager.onPageEvent('loaded', function(contentPage)
{
var missingImages = [];
missingImages.push(contentPage.getImagesFailed());
missingImages.push(contentPage.getImagesAborted());
missingImages = Util.Array.flatten(missingImages);
var missingFiles = [];
for (var i = 0; i < missingImages.length; i++)
{
var image = missingImages[i];
var imageFile = image.src.split('/').pop().split('file=').pop();
imageFile = '\'' + imageFile + '\'';
missingFiles.push(imageFile);
}
if (missingFiles.length > 0)
{
TDS.Diagnostics.logServerError('CONTENT ' + contentPage.id + ': Missing Images - ' + missingFiles.join(', '));
}
});
ContentManager.onItemEvent('loaded', function(contentPage, item)
{
if (item.grid == null) return;
var getGridImages = function()
{
var images = [];
images = images.concat(item.grid.question.getBackgroundImages());
images = images.concat(item.grid.question.getPaletteImages());
if (YAHOO.lang.isFunction(item.grid.question.getRegionsImages))
{
images = images.concat(item.grid.question.getRegionsImages());
}
return images;
};
var getMissingImages = function()
{
var images = getGridImages();
var missingImages = [];
for (var i = 0; i < images.length; i++)
{
var gridImage = images[i];
if (gridImage == null) continue;
var isValidImage = (gridImage.width > 0 && gridImage.height > 0);
if (!isValidImage) missingImages.push(gridImage);
}
return missingImages;
};
var logMissingImages = function(message, missingImages)
{
var missingFiles = [];
if (YAHOO.lang.isArray(missingImages))
{
for (var i = 0; i < missingImages.length; i++)
{
var image = missingImages[i];
if (image == null) continue;
var imageUrl = null;
if (image.url) imageUrl = image.url;
else if (image.src) imageUrl = image.src;
else if (image.href) imageUrl = image.getAttribute('xlink:href');
if (imageUrl == null) continue;
if (imageUrl.indexOf('file=') != -1)
{
imageUrl = imageUrl.split('file=')[1];
}
imageUrl = '"' + imageUrl + '"';
if (missingFiles.indexOf(imageUrl) == -1)
{
missingFiles.push(imageUrl);
}
}
}
if (missingFiles.length > 0)
{
var serverError = 'GRID I-' + item.bankKey + '-' + item.itemKey + ': ' + message + ' - ' + missingFiles.join(', ');
TDS.Diagnostics.logServerError(serverError);
}
};
item.grid.subscribe('onStateChange', function(gridEvt)
{
if (gridEvt.state == GridState.Loaded)
{
var imageErrors = getMissingImages();
if (imageErrors.length > 0)
{
var errorData = { message: 'Error with dimensions of images', values: imageErrors };
item.grid._setState(GridState.Error, errorData);
}
else if (YAHOO.lang.isFunction(item.grid.validate))
{
item.grid.validate();
}
}
else if (gridEvt.state == GridState.Error)
{
if (gridEvt.data)
{
logMissingImages(gridEvt.data.message, gridEvt.data.values);
}
var currentGroup = TestShell.PageManager.getCurrent();
if (currentGroup != null)
{
var currentContentPage = currentGroup.getContentPage();
if (currentContentPage != null && currentContentPage == item.getPage())
{
TestShell.UI.showContentError();
}
}
}
});
});
ContentManager.onPageEvent('beforeShow', function(contentPage)
{
if (contentPage.getImagesFailed().length > 0 ||
contentPage.getImagesAborted().length > 0)
{
TestShell.UI.showContentError();
return false;
}
var resourceLoaders = contentPage.getResourceLoaders();
if (resourceLoaders.hasLoaders() &&
resourceLoaders.getStatus() != ResourceLoader.Status.COMPLETE)
{
TestShell.UI.showContentError();
return false;
}
var items = contentPage.getItems();
for (var i = 0; i < items.length; i++)
{
var item = items[i];
if (item.grid)
{
if (item.grid.getState() == GridState.Error)
{
TestShell.UI.showContentError();
return false;
}
}
}
return true;
}, true);
ContentManager.onPageEvent('show', function(contentPage)
{
var page = TestShell.PageManager.get(contentPage.id);
TestShell.PageManager.Events.fire('onShow', page);
});
ContentManager.onPageEvent('beforeHide', function(contentPage)
{
TDS.ToolManager.hideAll();
ContentManager.Menu.hide();
TestShell.Comments.hide();
});
ContentManager.onPageEvent('hide', function(contentPage)
{
var page = TestShell.PageManager.get(contentPage.id);
TestShell.PageManager.Events.fire('onHide', page);
});
ContentManager.onPageEvent('hide', function(contentPage)
{
var tools = TDS.ToolManager.getAll();
for (var i = 0; i < tools.length; i++) {
try {
if (tools[i].id.toLowerCase().indexOf('calculator') > 0) {
var frameCalc = document.getElementById('frame-'+tools[i].id);
if (!frameCalc || !frameCalc.contentWindow) continue;
var winCalc = frameCalc.contentWindow;
if (typeof winCalc.resetTDSCalc != 'function') continue;
winCalc.resetTDSCalc();
}
}
catch (ex) { Util.log(ex); }
}
});
ContentManager.onEntityEvent('menushow', function(contentPage, entity, menu, evt)
{
if (ContentManager.Dialog.isShowing())
{
menu.cancel = true;
}
});
ContentManager.onPageEvent('completed', function(contentPage) {
TestShell.Navigation.next();
});
(function () {
ContentManager.onPageEvent('available', function (contentPage) {
var accProps = contentPage.getAccommodationProperties();
var zoomLevel = accProps.getPrintSize();
var pageZoom = contentPage.getZoom();
pageZoom.currentLevel = pageZoom.getLevel(zoomLevel);
if (pageZoom._documents.length > 0 &&
pageZoom._documents[0] == document) {
pageZoom._documents = [];
}
});
ContentManager.onPageEvent('beforeShow', function (contentPage) {
var shellZoom = TestShell.UI.zoom;
var pageZoom = contentPage.getZoom();
if (pageZoom.currentLevel != shellZoom.currentLevel) {
pageZoom.refresh(true);
}
});
ContentManager.onPageEvent('zoom', function (contentPage) {
var shellZoom = TestShell.UI.zoom;
var pageZoom = contentPage.getZoom();
if (shellZoom.currentLevel != pageZoom.currentLevel) {
shellZoom.setLevel(pageZoom.currentLevel);
}
$(TDS.ToolManager.getAll()).each(function (idx, panel) {
if (panel.refresh) {
panel.refresh();
}
});
});
})();
(function(window) {
if (!window.SpellCheck) return;
var SpellXhr = window.SpellCheck.XHR;
SpellXhr.onRequest.subscribe(function() {
TestShell.UI.showLoading('');
});
SpellXhr.onComplete.subscribe(function() {
TestShell.UI.hideLoading();
});
})(window);
ContentManager.Dialog.onShow.subscribe(function()
{
YUD.addClass(TestShell.Frame.getBody(), TestShell.UI.CSS.dialogShowing);
});
ContentManager.Dialog.onHide.subscribe(function()
{
YUD.removeClass(TestShell.Frame.getBody(), TestShell.UI.CSS.dialogShowing);
});
function tdsUpdateItemResponse(position, value)
{
var response = TestShell.PageManager.getResponse(position);
response.setValue(value);
Util.log('tdsUpdateItemResponse: ' + position + ' - \'' + response.value + '\' (' + response.sequence + ')');
TestShell.ResponseManager.sendResponse(response);
}
function tdsUpdateItemMark(position, marked)
{
var response = TestShell.PageManager.getResponse(position);
response.mark = marked;
TestShell.UI.updateControls();
TestShell.UI.showLoading('');
var markData = { position: position, mark: marked };
TestShell.xhrManager.markForReview(markData);
}
function tdsPassagePrint()
{
TestShell.Print.passage();
}
function tdsItemPrint(position)
{
var response = TestShell.PageManager.getResponse(position);
if (response.isDirty())
{
TestShell.UI.showAlert(Messages.get('TDSShellObjectsJS.Label.Warning'), Messages.get('TDSShellObjectsJS.Label.SaveBeforePrint'));
}
else
{
TestShell.Print.item(position);
}
}
function tdsRemoveResponse(position)
{
var itemResponse = TestShell.PageManager.getResponse(position);
if (itemResponse == null) return;
if (TestShell.ResponseManager.getPendingResponses().indexOf(itemResponse) != -1 ||
TestShell.ResponseManager.getOutgoingResponses().indexOf(itemResponse) != -1)
{
var resetWaitMsg = Messages.get('TestShell.Label.RemoveResponseWait');
TDS.Dialog.showAlert(resetWaitMsg);
return;
}
var itemData = {
position: itemResponse.position,
itemID: itemResponse.id,
dateCreated: itemResponse.dateCreated
};
var resetResponse = function()
{
TestShell.xhrManager.removeResponse(itemData, function(data, reply) {
if (reply != null && reply.replyCode === 0)
{
itemResponse.reset();
itemResponse.group.requestContent(true);
}
});
};
var resetMsg = Messages.get('TestShell.Label.RemoveResponseWarning');
TDS.Dialog.showPrompt(resetMsg, resetResponse);
}
TestShell.Events.subscribe('init', function()
{
ContentManager.Dialog.onShow.subscribe(function()
{
VideoManager.SWF.stopPlaying();
});
});
TTS.Manager.Events.onStatusChange.subscribe(function(currentStatus)
{
if (currentStatus == TTS.Status.Playing)
{
VideoManager.SWF.stopPlaying();
}
});

// FILE: testshell_Xml.js (98df8a22) 7/22/2014 5:26:22 PM

TestShell.Xml = {};
(function(TestShell) {
function createRequest(id, timestamp, responses) {
var xml = '<request action="update" eventID="' + id + '" timestamp="' + timestamp + '">';
if (YAHOO.util.Lang.isArray(responses)) {
xml += serializeResponses(responses);
}
xml += '</request>';
return xml;
};
function serializeResponses(responses) {
var xml = '<responseUpdates>';
Util.Array.each(responses, function(response) {
xml += serializeResponse(response);
});
xml += "</responseUpdates>";
return xml;
};
function serializeResponse(response) {
var xml = '<responseUpdate ';
xml += 'id="' + response.id + '" ';
xml += 'itsBank="' + response.itsBank + '" ';
xml += 'itsItem="' + response.itsItem + '" ';
xml += 'segmentID="' + response.group.segmentID + '" ';
xml += 'page="' + response.pageNum + '" ';
xml += 'position="' + response.position + '" ';
xml += 'sequence="' + response.sequence + '" ';
xml += 'dateCreated="' + response.dateCreated + '" ';
xml += 'isSelected="' + response.isSelected + '" ';
xml += 'isValid="' + response.isValid + '" ';
xml += '>';
var item = response.getItem();
xml += '<filePath>' + (item.filePath || '') + '</filePath>';
xml += '<value>';
if (response.value != null) {
if (typeof response.value == 'string') {
var responseValue = response.value.replace(/]]>/g, ']]&gt;');
xml += '<![CDATA[' + responseValue + ']]>';
} else {
var serialized = response.value;
try {
serialized = JSON.stringify(serialized);
} catch(ex) {
}
throw new Error('Cannot generate response xml because of invalid value property type: ' + serialized);
}
}
xml += '</value>';
xml += '</responseUpdate>';
return xml;
};
TestShell.Xml.createRequest = createRequest;
})(TestShell);
(function(TestShell) {
var getNode = Util.Dom.queryTag;
var getNodes = Util.Dom.queryTags;
var batchNodes = Util.Dom.queryTagsBatch;
var selectNode = Util.Dom.querySelector;
var selectNodes = Util.Dom.querySelectorAll;
var getAttribInt = Util.Xml.getAttributeInt;
var getAttribBool = Util.Xml.getAttributeBool;
var getAttrib = Util.Xml.getAttribute;
var getText = Util.Xml.getNodeText;
var getCData = Util.Xml.getCData;
function validResults(xmlDoc) {
if (xmlDoc == null) return false;
var nodeResults = getNode('results', xmlDoc);
if (nodeResults == null) return false;
return true;
};
function parseResults(xmlDoc) {
if (xmlDoc == null) return null;
var resultsNode = getNode('results', xmlDoc);
if (resultsNode == null) return null;
var results = {
eventID: getAttribInt(resultsNode, 'eventID'),
machineID: getAttrib(resultsNode, 'machineID'),
timestamps: readTimestamps(resultsNode),
notification: readNotification(resultsNode),
summary: parseSummary(resultsNode),
updates: readResponseUpdates(resultsNode),
groups: readGroups(resultsNode)
};
return results;
};
function readTimestamps(resultsNode) {
var node = getNode('timestamps', resultsNode);
if (node == null) return null;
var timestamps = {
clientSent: getAttribInt(node, 'sent'),
serverReceived: getAttribInt(node, 'received'),
serverCompleted: getAttribInt(node, 'completed'),
clientReceived: new Date().getTime()
};
return timestamps;
};
function readNotification(resultsNode)
{
var node = getNode('notification', resultsNode);
if (node == null) return null;
var notification = {
type: node.getAttribute('type'),
message: node.getAttribute('message')
};
return notification;
};
function parseSummary(resultsNode)
{
var node = getNode('summary', resultsNode);
if (node == null) return null;
var summary = {
testLength: getAttribInt(node, 'testLength'),
testLengthMet: getAttribBool(node, 'testLengthMet'),
testFinished: getAttribBool(node, 'testFinished'),
prefetched: getAttribBool(node, 'prefetched')
};
return summary;
};
function readResponseUpdates(resultsNode) {
var responses = [];
var updatesNode = getNode('updates', resultsNode);
batchNodes('response', updatesNode, function(updateNode) {
var responseStatus = parseResponseStatus(updateNode);
responses.push(responseStatus);
});
return responses;
};
function parseResponseStatus(updateNode) {
var responseStatus = new TestShell.Response.Status();
responseStatus.position = getAttribInt(updateNode, 'position');
responseStatus.status = getAttrib(updateNode, 'status');
responseStatus.reason = getAttrib(updateNode, 'reason');
return responseStatus;
};
function parseResponse(responseNode, group) {
var response = new TestShell.Response(group);
response.id = getAttrib(responseNode, 'id');
response.dateCreated = getAttrib(responseNode, 'created');
response.format = getAttrib(responseNode, 'format');
response.itsBank = getAttribInt(responseNode, 'bank');
response.itsItem = getAttribInt(responseNode, 'item');
response.pageNum = getAttribInt(responseNode, 'page');
response.position = getAttribInt(responseNode, 'position');
response.sequence = getAttribInt(responseNode, 'sequence');
response.mark = getAttribBool(responseNode, 'mark');
response.isSelected = getAttribBool(responseNode, 'isSelected');
response.isRequired = getAttribBool(responseNode, 'isRequired');
response.isValid = getAttribBool(responseNode, 'isValid');
response.prefetched = getAttribBool(responseNode, 'prefetched');
return response;
};
function parseGroup(resultsNode, groupNode) {
var group = new TestShell.PageGroup();
group.id = getAttrib(groupNode, 'id');
group.pageNum = getAttribInt(groupNode, 'page');
group.numRequired = getAttribInt(groupNode, 'numRequired');
group.segment = getAttribInt(groupNode, 'segment');
group.segmentID = getAttrib(groupNode, 'segmentID');
batchNodes('response', groupNode, function(node) {
var response = parseResponse(node, group);
group.responses.push(response);
});
return group;
};
function readGroups(resultsNode) {
var groupsNode = getNode('groups', resultsNode);
var groups = [];
batchNodes('group', groupsNode, function(node) {
var group = parseGroup(resultsNode, node);
groups.push(group);
});
return groups;
};
TestShell.Xml.validResults = validResults;
TestShell.Xml.parseResults = parseResults;
})(TestShell);

// FILE: testshell_Xhr.js (6be595ed) 7/22/2014 5:26:22 PM

TestShell.XhrManager = function()
{
TestShell.XhrManager.superclass.constructor.call(this, (90 * 1000), 1, TestShell);
this._action = null;
this.Events.subscribe('onShowProgress', function()
{
TestShell.UI.showLoading('');
});
this.Events.subscribe('onHideProgress', function()
{
TestShell.UI.hideLoading();
});
this.Events.subscribe('onError', TestShell.XhrManager.onError);
};
YAHOO.extend(TestShell.XhrManager, TDS.XhrManager);
TestShell.XhrManager.prototype.getUrl = function(action)
{
var urlBuilder = [];
urlBuilder.push(TDS.baseUrl);
urlBuilder.push('Pages/API/TestShell.axd/');
urlBuilder.push(action);
var currentPage = (TestShell.PageManager.getCurrent()) ? TestShell.PageManager.getCurrent().pageNum : 0;
urlBuilder.push('?currentPage=');
urlBuilder.push(currentPage);
return urlBuilder.join('');
};
TestShell.XhrManager.onError = function(request, errorMessage, retriable, logout)
{
var self = this;
if (retriable)
{
errorMessage += ' ' + Messages.getAlt('Messages.Label.XHRError', 'Select Yes to try again or No to logout.');
TDS.Dialog.showPrompt(errorMessage,
function()
{
TestShell.xhrManager.sendRequest(request);
},
function()
{
if (logout)
{
TestShell.redirectLogin();
}
});
}
else
{
TDS.Dialog.showWarning(errorMessage, function()
{
if (logout)
{
TestShell.redirectLogin();
}
});
}
};
TestShell.XhrManager.prototype.queueAction = function(action, parameters, callback)
{
TestShell.UI.showLoading('');
this._action = Util.Function.bind(this[action], this, parameters, callback);
TestShell.ResponseManager.processQueue();
};
TestShell.XhrManager.prototype.hasAction = function() { return (this._action != null); };
TestShell.XhrManager.prototype.processAction = function()
{
if (!this.hasAction()) return false;
this._action();
return true;
};
TestShell.XhrManager.prototype.pause = function(parameters, callback)
{
var data = TestShell.Audit.getJson();
return this.sendAction('pause', data, callback, null, parameters);
};
TestShell.XhrManager.prototype.complete = function(parameters, callback)
{
var data = TestShell.Audit.getJson();
return this.sendAction('complete', data, callback, null, parameters);
};
TestShell.XhrManager.prototype.waitForSegmentApproval = function(data, callback)
{
return this.sendAction('waitForSegmentApproval', data, callback, { showProgress: false });
};
TestShell.XhrManager.prototype.checkForSegmentApproval = function(callback)
{
return this.sendAction('checkForSegmentApproval', null, callback, { showProgress: false });
};
TestShell.XhrManager.prototype.exitSegment = function(data, callback)
{
var config = { showProgress: false, showDialog: false, showError: true, allowRetry: false, forceLogout: true };
return this.sendAction('exitSegment', data, callback, config);
};
TestShell.XhrManager.prototype.recordItemComment = function(data, callback)
{
return this.sendAction('recordItemComment', data, callback, {
allowRetry: true, forceLogout: false, showProgress: false
});
};
TestShell.XhrManager.prototype.recordOppComment = function(data, callback)
{
return this.sendAction('recordOppComment', data, callback, {
allowRetry: true, forceLogout: false, showProgress: false
});
};
TestShell.XhrManager.prototype.getOppComment = function(callback)
{
return this.sendAction('getOppComment', null, callback, {
allowRetry: true, forceLogout: false, showProgress: false
});
};
TestShell.XhrManager.prototype.markForReview = function(data, callback)
{
return this.sendAction('markForReview', data, callback, { allowRetry: true, forceLogout: false, showProgress: true });
};
TestShell.XhrManager.prototype.removeResponse = function(data, callback)
{
return this.sendAction('removeResponse', data, callback, { allowRetry: true, forceLogout: false, showProgress: true });
};
TestShell.XhrManager.prototype.getPauseStatus = function(callback)
{
return this.sendAction('getStatus', null, callback, { allowRetry: true, forceLogout: true, showProgress: true });
};

// FILE: testshell_ResponseManager.js (892f1ae4) 7/22/2014 5:26:22 PM

TestShell.ResponseManager = {};
TestShell.ResponseManager.Error =
{
None: 0,
Timeout: 1,
Network: 2,
Xml: 3,
HTTP: 4,
Server: 5,
ReturnStatus: 6
};
TestShell.ResponseManager._transaction = null;
TestShell.ResponseManager._sending = false;
TestShell.ResponseManager._timeout = (90 * 1000);
TestShell.ResponseManager._attemptTotal = 0;
TestShell.ResponseManager._attemptCount = 0;
TestShell.ResponseManager._maxRetries = 2;
TestShell.ResponseManager._lastError = TestShell.ResponseManager.Error.None;
TestShell.ResponseManager._lastStatusCode = 0;
TestShell.ResponseManager._lastStatusText = null;
TestShell.ResponseManager._pingResponses = false;
TestShell.ResponseManager._pendingResponses = [];
TestShell.ResponseManager._outgoingResponses = [];
TestShell.ResponseManager._timerDelay = null;
TestShell.ResponseManager.createEvent = function(name)
{
return new YAHOO.util.CustomEvent(name, this, true, YAHOO.util.CustomEvent.FLAT);
};
TestShell.ResponseManager.Events =
{
onQueue: TestShell.ResponseManager.createEvent('onQueue'),
onSend: TestShell.ResponseManager.createEvent('onSend'),
onFailure: TestShell.ResponseManager.createEvent('onFailure'),
onSuccess: TestShell.ResponseManager.createEvent('onSuccess'),
onGroups: TestShell.ResponseManager.createEvent('onGroups')
};
TestShell.ResponseManager.fireEvent = function(name, obj) { this.Events[name].fire(obj); };
TestShell.ResponseManager.getLastError = function() { return this._lastError; };
TestShell.ResponseManager.getLastStatusCode = function() { return this._lastStatusCode; };
TestShell.ResponseManager.getLastStatusText = function() { return this._lastStatusText; };
TestShell.ResponseManager._setLastError = function(error, message) { this._lastError = error; };
TestShell.ResponseManager._setLastStatus = function(statusCode, statusText)
{
this._lastStatusCode = statusCode;
this._lastStatusText = statusText;
};
TestShell.ResponseManager.getPendingResponses = function() { return this._pendingResponses; };
TestShell.ResponseManager.getOutgoingResponses = function() { return this._outgoingResponses; };
TestShell.ResponseManager.resetQueue = function()
{
this._setLastError(TestShell.ResponseManager.Error.None);
this._attemptCount = 0;
};
TestShell.ResponseManager.clearQueue = function()
{
this._pingResponses = false;
this._pendingResponses = [];
this._outgoingResponses = [];
this.resetQueue();
};
TestShell.ResponseManager.ping = function()
{
this._pingResponses = true;
this.processQueue();
};
TestShell.ResponseManager.isSending = function() { return this._sending; };
TestShell.ResponseManager.sendResponse = function(response) { this.sendResponses([response]); };
TestShell.ResponseManager.sendResponses = function(responses)
{
for (var i = 0; i < responses.length; i++)
{
var response = responses[i];
if (this._pendingResponses.indexOf(response) == -1)
{
this.fireEvent('onQueue', response);
this._pendingResponses.push(response);
}
}
this.processQueue();
};
TestShell.ResponseManager.hasReachedMaxRetries = function()
{
return this._attemptCount > this._maxRetries;
};
TestShell.ResponseManager.hasFatalLastError = function()
{
return (this.getLastError() >= TestShell.ResponseManager.Error.HTTP);
};
TestShell.ResponseManager.processQueue = function()
{
if (this._timerDelay) this._timerDelay.cancel();
if (this._sending) return false;
if (this.hasReachedMaxRetries() || this.hasFatalLastError())
{
this.fireEvent('onFailure', this.getLastError());
return false;
}
var shiftQueues = function(fromArr, toArr)
{
var fromObj = null;
while ((fromObj = fromArr.pop()) != null)
{
if (toArr.indexOf(fromObj) == -1) toArr.push(fromObj);
}
};
shiftQueues(this._pendingResponses, this._outgoingResponses);
if (this._pingResponses || this._outgoingResponses.length > 0)
{
this._timerDelay = YAHOO.lang.later(1, this, this._sendOutgoing);
return true;
}
else if (TestShell.xhrManager.hasAction())
{
TestShell.xhrManager.processAction();
}
return false;
};
TestShell.ResponseManager._createUrl = function()
{
var urlBuilder = [];
urlBuilder.push(TDS.baseUrl);
urlBuilder.push('Pages/API/Response.axd/update');
var lastGroup = TestShell.PageManager.getLastGroup();
urlBuilder.push('?lastPage=' + (lastGroup ? lastGroup.pageNum : 0));
return urlBuilder.join('');
};
TestShell.ResponseManager._createRequest = function()
{
var timestamp = new Date().getTime();
var requestXml = TestShell.Xml.createRequest(this._attemptTotal, timestamp, this._outgoingResponses);
return requestXml;
};
TestShell.ResponseManager._sendOutgoing = function()
{
this._sending = true;
this._attemptCount++;
this._attemptTotal++;
var callback = {};
callback.success = this._sendSuccess;
callback.failure = this._sendFailure;
callback.timeout = this._timeout;
callback.scope = this;
Util.Array.each(this._outgoingResponses, function(outgoingResponse)
{
outgoingResponse.sequence++;
});
var url = this._createUrl();
var content = this._createRequest();
this._transaction = YUC.asyncRequest('POST', url, callback, content);
this.fireEvent('onSend', this._outgoingResponses);
};
TestShell.ResponseManager._sendFailure = function(xhrObj)
{
this._sending = false;
Util.log('TestShell.ResponseManager xhr failure: ' + xhrObj.statusText);
this._setLastStatus(xhrObj.status, xhrObj.statusText);
if (xhrObj.status == -1)
{
this._setLastError(TestShell.ResponseManager.Error.Timeout);
}
else if (xhrObj.status == 0)
{
this._setLastError(TestShell.ResponseManager.Error.Network);
}
else if (xhrObj.status == 403)
{
this._setLastError(TestShell.ResponseManager.Error.ReturnStatus);
}
else if (xhrObj.status == 500)
{
this._setLastError(TestShell.ResponseManager.Error.Server);
}
else
{
this._setLastError(TestShell.ResponseManager.Error.HTTP);
}
this.processQueue();
};
TestShell.ResponseManager._sendSuccess = function(xhrObj)
{
this._sending = false;
this._setLastStatus(xhrObj.status, xhrObj.statusText);
if (xhrObj.getAllResponseHeaders == '' && xhrObj.responseText == '')
{
this._setLastError(TestShell.ResponseManager.Error.Network);
this.processQueue();
return;
}
var xmlDoc = xhrObj.responseXML;
if (!TestShell.Xml.validResults(xmlDoc))
{
this._setLastError(TestShell.ResponseManager.Error.Xml);
this.processQueue();
return;
}
var results = TestShell.Xml.parseResults(xmlDoc);
if (results.updates)
{
Util.Array.each(results.updates, function(responseUpdate)
{
var responseSent = Util.Array.find(TestShell.ResponseManager.getOutgoingResponses(), function(responseOutgoing)
{
return (responseUpdate.position == responseOutgoing.position);
});
if (responseSent)
{
Util.Array.remove(TestShell.ResponseManager.getOutgoingResponses(), responseSent);
}
});
}
if (TestShell.ResponseManager.getOutgoingResponses().length > 0)
{
Util.log('ResponseManager possible problem: Outgoing responses were not all sent');
}
TestShell.testLengthMet = results.summary.testLengthMet;
TestShell.testFinished = results.summary.testFinished;
TestShell.Config.testLength = results.summary.testLength;
if (TestShell.PageManager.getGroups().length == 0 && results.groups.length == 0 && TestShell.testLengthMet)
{
TestShell.redirectReview();
return;
}
if (results.groups && results.groups.length > 0)
{
this.fireEvent('onGroups', results.groups);
}
this.fireEvent('onSuccess', results);
this._pingResponses = false;
this.resetQueue();
this.processQueue();
};
TestShell.ResponseManager.Events.onQueue.subscribe(function(response)
{
TestShell.UI.updateControls();
});
TestShell.ResponseManager.Events.onSuccess.subscribe(function(response)
{
TestShell.UI.updateControls();
});
TestShell.ResponseManager.Events.onFailure.subscribe(function(error)
{
TestShell.UI.hideLoading();
var logout = function()
{
TestShell.ResponseManager.clearQueue();
TestShell.redirectLogin();
};
if (TestShell.ResponseManager.hasFatalLastError())
{
var message = Messages.getAlt('TestShell.Label.ErrorLoggedOut', 'Error you will be logged out');
if (this.getLastError() == TestShell.ResponseManager.Error.ReturnStatus)
{
message = this.getLastStatusText();
}
TestShell.UI.showWarning(message, logout);
}
else
{
TestShell.UI.showErrorPrompt('ResponseError',
{
yes: function()
{
TestShell.ResponseManager.resetQueue();
TestShell.ResponseManager.processQueue();
},
no: logout
});
}
});

// FILE: testshell_Response.js (2b594653) 7/22/2014 5:26:22 PM

TestShell.Response = function(group)
{
this.group = group;
this.id = null;
this.itsBank = 0;
this.itsItem = 0;
this.position = 0;
this.sequence = 0;
this.dateCreated = null;
this.mark = false;
this.isSelected = false;
this.isRequired = false;
this.isValid = false;
this.prefetched = false;
this.value = null;
this.comment = '';
this.getItem = function()
{
var page = group.getContentPage();
if (page != null) return page.getItem(this.position);
return null;
};
};
TestShell.Response.prototype.reset = function()
{
this.sequence = 0;
this.value = null;
this.isSelected = false;
this.isValid = false;
this.mark = false;
this.comment = '';
};
TestShell.Response.prototype.setValue = function(data)
{
this.value = data;
this.isValid = true;
this.isSelected = true;
};
TestShell.Response.prototype.getLastValue = function()
{
if (this.value != null) return this.value;
var item = this.getItem();
if (item) return item.value;
return null;
};
TestShell.Response.prototype.isAnswered = function()
{
return (this.isSelected && this.isValid);
};
TestShell.Response.prototype.isDirty = function()
{
var item = this.getItem();
if (!item) return false;
if (item.format.toLowerCase() == 'mc') return false;
if (item.recorder) {
var recorderObj = TDS.Audio.Widget.getRecorder(item.recorder);
if (recorderObj) {
return recorderObj.dirty;
}
}
var itemResponse = item.getResponse();
if (!itemResponse) return false;
if (itemResponse.isReady === false) {
return false;
}
var currentResponse = itemResponse.value;
var previousResponse = this.getLastValue();
if (item.responseType.toLowerCase() == 'grid')
{
if (!item.grid || !item.grid.isLoaded()) return false;
if (previousResponse == null && !item.grid.isValid()) return false;
return item.grid.hasChanged(previousResponse);
}
if (itemResponse.isSelected != this.isSelected) return true;
if (previousResponse == null && (currentResponse == null || currentResponse.length == 0)) return false;
return (currentResponse != previousResponse);
};
TestShell.Response.prototype.undo = function()
{
var item = this.getItem();
if (!item || !item.recorder) return false;
var previousResponse = this.getLastValue();
if (previousResponse != null)
{
Util.log('recorder: undo - loadBase64Audio');
TDS.Audio.Recorder.loadBase64Audio(item.recorder.id, previousResponse);
}
return true;
};
TestShell.Response.prototype.toString = function()
{
return (this.position != null) ? this.position.toString() : '';
};
TestShell.Response.Status = function() {
this.id = null;
this.status = '';
this.reason = '';
};
function getResponseIDs(responses)
{
return Util.Array.reduce(responses, '', function(text, response)
{
return text + ((text.length == 0) ? '' : ', ') + response.position;
});
}

// FILE: testshell_Page.js (c25f36fc) 7/22/2014 5:26:22 PM

TestShell.Page = function(id)
{
this.id = id;
this.zoom = null;
this.navOption = null;
this._visited = false;
};
TestShell.Page.prototype.isShowing = function()
{
return (YUD.getStyle(this.container, 'display') == 'block');
};
TestShell.Page.prototype.show = function() { return true; };
TestShell.Page.prototype.hide = function() { return true; };
TestShell.Page.prototype.isCurrent = function()
{
return (this === TestShell.PageManager.getCurrent());
};
TestShell.Page.prototype.isVisible = function()
{
if (this.isCurrent()) return true;
var pages = TestShell.PageManager.getPages();
for (var i = 0; i < pages.length; i++) {
var page = pages[i];
if (page == null) return false;
if (this == page) return true;
if (!page.isCompleted()) return false;
}
return false;
};
TestShell.Page.prototype.isEnabled = function() {
if (this.isVisible() === false) {
return false;
} else {
return true;
}
};
TestShell.Page.prototype.requiresVisit = function() {
var segment = this.getSegment();
if (segment) {
var accProps = segment.getAccommodationProperties();
return (accProps && accProps.requirePageVisit());
}
return false;
};
TestShell.Page.prototype.setVisited = function() {
this._visited = true;
};
TestShell.Page.prototype.isVisited = function() {
if (this._visited) return true;
if (this.requiresVisit()) {
var nextPages = this.getNextPages();
for (var i = 0; i < nextPages.length; i++) {
var page = nextPages[i];
if (page._visited) {
return true;
}
}
}
return false;
};
TestShell.Page.prototype.isCompleted = function() {
return true;
};
TestShell.Page.prototype.getLabelGroup = function() {
return null;
};
TestShell.Page.prototype.getLabel = function() {
return 'Page ' + this.id;
};
TestShell.Page.prototype.hasLabel = function()
{
var label = this.getLabel();
return (label != null);
};
TestShell.Page.prototype.updateNavigationLabel = function(refPage)
{
if (!this.hasLabel()) return;
var labelGroup = this.getLabelGroup();
var labelText = this.getLabel(true);
if (this.navOption == null)
{
var navDropdown = YUD.get('ddlNavigation');
var navGroup = null;
if (YAHOO.lang.isObject(labelGroup))
{
var navGroups = navDropdown.getElementsByTagName('optgroup');
if (labelGroup.id)
{
navGroup = document.getElementById(labelGroup.id);
}
else
{
navGroup = YAHOO.Array.filter(navGroups, function(existingNavGroup)
{
return (labelGroup == existingNavGroup.label);
});
}
if (navGroup == null)
{
navGroup = HTML.OPTGROUP({ id: labelGroup.id, label: labelGroup.label });
if (refPage) YUD.insertBefore(navGroup, refPage.navOption);
else navDropdown.appendChild(navGroup);
}
}
else
{
navGroup = navDropdown;
}
this.navOption = HTML.OPTION({ value: this.id });
if (refPage) {
YUD.insertBefore(this.navOption, refPage.navOption);
} else if (navGroup) {
navGroup.appendChild(this.navOption);
}
}
this.navOption.text = labelText;
if (this.isEnabled())
{
this.navOption.disabled = false;
YUD.removeClass(this.navOption, 'disabled');
}
else
{
this.navOption.disabled = true;
YUD.addClass(this.navOption, 'disabled');
}
if (this.isVisible())
{
YUD.setStyle(this.navOption, 'display', '');
YUD.setStyle(this.navOption, 'visibility', '');
YUD.removeClass(this.navOption, 'hidden');
}
else
{
YUD.setStyle(this.navOption, 'display', 'none');
YUD.setStyle(this.navOption, 'visibility', 'hidden');
YUD.addClass(this.navOption, 'hidden');
}
};
TestShell.Page.prototype.hasContent = function()
{
return true;
};
TestShell.Page.prototype.requestContent = function(reload) {};
TestShell.Page.prototype.getScreenReaderText = function()
{
return 'Page is ready';
};
TestShell.Page.prototype.getSegment = function() { return null; };
TestShell.Page.prototype.getCoverPage = function() { return null; };
TestShell.Page.prototype.getNext = function()
{
var pages = TestShell.PageManager.getPages(true);
var idx = pages.indexOf(this);
return (idx != -1) ? pages[idx + 1] : null;
};
TestShell.Page.prototype.getPrevious = function()
{
var pages = TestShell.PageManager.getPages(true);
var idx = pages.indexOf(this);
return (idx != -1) ? pages[idx - 1] : null;
};
TestShell.Page.prototype.getNextPages = function(enabled) {
var pagesAfter = [];
var pages = TestShell.PageManager.getPages(enabled);
var idx = pages.indexOf(this);
if (idx != -1) {
for (var i = idx + 1; i < pages.length; i++) {
pagesAfter.push(pages[i]);
}
}
return pagesAfter;
};
TestShell.Page.prototype.getPreviousPages = function(enabled) {
var pagesBefore = [];
var pages = TestShell.PageManager.getPages(enabled);
var idx = pages.indexOf(this);
if (idx != -1) {
for (var i = 0; i < idx; i++) {
pagesBefore.push(pages[i]);
}
}
return pagesBefore;
};
TestShell.Page.prototype.toString = function() { return this.id; };
function getGroupIDs(groups)
{
return Y.Array.reduce(groups, '', function(text, group)
{
return text + ((text.length == 0) ? '' : ', ') + group.id;
});
}

// FILE: testshell_PageContent.js (76fa9bea) 7/22/2014 5:26:22 PM

TestShell.PageContent = function(id)
{
TestShell.PageContent.superclass.constructor.call(this, id);
this._requestCount = 0;
};
YAHOO.lang.extend(TestShell.PageContent, TestShell.Page);
TestShell.PageContent.prototype.getRequestCount = function() { return this._requestCount; };
TestShell.PageContent.prototype.getContentPage = function()
{
return ContentManager.getPage(this.id);
};
TestShell.PageContent.prototype.hasContent = function()
{
var contentPage = this.getContentPage();
return (contentPage != null &&
contentPage.getState() == ContentPage.State.Loaded);
};
TestShell.PageContent.prototype.requestContent = function(reload)
{
var contentPage = this.getContentPage();
var contentExists = (contentPage != null);
if (contentExists)
{
if (reload) ContentManager.removePage(contentPage);
else return false;
}
this._requestCount++;
return TestShell.ContentLoader.request(this);
};
TestShell.PageContent.prototype.show = function()
{
var contentPage = this.getContentPage();
if (contentPage) return contentPage.show();
else return false;
};
TestShell.PageContent.prototype.hide = function()
{
var contentPage = this.getContentPage();
if (contentPage) return contentPage.hide();
else return false;
};
TestShell.PageContent.prototype.getScreenReaderText = function()
{
var text = 'Page is ready. ';
var contentPage = this.getContentPage();
var itemCount = contentPage.getItems().length;
if (contentPage.getPassage() != null)
{
text += '1 Passage and ';
}
text += itemCount + ' Question';
if (itemCount > 1) text += 's';
return text;
};
TestShell.PageContent.prototype.createSoundCue = function() {
var Player = TDS.Audio.Player;
var Widget = TDS.Audio.Widget;
var contentPage = this.getContentPage();
if (contentPage == null || contentPage.soundCue == null) return false;
var id = 'soundcue-' + contentPage.soundCue.bankKey + '-' + contentPage.soundCue.itemKey;
var url = TestShell.getHandlersUrl('SoundCue.axd?bankKey=' + contentPage.soundCue.bankKey + '&itemKey=' + contentPage.soundCue.itemKey);
contentPage.soundCue.id = id;
var linkEl = YUD.get(id);
if (linkEl == null)
{
linkEl = HTML.A({
id: id,
href: url,
type: 'audio/ogg',
className: 'sound_cue',
style: 'display:none;'
});
YUD.get('soundCues').appendChild(linkEl);
Widget.createPlayer(linkEl);
}
contentPage.autoPlayQueue.insert(id);
return true;
};
TestShell.PageContent.prototype.showSoundCue = function()
{
var contentPage = this.getContentPage();
if (contentPage == null || contentPage.soundCue == null) return false;
var element = YUD.get(contentPage.soundCue.id);
if (element) {
YUD.setStyle(element, 'display', 'block');
}
return true;
};
TestShell.PageContent.prototype.hideSoundCue = function()
{
var contentPage = this.getContentPage();
if (contentPage == null || contentPage.soundCue == null) return false;
var element = YUD.get(contentPage.soundCue.id);
if (element) {
YUD.setStyle(element, 'display', 'none');
}
return true;
};
TestShell.PageContent.prototype.getMissingImages = function()
{
var missingImages = [];
var contentPage = this.getContentPage();
if (contentPage)
{
var images = contentPage.getImages();
for (var i = 0; i < images.length; i++)
{
var image = images[i];
if (image.state && image.state > 1) missingImages.push(image);
}
}
return missingImages;
};

// FILE: testshell_PageGroup.js (e8e50766) 7/22/2014 5:26:22 PM

TestShell.PageGroup = function(id)
{
TestShell.PageGroup.superclass.constructor.call(this, id);
this.pageNum = 0;
this.responses = [];
this.numRequired = -1;
this.segment = 0;
this.segmentID = null;
};
YAHOO.lang.extend(TestShell.PageGroup, TestShell.PageContent);
TestShell.PageGroup.prototype.getContentUrl = function()
{
var urlBuilder = [];
urlBuilder.push(TDS.baseUrl);
urlBuilder.push('Pages/API/Content.axd/loadGroup');
urlBuilder.push('?groupID=' + this.id);
urlBuilder.push('&page=' + this.pageNum);
urlBuilder.push('&datecreated=' + this.responses[0].dateCreated);
urlBuilder.push('&new=' + this.isNew());
urlBuilder.push('&attempt=' + this.getRequestCount());
return urlBuilder.join('');
};
TestShell.PageGroup.prototype.isNew = function()
{
return Util.Array.some(this.responses, function(r) {
return r.prefetched;
}, this);
};
TestShell.PageGroup.prototype.isEnabled = function()
{
var segment = this.getSegment();
if (segment && segment.isLocked()) {
return false;
}
return TestShell.PageGroup.superclass.isEnabled.call(this);
};
TestShell.PageGroup.prototype.isCompleted = function()
{
var numValid = 0;
for (var i = 0; i < this.responses.length; i++) {
var response = this.responses[i];
if (response.isSelected && response.isValid) {
numValid++;
}
else if (response.isRequired) {
return false;
}
}
var completed = (numValid >= this.numRequired);
if (completed && numValid === 0 && this.requiresVisit()) {
return this.isVisited();
}
return completed;
};
TestShell.PageGroup.prototype.isVisited = function() {
for (var i = 0; i < this.responses.length; i++) {
if (this.responses[i].isAnswered()) return true;
}
if (this.requiresVisit()) {
var nextPages = this.getNextPages();
for (var i = 0; i < nextPages.length; i++) {
var page = nextPages[i];
if (page instanceof TestShell.PageGroup) {
if (page.getNumAnswered() > 0) {
return true;
}
}
}
}
return TestShell.PageGroup.superclass.isVisited.call(this);
};
TestShell.PageGroup.prototype.getLabelGroup = function()
{
if (!TestShell.Config.showSegmentLabels) return null;
var segment = this.getSegment();
if (segment == null) return null;
var id = 'segment_' + segment.getSafeId();
return { id: id, label: segment.getLabel() };
};
TestShell.PageGroup.prototype.getLabel = function(showMarked)
{
var defaultAccProps = Accommodations.Manager.getDefaultProperties();
if (defaultAccProps && defaultAccProps.getNavigationDropdown() == 'TDS_NavTk')
{
return this.getLabelTask(showMarked);
}
var firstRes = this.responses[0];
var lastRes = this.responses[this.responses.length - 1];
var text = firstRes.position;
if (firstRes != lastRes)
{
text += ' - ' + lastRes.position;
}
if (showMarked && this.hasMark())
{
text += ' (' + Messages.get('TDSShellObjectsJS.Label.Marked') + ')';
}
return text;
};
TestShell.PageGroup.prototype.getLabelTask = function(showMarked)
{
var text = Messages.getAlt('TDSShellObjectsJS.Label.TaskLabel', 'Task ') + this.pageNum;
if (showMarked && this.hasMark())
{
text += ' (' + Messages.get('TDSShellObjectsJS.Label.Marked') + ')';
}
return text;
};
TestShell.PageGroup.prototype.toString = function()
{
return (this.pageNum > 0) ? this.pageNum.toString() : '';
};
TestShell.PageGroup.prototype.getNumAnswered = function()
{
var numAnswered = 0;
for (var i = 0; i < this.responses.length; i++)
{
var response = this.responses[i];
if (response.isSelected && response.isValid)
{
numAnswered++;
}
}
return numAnswered;
};
TestShell.PageGroup.prototype.getResponse = function(position)
{
return Util.Array.find(this.responses, function(response)
{
return response.position == position;
});
};
TestShell.PageGroup.prototype.hasMark = function()
{
var markedResponse = Util.Array.find(this.responses, function(response)
{
return response.mark;
});
return (markedResponse != null);
};
TestShell.PageGroup.prototype.getSegment = function()
{
return TestShell.SegmentManager.get(this.segmentID);
};
TestShell.PageGroup.prototype.getCoverPageInfo = function()
{
var contentPage = this.getContentPage();
if (contentPage == null) return null;
var items = contentPage.getItems();
if (items == null || items.length == 0) return null;
var contentItem = items[0];
if (contentItem.coverPage == null) return null;
var bankKey = contentItem.coverPage.bankKey;
var itemKey = contentItem.coverPage.itemKey;
var id = 'I-' + bankKey + '-' + itemKey;
return {
bankKey: bankKey,
itemKey: itemKey,
id: id
};
};
TestShell.PageGroup.prototype.hasCoverPage = function()
{
var cpInfo = this.getCoverPageInfo();
return (cpInfo != null);
};
TestShell.PageGroup.prototype.getCoverPage = function()
{
var cpInfo = this.getCoverPageInfo();
if (cpInfo == null) return null;
return TestShell.CoverPages.get(cpInfo.id);
};
TestShell.PageGroup.prototype.getInfo = function()
{
var responsesRequired = 0;
var responsesValid = 0;
for (var i = 0; i < this.responses.length; i++)
{
var response = this.responses[i];
if (response.isRequired) responsesRequired++;
if (response.isValid) responsesValid++;
}
return {
itemCount: this.responses.length,
groupRequired: this.numRequired,
itemsRequired: responsesRequired,
itemsAnswered: responsesValid
};
};

// FILE: testshell_PageResource.js (fa7e01db) 7/22/2014 5:26:22 PM

TestShell.PageResource = function(bankKey, itemKey, segmentID, label)
{
this._bankKey = bankKey;
this._itemKey = itemKey;
this._segmentID = segmentID;
this._label = label;
var id = 'I-' + bankKey + '-' + itemKey;
TestShell.PageResource.superclass.constructor.call(this, id);
};
YAHOO.lang.extend(TestShell.PageResource, TestShell.PageContent);
TestShell.PageResource.prototype.getContentUrl = function()
{
var urlBuilder = [];
urlBuilder.push(TDS.baseUrl);
urlBuilder.push('Pages/API/Content.axd/loadResource');
urlBuilder.push('?bankKey=' + this._bankKey);
urlBuilder.push('&itemKey=' + this._itemKey);
urlBuilder.push('&segmentID=' + this._segmentID);
return urlBuilder.join('');
};
TestShell.PageResource.prototype.getLabel = function() { return this._label; };

// FILE: testshell_PageReview.js (007e69a5) 7/22/2014 5:26:22 PM

TestShell.PageReview = function(segment)
{
TestShell.PageReview.superclass.constructor.call(this, segment.getSafeId());
this._segment = segment;
this._divReview = null;
this._confirmed = false;
this.init();
};
YAHOO.lang.extend(TestShell.PageReview, TestShell.Page);
TestShell.PageReview.prototype.init = function()
{
var divReviews = YUD.get('reviews');
this._divReview = HTML.DIV({ className: 'review' });
this._divReview.innerHTML = YUD.get('template_review').innerHTML;
TDS.Messages.Template.processLanguage(this._divReview);
divReviews.appendChild(this._divReview);
this.hide();
};
TestShell.PageReview.prototype.getSegment = function() { return this._segment; };
TestShell.PageReview.prototype.getLabel = function() { return 'Review'; };
TestShell.PageReview.prototype.isVisible = function()
{
var groups = this._segment.getGroups();
var anyGroupEnabled = Util.Array.some(groups, function(group) { return group.isEnabled(); });
if (!anyGroupEnabled) return false;
return TestShell.PageReview.superclass.isVisible.call(this);
};
TestShell.PageReview.prototype.hide = function()
{
ContentManager.Renderer.hide(this._divReview);
TestShell.PageManager.Events.fire('onHide', this);
};
TestShell.PageReview.prototype.show = function()
{
var divList = this._divReview.getElementsByTagName('ul')[0];
divList.innerHTML = '';
var groups = this._segment.getGroups();
groups = Util.Array.filter(groups, function(group) { return group.isEnabled(); });
Util.Array.each(groups, function(group)
{
var btnReview = HTML.A({ href: '#' }, '' + group.getLabel());
if (group instanceof TestShell.PageGroup && group.hasMark())
{
YUD.addClass(btnReview, 'marked');
}
YUE.on(btnReview, 'click', function()
{
TestShell.UI.Nodes.ddlNavigation.value = group.id;
TestShell.Navigation.change();
});
divList.appendChild(HTML.LI(null, btnReview));
});
ContentManager.Renderer.show(this._divReview);
TestShell.PageManager.Events.fire('onShow', this);
};
TestShell.PageReview.prototype.setConfirmed = function() { this._confirmed = true; };
TestShell.PageReview.prototype.isConfirmed = function() { return this._confirmed; };
TestShell.PageReview.prototype.isCompleted = function()
{
if (TDS.getPref('testshell.segments.disableReviewConfirm')) return true;
if (this.isConfirmed()) return true;
var segments = TestShell.SegmentManager.getSegments();
var segmentCurrIdx = segments.indexOf(this._segment);
var segmentsNext = Util.Array.slice(segments, segmentCurrIdx + 1);
for (var i = 0; i < segmentsNext.length; i++)
{
var segmentNext = segmentsNext[i];
var groups = segmentNext.getGroups();
for (var j = 0; j < groups.length; j++)
{
var group = groups[j];
if (group.isVisited()) return true;
}
}
return false;
};

// FILE: testshell_PageManager.js (9534c9c5) 7/22/2014 5:26:22 PM

TestShell.PageManager = {};
TestShell.PageManager.Events = new Util.EventManager(TestShell.PageManager);
TestShell.PageManager._initializing = true;
TestShell.PageManager._pageList = [];
TestShell.PageManager._pageLookup = {};
TestShell.PageManager._current = null;
TestShell.PageManager.getPages = function(isEnabled) {
if (isEnabled) {
return Util.Array.filter(this._pageList, function(page) {
return page.isEnabled();
});
}
return this._pageList.slice(0);
};
TestShell.PageManager.hasPages = function() {
return (this._pageList.length > 0);
};
TestShell.PageManager.getGroups = function(isEnabled) {
var pages = this.getPages(isEnabled);
var groups = [];
for (var i = 0; i < pages.length; i++) {
var page = pages[i];
if (page instanceof TestShell.PageGroup) {
groups.push(page);
}
}
return groups;
};
TestShell.PageManager.setCurrent = function(page) {
if (this._current != null) {
TestShell.PageManager.History.push(this._current);
}
Util.log('TestShell.PageManager.setCurrent: ' + (page == null ? 'NULL' : page.id));
this._current = page;
};
TestShell.PageManager.getCurrent = function() {
return this._current;
};
TestShell.PageManager.get = function(id) {
return this._pageLookup[id];
};
TestShell.PageManager.getResponse = function(position) {
var groups = this.getGroups();
for (var i = 0; i < groups.length; i++) {
var group = groups[i];
var response = group.getResponse(position);
if (response != null) {
return response;
}
}
return null;
};
TestShell.PageManager.getFirst = function(isEnabled) {
var pages = this.getPages(isEnabled);
return (pages.length > 0) ? pages[0] : null;
};
TestShell.PageManager.getFirstGroup = function(isEnabled) {
var groups = this.getGroups(isEnabled);
return (groups.length > 0) ? groups[0] : null;
};
TestShell.PageManager.getLast = function(isEnabled) {
var pages = this.getPages(isEnabled);
return (pages.length > 0) ? pages[pages.length - 1] : null;
};
TestShell.PageManager.getLastGroup = function(isEnabled) {
var groups = this.getGroups(isEnabled);
return (groups.length > 0) ? groups[groups.length - 1] : null;
};
TestShell.PageManager.isFirst = function() {
var page = this.getCurrent();
var firstPage = this.getFirst(true);
return (page != null && firstPage != null && page == firstPage);
};
TestShell.PageManager.isLast = function() {
var page = this.getCurrent();
var lastPage = this.getLast(true);
return (page != null && lastPage != null && page == lastPage);
};
TestShell.PageManager.getPrevious = function() {
var page = this.getCurrent();
if (page) {
var pages = this.getPages(true);
var idx = pages.indexOf(page);
if (idx != -1) {
return pages[idx - 1];
}
}
return null;
};
TestShell.PageManager.getNext = function() {
var page = this.getCurrent();
if (page) {
var pages = this.getPages(true);
var idx = pages.indexOf(page);
if (idx != -1) {
return pages[idx + 1];
}
}
return null;
};
TestShell.PageManager.moveBack = function() {
var backPage = this.getPrevious();
if (backPage) {
this.setCurrent(backPage);
return true;
}
return false;
};
TestShell.PageManager.moveNext = function() {
var nextPage = this.getNext();
if (nextPage) {
TestShell.PageManager.setCurrent(nextPage);
return true;
}
return false;
};
TestShell.PageManager.contains = function(page) {
return (this._pageList.indexOf(page) != -1);
};
TestShell.PageManager.addPage = function(newPage) {
this._pageLookup[newPage.id] = newPage;
this._pageList.push(newPage);
newPage.updateNavigationLabel();
};
TestShell.PageManager.insertPage = function(newPage, refPage) {
this._pageLookup[newPage.id] = newPage;
var refIdx = this._pageList.indexOf(refPage);
Util.Array.insertAt(this._pageList, newPage, refIdx);
newPage.updateNavigationLabel(refPage);
};
TestShell.PageManager._addGroup = function(group) {
var lastGroup = this.getLastGroup();
var segmentReview = null;
if (lastGroup && lastGroup.getSegment() != null && lastGroup.getSegment() != group.getSegment()) {
var segment = lastGroup.getSegment();
if (segment.showItemReview()) {
segmentReview = this.addReview(lastGroup.getSegment());
}
}
var foundExistingGroup = Util.Array.find(this.getGroups(), function(existingGroup) {
return group.id == existingGroup.id;
});
if (foundExistingGroup != null) {
return;
}
this.addPage(group);
if (this._initializing) {
if (TestShell.Config.reviewPage > 0) {
if (TestShell.Config.reviewPage == group.pageNum) {
this.setCurrent(group);
}
} else if (TestShell.Config.startPosition > 0) {
if (group.getResponse(TestShell.Config.startPosition) != null) {
this.setCurrent(group);
}
}
}
if (this.getCurrent() == null) {
var useGroup = false;
var groupInfo = group.getInfo();
if (!this._initializing) {
useGroup = true;
}
else if (!group.isCompleted()) {
useGroup = true;
}
else if (groupInfo.groupRequired == 0 && groupInfo.itemCount != groupInfo.itemsAnswered) {
useGroup = true;
}
if (segmentReview != null) {
this.setCurrent(segmentReview);
} else if (useGroup) {
this.setCurrent(group);
}
}
if (!this._initializing || !group.isCompleted()) {
group.requestContent();
}
};
TestShell.PageManager.addGroups = function(groups) {
Util.Array.each(groups, this._addGroup, this);
if (this._initializing) {
if (this.getCurrent() == null) {
this.setCurrent(groups[groups.length - 1]);
}
this._initializing = false;
} else {
if (this.getCurrent() == null) {
this.setCurrent(groups[0]);
}
}
if (TestShell.testLengthMet) {
var lastGroup = this.getLastGroup();
var lastSegment = lastGroup.getSegment();
if (lastSegment && lastSegment.showItemReview()) {
this.addReview(lastGroup.getSegment());
}
}
TestShell.Navigation.requestPage();
};
TestShell.PageManager.addReview = function(segment) {
var pageReview = new TestShell.PageReview(segment);
this.addPage(pageReview);
return pageReview;
};
TestShell.PageManager.clearCurrent = function() {
TestShell.PageManager.setCurrent(null);
};
TestShell.PageManager.swapCurrent = function(coverPage) {
TestShell.PageManager.clearCurrent();
TestShell.PageManager.History.pop();
TestShell.PageManager.setCurrent(coverPage);
TestShell.Navigation.requestPage();
};
TestShell.PageManager.isCompleted = function(onlyEnabled, onlyVisited) {
var groups = this.getGroups(onlyEnabled);
var notCompletedGroup = Util.Array.find(groups, function(group) {
if (onlyVisited && !group.isVisited()) {
return false;
}
return (!group.isCompleted());
});
return (notCompletedGroup == null);
};
TestShell.PageManager.History = new Util.Structs.Stack();
TestShell.ResponseManager.Events.onGroups.subscribe(function(groups) {
TestShell.PageManager.addGroups(groups);
});
TestShell.PageManager.getAccommodations = function(page) {
if (page == null) {
return null;
}
if (page instanceof TestShell.PageContent) {
var contentPage = page.getContentPage();
if (contentPage) {
return contentPage.getAccommodations();
}
} else {
var pageSegment = (typeof(page.getSegment) == 'function') ? page.getSegment() : null;
if (pageSegment) {
return Accommodations.Manager.get(pageSegment.getId());
}
}
return Accommodations.Manager.getCurrent();
};
TestShell.PageManager.updateAccommodations = function(currentPage) {
var previousPage = TestShell.PageManager.History.peek();
var currentAccs = TestShell.PageManager.getAccommodations(currentPage);
var previousAccs = TestShell.PageManager.getAccommodations(previousPage);
if (currentAccs == previousAccs) {
return;
}
Accommodations.Manager.updateCSS(document.body, currentAccs.getId());
};
TestShell.PageManager.Events.subscribe('onShow', function(page) {
TestShell.idleTimer.waitMins = TestShell.Config.interfaceTimeout;
TestShell.idleTimer.reset();
TestShell.autoSaveStart();
TestShell.PageManager.updateAccommodations(page);
var navEl = YUD.get('foot') || YUD.get('navigation');
var isPageContent = (page instanceof TestShell.PageContent);
if (navEl) {
navEl.className = '';
YUD.addClass(navEl, isPageContent ? 'Content_Yes' : 'Content_No');
}
if (isPageContent) {
var contentPage = page.getContentPage();
if (contentPage) {
page.showSoundCue();
contentPage.autoPlayQueue.start();
if (navEl) {
YUD.addClass(navEl, 'Layout_' + contentPage.layout);
var contentPassage = contentPage.getPassage();
if (contentPassage && !contentPassage.isEmpty()) {
YUD.addClass(navEl, 'Passage_Yes');
} else {
YUD.addClass(navEl, 'Passage_No');
}
}
}
}
TestShell.UI.showSave(page);
TestShell.Tools.updateShowing();
var navContainer = YUD.get('navigationContainer');
if (navContainer != null) {
if (page.hasLabel()) {
YUD.setStyle(navContainer, 'display', 'block');
} else {
YUD.setStyle(navContainer, 'display', 'none');
}
}
setTimeout(function() {
if (isPageContent && ContentManager.enableARIA) {
var contentFocuser = YUD.get('contentsFocuser');
if (contentFocuser) {
contentFocuser.innerHTML = page.getScreenReaderText();
contentFocuser.focus();
}
} else {
var contentPage = ContentManager.getCurrentPage();
if (contentPage) {
Util.Dom.focus(contentPage.getWin());
}
if (Util.Browser.isMac()) {
Util.Dom.focus(top);
}
}
}, 1);
});
TestShell.PageManager.Events.subscribe('onHide', function(page) {
if (page instanceof TestShell.PageContent) {
page.hideSoundCue();
}
});

// FILE: testshell_ContentLoader.js (ebe21d89) 7/22/2014 5:26:22 PM

TestShell.ContentLoader =
{
_requests: []
};
TestShell.ContentLoader.lookupGroup = function(request)
{
var groupID = request.getId();
var group = TestShell.PageManager.get(groupID);
return group;
};
TestShell.ContentLoader._xhrManager = new TDS.XhrManager(120000, 2);
TestShell.ContentLoader.Events = new Util.EventManager();
TestShell.ContentLoader._createRequest = function(group)
{
var url = group.getContentUrl();
var request = this._xhrManager.createRequest(group.id, url, 'POST', null, this._processResponse, this);
request.setArgs(
{
showProgress: false,
showDialog: true,
allowRetry: true,
forceLogout: true
});
return request;
};
TestShell.ContentLoader.isRequesting = function(group)
{
return Util.Array.contains(this._requests, group);
};
TestShell.ContentLoader.request = function(group)
{
if (this.isRequesting(group)) return false;
this._requests.push(group);
var request = TestShell.ContentLoader._createRequest(group);
var delay = (this._requests.length > 1) ? (this._requests.length * 1000) : 0;
YAHOO.lang.later(delay, this, function()
{
this._xhrManager.sendRequest(request);
this.Events.fire('onRequest', group);
});
return true;
};
TestShell.ContentLoader._processResponse = function(request)
{
var group = TestShell.ContentLoader.lookupGroup(request);
if (group == null) return;
Util.Array.remove(this._requests, group);
var xmlDoc = request.getResponseXml();
if (xmlDoc != null)
{
this.Events.fire('onSuccess', group, request);
this._processXml(group, xmlDoc);
}
else
{
this.Events.fire('onFailure', group, request);
}
};
TestShell.ContentLoader._processXml = function(group, xmlDoc)
{
var contentPage = group.getContentPage();
if (contentPage)
{
try
{
ContentManager.removePage(contentPage);
}
catch (e) { }
}
var xmlContents = ContentManager.Xml.create(xmlDoc);
contentPage = ContentManager.createPage(xmlContents[0]);
contentPage.render();
};
TestShell.ContentLoader._xhrManager.Events.subscribe('onError', function(request, errorMessage, retriable, logout)
{
var group = TestShell.ContentLoader.lookupGroup(request);
var currentGroup = TestShell.PageManager.getCurrent();
if (currentGroup != null && currentGroup != group) return;
TestShell.UI.hideLoading();
if (retriable)
{
errorMessage += ' ' + Messages.getAlt('Messages.Label.XHRError', 'Select Yes to try again or No to logout.');
TDS.Dialog.showPrompt(errorMessage,
function()
{
TestShell.Navigation.requestPage();
},
function()
{
if (logout) TestShell.redirectLogin();
});
}
else
{
TDS.Dialog.showWarning(errorMessage, function()
{
if (logout) TestShell.redirectLogin();
});
}
});

// FILE: testshell_SegmentManager.js (a8d8ad8b) 7/22/2014 5:26:22 PM

TestShell.Segment = function(id, position, label, isPermeable, entryApproval, exitApproval, itemReview, updatePermeable)
{
this._id = id;
this._position = position;
this._label = label;
this._isPermeable = isPermeable;
this._entryApproval = entryApproval;
this._exitApproval = exitApproval;
this._showItemReview = itemReview;
this._updatePermeable = YAHOO.lang.isNumber(updatePermeable) ? updatePermeable : isPermeable;
this._requireEntryApproval = (entryApproval > TestShell.Segment.Approval.Never);
this._requireExitApproval = (exitApproval > TestShell.Segment.Approval.Never);
this._inside = false;
};
TestShell.Segment.Approval =
{
Never: 0,
Always: 1,
FirstTime: 2
};
TestShell.Segment.prototype.enter = function()
{
this._inside = true;
this._requireEntryApproval = false;
if (this._exitApproval == TestShell.Segment.Approval.Always)
{
this._requireExitApproval = true;
}
this._isPermeable = this._updatePermeable;
TestShell.SegmentManager.Events.fire('onTransitionEnter', this);
};
TestShell.Segment.prototype.exit = function()
{
this._inside = false;
this._requireExitApproval = false;
if (this._entryApproval == TestShell.Segment.Approval.Always)
{
this._requireEntryApproval = true;
}
TestShell.SegmentManager.Events.fire('onTransitionExit', this);
};
TestShell.Segment.prototype.isInside = function() { return this._inside; };
TestShell.Segment.prototype.getId = function() { return this._id; };
TestShell.Segment.prototype.getPosition = function() { return this._position; };
TestShell.Segment.prototype.getLabel = function() { return this._label; };
TestShell.Segment.prototype.isPermeable = function() { return this._isPermeable > 0; };
TestShell.Segment.prototype.showItemReview = function() { return this._showItemReview; };
TestShell.Segment.prototype.getSafeId = function()
{
var id = this.getId();
id = id.replace( /\s+/g , '');
id = id.replace( /[^A-Za-z0-9]+/gi , '');
return id;
};
TestShell.Segment.prototype.requireEntryApproval = function() { return this._requireEntryApproval; };
TestShell.Segment.prototype.requireExitApproval = function() { return this._requireExitApproval; };
TestShell.Segment.prototype.toString = function() { return this._id; };
TestShell.Segment.prototype.getGroups = function()
{
var testGroups = TestShell.PageManager.getGroups();
return Util.Array.filter(testGroups, function(group)
{
return (this._id == group.segmentID);
}, this);
};
TestShell.Segment.prototype.hasGroups = function()
{
return (this.getGroups().length > 0);
};
TestShell.Segment.prototype.getFirstGroup = function()
{
var groups = this.getGroups();
return (groups.length > 0) ? groups[0] : null;
};
TestShell.Segment.prototype.getLastGroup = function()
{
var groups = this.getGroups();
return (groups.length > 0) ? groups[groups.length - 1] : null;
};
TestShell.Segment.prototype.isCompleted = function()
{
var groups = this.getGroups();
return Util.Array.every(groups, function(group)
{
return group.isCompleted();
});
};
TestShell.Segment.prototype.isLengthMet = function()
{
if (TestShell.testLengthMet) return true;
var nextSegment = TestShell.SegmentManager.getByPosition(this._position);
if (nextSegment)
{
return (nextSegment.hasGroups());
}
return false;
};
TestShell.Segment.prototype.isFinished = function()
{
return (this.isLengthMet() && this.isCompleted());
};
TestShell.Segment.prototype.isLocked = function()
{
return (!this.isInside() && !this.isPermeable() && this.isFinished());
};
TestShell.Segment.prototype.getAccommodations = function() {
return Accommodations.Manager.get(this._id);
};
TestShell.Segment.prototype.getAccommodationProperties = function()
{
return Accommodations.Manager.getProperties(this._id);
};
TestShell.SegmentManager =
{
_segments: new Util.Structs.Map(),
_segmentPositions: new Util.Structs.Map(),
_currentSegment: null,
_enteringSegment: null,
_exitingSegment: null,
_transitionState: null,
_approvalState: null,
_pollTimer: null,
_checkApprovalTimestamp: null,
Events: new Util.EventManager()
};
TestShell.SegmentManager.TransitionState =
{
Begin: 1,
Exiting: 2,
Entering: 3,
End: 4
};
TestShell.SegmentManager.XhrState =
{
None: 1,
Request: 2,
Waiting: 3,
Checking: 4,
Error: 5
};
TestShell.SegmentManager.ApprovalStatus =
{
Waiting: 0,
Approved: 1,
Denied: 2,
Logout: 3
};
TestShell.SegmentManager.init = function()
{
Util.Array.each(window.tdsSegments, function(tdsSegment)
{
var segment = new TestShell.Segment(
tdsSegment.id, tdsSegment.position, tdsSegment.label, tdsSegment.isPermeable,
tdsSegment.entryApproval, tdsSegment.exitApproval, tdsSegment.itemReview, tdsSegment.updatePermeable);
this._segments.set(tdsSegment.id, segment);
this._segmentPositions.set(tdsSegment.position, segment);
}, this);
this._transitionState = TestShell.SegmentManager.TransitionState.End;
this._approvalState = TestShell.SegmentManager.XhrState.None;
this._poll();
};
TestShell.SegmentManager.getSegments = function()
{
return this._segments.getValues();
};
TestShell.SegmentManager.get = function(id)
{
if (YAHOO.lang.isObject(id)) return id;
return this._segments.get(id);
};
TestShell.SegmentManager.getByPosition = function(position)
{
return this._segmentPositions.get(position);
};
TestShell.SegmentManager.getCurrent = function() { return this._currentSegment; };
TestShell.SegmentManager.getTransitionState = function() { return this._transitionState; };
TestShell.SegmentManager._setTransitionState = function(newState)
{
if (this._transitionState != newState)
{
this._transitionState = newState;
this.Events.fire('onTransitionChange', newState);
}
};
TestShell.SegmentManager.getXhrState = function() { return this._approvalState; };
TestShell.SegmentManager._setXhrState = function(newState)
{
if (this._approvalState != newState)
{
this._approvalState = newState;
this.Events.fire('onApprovalChange', newState);
}
};
TestShell.SegmentManager._getCheckApprovalTimestamp = function() { return this._checkApprovalTimestamp; };
TestShell.SegmentManager._setCheckApprovalTimestamp = function() { this._checkApprovalTimestamp = Util.Date.now(); };
TestShell.SegmentManager.transition = function(enterSegment)
{
if (this.getTransitionState() != TestShell.SegmentManager.TransitionState.End) return false;
enterSegment = this.get(enterSegment);
if (enterSegment == null) return true;
var currentSegment = this.getCurrent();
if (currentSegment == enterSegment) return true;
this._setTransitionState(TestShell.SegmentManager.TransitionState.Begin);
this._currentSegment = null;
this._exitingSegment = currentSegment;
this._enteringSegment = enterSegment;
this._process();
return (this.getTransitionState() == TestShell.SegmentManager.TransitionState.End);
};
TestShell.SegmentManager._poll = function()
{
if (this._pollTimer) this._pollTimer.cancel();
this._process();
this._pollTimer = YAHOO.lang.later(500, this, this._poll);
};
TestShell.SegmentManager._process = function()
{
if (this.getTransitionState() == TestShell.SegmentManager.TransitionState.End) return;
if (this.getXhrState() == TestShell.SegmentManager.XhrState.Request ||
this.getXhrState() == TestShell.SegmentManager.XhrState.Checking) return;
if (TestShell.ResponseManager.getPendingResponses().length > 0 ||
TestShell.ResponseManager.getOutgoingResponses().length > 0) return;
if (TestShell.ContentLoader._xhrManager.getOutstandingCount() > 0) return;
if (this.getXhrState() == TestShell.SegmentManager.XhrState.Waiting)
{
var checkTimestamp = this._getCheckApprovalTimestamp();
var currentTimestamp = Util.Date.now();
var poll = (currentTimestamp - checkTimestamp);
if (poll > 5000)
{
this._checkApproval();
}
return;
}
if (this.getXhrState() == TestShell.SegmentManager.XhrState.None &&
this.getTransitionState() == TestShell.SegmentManager.TransitionState.Begin)
{
if (this._exitingSegment)
{
this._requestExit(this._exitingSegment);
}
}
if (this.getXhrState() == TestShell.SegmentManager.XhrState.None &&
(this.getTransitionState() == TestShell.SegmentManager.TransitionState.Begin ||
this.getTransitionState() == TestShell.SegmentManager.TransitionState.Exiting))
{
if (this._exitingSegment)
{
this._exitingSegment.exit();
this._exitingSegment = null;
}
this._requestEntry(this._enteringSegment);
}
if (this.getXhrState() == TestShell.SegmentManager.XhrState.None &&
this.getTransitionState() == TestShell.SegmentManager.TransitionState.Entering)
{
if (this._enteringSegment)
{
this._enteringSegment.enter();
this._currentSegment = this._enteringSegment;
this._enteringSegment = null;
}
this._setTransitionState(TestShell.SegmentManager.TransitionState.End);
TestShell.Navigation.requestPage();
}
};
TestShell.SegmentManager._requestExit = function(segment)
{
this._setTransitionState(TestShell.SegmentManager.TransitionState.Exiting);
if (segment.requireExitApproval())
{
this._setXhrState(TestShell.SegmentManager.XhrState.Request);
var request = { position: segment.getPosition(), approval: 'exit' };
TestShell.xhrManager.waitForSegmentApproval(request, function(obj)
{
TestShell.SegmentManager._setCheckApprovalTimestamp();
TestShell.SegmentManager._setXhrState(TestShell.SegmentManager.XhrState.Waiting);
});
return;
}
};
TestShell.SegmentManager._requestEntry = function(segment)
{
this._setTransitionState(TestShell.SegmentManager.TransitionState.Entering);
if (segment.requireEntryApproval())
{
this._setXhrState(TestShell.SegmentManager.XhrState.Request);
var request = { position: segment.getPosition(), approval: 'entry' };
TestShell.xhrManager.waitForSegmentApproval(request, function(obj)
{
TestShell.SegmentManager._setCheckApprovalTimestamp();
TestShell.SegmentManager._setXhrState(TestShell.SegmentManager.XhrState.Waiting);
});
return;
}
};
TestShell.SegmentManager._checkApproval = function()
{
this._setXhrState(TestShell.SegmentManager.XhrState.Request);
TestShell.xhrManager.checkForSegmentApproval(function(approval)
{
TestShell.SegmentManager._setCheckApprovalTimestamp();
if (approval == null)
{
TestShell.SegmentManager._setXhrState(TestShell.SegmentManager.XhrState.Error);
}
else if (approval.status == TestShell.SegmentManager.ApprovalStatus.Denied)
{
TestShell.SegmentManager.deniedApproval(approval);
}
else if (approval.status == TestShell.SegmentManager.ApprovalStatus.Approved)
{
TestShell.SegmentManager._setXhrState(TestShell.SegmentManager.XhrState.None);
}
else
{
TestShell.SegmentManager._setXhrState(TestShell.SegmentManager.XhrState.Waiting);
}
});
};
TestShell.SegmentManager.deniedApproval = function(approval)
{
TestShell.SegmentManager._setXhrState(TestShell.SegmentManager.XhrState.Error);
var deniedMessage;
if (approval.comment != null && approval.comment.length > 0) {
deniedMessage = approval.comment;
} else {
deniedMessage = Messages.get('TestShell.Segment.Denied');
}
TDS.Dialog.showAlert(deniedMessage, function() {
TDS.logout();
});
};
TestShell.SegmentManager.checkPermeability = function(segment)
{
if (segment.isLocked());
{
var groups = segment.getGroups();
Util.Array.each(groups, function(group)
{
group.updateNavigationLabel();
});
}
};
TestShell.SegmentManager.Events.subscribe('onTransitionExit', function(segment)
{
TestShell.SegmentManager.checkPermeability(segment);
if (TestShell.xhrManager.inProgress('exitSegment'))
{
TestShell.xhrManager.abort('exitSegment');
}
var request = { position: segment.getPosition() };
TestShell.xhrManager.exitSegment(request, function(obj) {});
});
TestShell.SegmentManager.getTransitionName = function(state)
{
switch (state)
{
case TestShell.SegmentManager.TransitionState.Begin: return 'begin';
case TestShell.SegmentManager.TransitionState.Exiting: return 'exiting';
case TestShell.SegmentManager.TransitionState.Entering: return 'entering';
case TestShell.SegmentManager.TransitionState.End: return 'end';
}
return null;
};
TestShell.SegmentManager.getApprovalName = function(state)
{
switch (state)
{
case TestShell.SegmentManager.XhrState.None: return 'none';
case TestShell.SegmentManager.XhrState.Request: return 'request';
case TestShell.SegmentManager.XhrState.Waiting: return 'waiting';
case TestShell.SegmentManager.XhrState.Checking: return 'checking';
}
return null;
};
TestShell.SegmentManager.Events.subscribe('onTransitionChange', function(state)
{
var stateName = TestShell.SegmentManager.getTransitionName(state);
Util.log('SEGMENT TRANSITION: ' + stateName);
});
TestShell.SegmentManager.Events.subscribe('onApprovalChange', function(state)
{
var stateName = TestShell.SegmentManager.getApprovalName(state);
Util.log('SEGMENT APPROVAL: ' + stateName);
});
TestShell.SegmentManager.getDebug = function()
{
var segments = TestShell.SegmentManager.getSegments();
var debugSegments = [];
var getApprovalFormatted = function(approval)
{
switch (approval)
{
case TestShell.Segment.Approval.Never: return 'never';
case TestShell.Segment.Approval.Always: return 'always';
case TestShell.Segment.Approval.FirstTime: return 'first';
}
return null;
};
Util.Array.each(segments, function(segment)
{
var debugSegment =
{
'id': segment.getId(),
'position': segment.getPosition(),
'current': (TestShell.SegmentManager._currentSegment == segment),
'entering': (TestShell.SegmentManager._enteringSegment == segment),
'exiting': (TestShell.SegmentManager._exitingSegment == segment),
'item review': segment.showItemReview(),
'permeable': segment.isPermeable(),
'entry approval': getApprovalFormatted(segment._entryApproval),
'entry required': segment.requireEntryApproval(),
'exit approval': getApprovalFormatted(segment._exitApproval),
'exit required': segment.requireExitApproval(),
'groups': segment.hasGroups(),
'completed': segment.isCompleted(),
'length met': segment.isLengthMet(),
'finished': segment.isFinished(),
'locked': segment.isLocked(),
'inside': segment.isInside()
};
debugSegments.push(debugSegment);
});
return debugSegments;
};
TestShell.SegmentManager.writeDebug = function()
{
var debugSegments = TestShell.SegmentManager.getDebug();
console.table(debugSegments);
};

// FILE: testshell_Frame.js (c3b2739b) 7/22/2014 5:26:22 PM

TestShell.Frame =
{
getWriting: function()
{
var contentPage = ContentManager.getCurrentPage();
return (contentPage && contentPage.writing) ? contentPage.writing : null;
},
getBody: function()
{
var contentPage = ContentManager.getCurrentPage();
return (contentPage) ? contentPage.getBody() : null;
}
};

// FILE: testshell_Navigation.js (88acc14a) 7/22/2014 5:26:22 PM

TestShell.Navigation = {};
TestShell.Navigation.State =
{
Initializing: 'init',
Change: 'change',
Back: 'back',
Next: 'next',
Viewing: 'view'
};
TestShell.Navigation._currentState = TestShell.Navigation.State.Initializing;
TestShell.Navigation.getState = function() { return this._currentState; };
TestShell.Navigation.setState = function(state) { this._currentState = state; };
TestShell.Navigation.createWorkflow = function(fromGroup, toGroup)
{
var taskWorkflow = new Util.TaskWorkflow();
taskWorkflow.add(TestShell.Validation.checkAudioPlaying);
taskWorkflow.add(TestShell.Validation.checkGrid);
taskWorkflow.add(TestShell.Validation.checkDirtyResponses);
taskWorkflow.add(TestShell.Validation.checkAudioRecording);
taskWorkflow.add(TestShell.Validation.checkRecorderQuality);
taskWorkflow.add(TestShell.Validation.checkIfPromptSelected);
taskWorkflow.add(TestShell.Validation.checkSimulatorPlaying, 'SimulatorPlayingWhileNavigating');
var transition = { from: fromGroup, to: toGroup };
taskWorkflow.add(TestShell.Validation.checkSegment, transition);
if (TDS.isProxyLogin)
{
taskWorkflow.add(TestShell.save, TestShell, true);
taskWorkflow.add(TestShell.Validation.checkOptionalUnanswered);
}
return taskWorkflow;
};
TestShell.Navigation.change = function()
{
var currentGroup = TestShell.PageManager.getCurrent();
var selectedGroup = TestShell.PageManager.get(TestShell.UI.Nodes.ddlNavigation.value);
var taskWorkflow = TestShell.Navigation.createWorkflow(currentGroup, selectedGroup);
taskWorkflow.start(this._changeInternal, this);
};
TestShell.Navigation._changeInternal = function()
{
TestShell.save();
var currentGroup = TestShell.PageManager.getCurrent();
var groupID = TestShell.UI.Nodes.ddlNavigation.value;
var selectedGroup = TestShell.PageManager.get(groupID);
if (!selectedGroup.isVisible())
{
this.update();
this.reset();
TestShell.UI.showWarning(ErrorCodes.get('NextUnanswered'));
Util.log('TestShell.changePage (FAIL: not visible): ' + selectedGroup.id);
return;
}
else
{
Util.log('TestShell.changePage: ' + selectedGroup.id);
}
TestShell.Navigation.setState(TestShell.Navigation.State.Change);
if (currentGroup) currentGroup.hide();
TestShell.PageManager.setCurrent(selectedGroup);
this.requestPage();
};
TestShell.Navigation.back = function()
{
var currentGroup = TestShell.PageManager.getCurrent();
var previousGroup = TestShell.PageManager.getPrevious();
var taskWorkflow = TestShell.Navigation.createWorkflow(currentGroup, previousGroup);
taskWorkflow.start(this._backInternal, this);
};
TestShell.Navigation._backInternal = function()
{
if (TestShell.PageManager.isFirst())
{
Util.log('TestShell.backPage: You are currently on the first page cannot move back.');
return;
}
TestShell.save();
var currentGroup = TestShell.PageManager.getCurrent();
var previousGroup = TestShell.PageManager.getPrevious();
Util.log('TestShell.backPage: ' + (previousGroup ? previousGroup.id : 'none') + ' (current: ' + (currentGroup ? currentGroup.id : 'none') + ')');
TestShell.Navigation.setState(TestShell.Navigation.State.Back);
if (currentGroup) currentGroup.hide();
TestShell.PageManager.setCurrent(previousGroup);
this.requestPage();
};
TestShell.Navigation.next = function()
{
var currentGroup = TestShell.PageManager.getCurrent();
if (currentGroup instanceof TestShell.PageReview) currentGroup.setConfirmed();
var nextGroup = TestShell.PageManager.getNext();
var taskWorkflow = TestShell.Navigation.createWorkflow(currentGroup, nextGroup);
taskWorkflow.start(this._nextInternal, this);
};
TestShell.Navigation._nextInternal = function()
{
TestShell.save();
var currentGroup = TestShell.PageManager.getCurrent();
if (currentGroup && !currentGroup.isCompleted())
{
TestShell.UI.showWarning(ErrorCodes.get('NextUnanswered'));
return;
}
if (TestShell.PageManager.isLast() && TestShell.testLengthMet)
{
if (!TDS.showItemScores) TestShell.UI.showWarning(ErrorCodes.get('NextTestFinished'));
return;
}
var nextGroup = TestShell.PageManager.getNext();
Util.log('TestShell.nextPage: ' + (nextGroup ? nextGroup.id : 'waiting') + ' (current: ' + (currentGroup ? currentGroup.id : 'none') + ')');
TestShell.Navigation.setState(TestShell.Navigation.State.Next);
if (currentGroup) currentGroup.hide();
TestShell.PageManager.setCurrent(nextGroup);
this.requestPage();
};
TestShell.Navigation._lastRequestedGroup = null;
TestShell.Navigation.requestPage = function()
{
var group = TestShell.PageManager.getCurrent();
if (group == null)
{
Util.log('TestShell.UI.requestPage (no group)');
TestShell.UI.showLoading(Messages.getAlt('TestShell.UI.WaitNextPage', 'Waiting for the next page.'));
return;
}
if (TestShell.Navigation._lastRequestedGroup != group)
{
TestShell.Navigation._lastRequestedGroup = group;
TestShell.Audit.add(group.id, 'page-requested');
}
if (!group.hasContent())
{
Util.log('TestShell.UI.requestPage: ' + group.id + ' (no iframe)');
TestShell.UI.showLoading(Messages.getAlt('TestShell.UI.LoadingContent', 'Loading the page content.'));
group.requestContent();
return;
}
if (group.isShowing())
{
Util.log('TestShell.UI.requestPage: ' + group.id + ' (already viewing)');
return;
}
var currentSegment = group.getSegment();
if (!TestShell.SegmentManager.transition(currentSegment))
{
TestShell.UI.showLoading(Messages.getAlt('TestShell.UI.WaitSegmentApproval', 'Waiting for segment approval.'));
return;
}
if (group.show() === false)
{
Util.log('TestShell.UI.requestPage: ' + group.id + ' (cancelled)');
return;
}
Util.log('TestShell.UI.requestPage: ' + group.id + ' (viewing)');
TestShell.Navigation.setState(TestShell.Navigation.State.Viewing);
group.setVisited();
TestShell.UI.updateControls();
if (group.navOption != null) group.navOption.selected = true;
TestShell.UI.hideLoading();
};
TestShell.Navigation.reset = function()
{
var currentGroup = TestShell.PageManager.getCurrent();
if (currentGroup != null && currentGroup.navOption != null) currentGroup.navOption.selected = true;
};
TestShell.Navigation.update = function()
{
Util.Array.each(TestShell.PageManager.getPages(), function(page)
{
page.updateNavigationLabel();
});
};

// FILE: testshell_Tools.js (4b95969d) 7/22/2014 5:26:22 PM

TestShell.Tools = {};
TestShell.Tools.init = function()
{
TDS.ToolManager.init();
};
TestShell.Tools.toggleHelp = function()
{
var key = 'Global.Path.Help';
var id = 'tool-' + key;
var panel = TDS.ToolManager.get(id);
if (panel == null)
{
var headerText = window.Messages.getAlt('TestShell.Label.HelpGuide', 'Help');
panel = TDS.ToolManager.createPanel(id, 'helpguide', headerText, null, key);
}
TDS.ToolManager.toggle(panel);
};
TestShell.Tools.toggleFormula = function()
{
var contentPage = ContentManager.getCurrentPage();
var accProps = contentPage.getAccommodationProperties();
if (!accProps.hasFormula()) return;
var key = accProps.getFormula();
var id = 'tool-' + key;
var panel = TDS.ToolManager.get(id);
if (panel == null)
{
var headerText = window.Messages.getAlt('TestShell.Label.Formulas', 'Formula');
panel = TDS.ToolManager.createPanel(id, 'formula', headerText, null, key);
}
TDS.ToolManager.toggle(panel);
};
TestShell.Tools.togglePeriodicTable = function()
{
var contentPage = ContentManager.getCurrentPage();
var accProps = contentPage.getAccommodationProperties();
if (!accProps.hasPeriodicTable()) return;
var key = accProps.getPeriodicTable();
var id = 'tool-' + key;
var panel = TDS.ToolManager.get(id);
if (panel == null)
{
var headerText = window.Messages.getAlt('TestShell.Label.PeriodicTable', 'Periodic Table');
panel = TDS.ToolManager.createPanel(id, 'periodictable', headerText, null, key);
}
TDS.ToolManager.toggle(panel);
};
TestShell.Tools.updateShowing = function()
{
if (this._count) YUD.addClass(TestShell.Frame.getBody(), TestShell.UI.CSS.popupShowing);
else YUD.removeClass(TestShell.Frame.getBody(), TestShell.UI.CSS.popupShowing);
};
TDS.ToolManager.Events.subscribe('onLoaded', function(panel)
{
var frame = panel.getFrame();
var frameDoc = Util.Dom.getFrameContentDocument(frame);
TestShell.UI.zoom.addDocument(frameDoc, true);
TestShell.UI.zoom.refresh();
});
TDS.ToolManager.Events.subscribe('onShow', function(panel) {
YUD.addClass(document.body, 'showingTools');
});
TDS.ToolManager.Events.subscribe('onHide', function(panel) {
YUD.removeClass(document.body, 'showingTools');
});

// FILE: testshell_Calculator.js (2e63e245) 7/22/2014 5:26:22 PM

TestShell.Calculator = {};
TestShell.Calculator._calcMapping = {};
TestShell.Calculator._calcMapping['Basic'] = 'TDS_CalcBasic';
TestShell.Calculator._calcMapping['StandardMem'] = 'TDS_CalcStdMem';
TestShell.Calculator._calcMapping['Standard'] = 'TDS_CalcStd';
TestShell.Calculator._calcMapping['Scientific'] = 'TDS_CalcSci';
TestShell.Calculator._calcMapping['ScientificInv'] = 'TDS_CalcSciInv';
TestShell.Calculator._calcMapping['Graphing'] = 'TDS_CalcGraphing';
TestShell.Calculator._calcMapping['GraphingInv'] = 'TDS_CalcGraphingInv';
TestShell.Calculator._calcMapping['Matrices'] = 'TDS_CalcMatrices';
TestShell.Calculator._calcMapping['Regression'] = 'TDS_CalcRegress';
TestShell.Calculator.getCode = function(calcType)
{
return TestShell.Calculator._calcMapping[calcType];
};
TestShell.Calculator.toggle = function()
{
var contentPage = ContentManager.getCurrentPage();
if (contentPage == null) return;
var accProps = contentPage.getAccommodationProperties();
if (accProps == null || !accProps.hasCalculator()) return;
var calcModes = accProps.getCalculator();
for (var calcName in TestShell.Calculator._calcMapping)
{
var calcCode = TestShell.Calculator._calcMapping[calcName];
calcModes = calcModes.replace(calcCode, calcName);
}
var id = 'tool-calculator-' + calcModes.replace(/&/g, "-");
var calcUrl = "../Scripts/Calculator/TDSCalculator.xhtml?mode=" + calcModes.replace(/&/g, ",");
var panel = TDS.ToolManager.get(id);
if (panel == null)
{
panel = TestShell.Calculator.create(id, calcUrl);
}
TDS.ToolManager.toggle(panel);
};
TestShell.Calculator.getInstance = function(id)
{
var frameCalc = document.getElementById('frame-' + id);
if (!frameCalc || !frameCalc.contentWindow) return null;
var winCalc = frameCalc.contentWindow;
if (!YAHOO.lang.isFunction(winCalc.getWorkingCalcInstance)) return null;
var calcInstance = winCalc.getWorkingCalcInstance();
if (calcInstance != null && YAHOO.lang.isFunction(calcInstance.setInitKeyboardElement)) return calcInstance;
return null;
};
TestShell.Calculator.setStyle = function(panel, calcInstance)
{
for (var calcName in TestShell.Calculator._calcMapping)
{
var calcCode = TestShell.Calculator._calcMapping[calcName];
YUD.removeClass(panel.element, calcCode);
}
var currentCalcCode = TestShell.Calculator.getCode(calcInstance.config.name);
if (currentCalcCode)
{
YUD.addClass(panel.element, currentCalcCode);
}
panel.refresh();
};
TestShell.Calculator.create = function(id, calcUrl)
{
var headerText = window.Messages.getAlt('TestShell.Label.Calculator', 'Calculator');
var panel = TDS.ToolManager.createPanel(id, 'calculator', headerText, null);
TDS.ToolManager.loadUrl(panel, calcUrl, function ()
{
YUD.addClass(panel.getFrame().contentDocument.body, 'client_' + TDS.clientStylePath);
var calcInstance = TestShell.Calculator.getInstance(id);
if (calcInstance && calcInstance.parent)
{
setTimeout(function()
{
TestShell.Calculator.setStyle(panel, calcInstance);
}, 0);
calcInstance.parent.CalcModeChange.subscribe(function(ev, arr)
{
var oldCalc = arr[0], newCalc = arr[1];
TestShell.Calculator.setStyle(panel, newCalc);
var panelX = panel.cfg.getProperty('x');
var panelY = panel.cfg.getProperty('y');
panel.moveTo(panelX, panelY);
});
}
});
panel.showEvent.subscribe(function()
{
var calcInstance = TestShell.Calculator.getInstance(id);
if (calcInstance)
{
calcInstance.clearFocus(calcInstance.config.keyboardRegionDivs);
setTimeout(function() { calcInstance.setInitKeyboardElement(); }, 1);
}
});
return panel;
};

// FILE: testshell_Validation.js (99894417) 7/22/2014 5:26:22 PM

TestShell.Validation = {};
TestShell.Validation.checkGrid = function(taskWorkflow)
{
var currentGroup = TestShell.PageManager.getCurrent();
if (currentGroup && currentGroup.responses)
{
for (var i = 0; i < currentGroup.responses.length; i++)
{
var response = currentGroup.responses[i];
var item = response.getItem();
if (item && item.grid &&
item.responseType.toLowerCase() == 'grid')
{
if (item.grid.getState() != GridState.Loaded &&
item.grid.getState() != GridState.Error)
{
TestShell.Navigation.reset();
TestShell.UI.showWarning(Messages.get('TDSShellUIJS.Label.WaitForGridToLoad'));
taskWorkflow.cancel();
}
}
}
if (currentGroup.iframe)
{
var visitTime = (new Date() - currentGroup.iframe.timestamps.showDate);
if (visitTime < 500)
{
TestShell.Navigation.reset();
taskWorkflow.cancel();
}
}
}
};
TestShell.Validation.checkAudioPlaying = function(taskWorkflow) {
if (TDS.Audio.isActive()) {
if (TestShell.Config.allowSkipAudio) {
TDS.Audio.stopAll();
} else {
TestShell.Navigation.reset();
TestShell.UI.showWarning(ErrorCodes.get('NavigateAudioPlaying'));
taskWorkflow.cancel();
}
}
};
TestShell.Validation.checkAudioRecording = function(taskWorkflow) {
if (TDS.Audio.Recorder.isCapturing()) {
TestShell.UI.showWarning(ErrorCodes.get('SaveRecordingInProgress'));
taskWorkflow.cancel();
}
};
TestShell.Validation.checkDirtyResponses = function(taskWorkflow)
{
var currentGroup = TestShell.PageManager.getCurrent();
if (currentGroup == null || currentGroup.responses == null) return;
for (var i = 0; i < currentGroup.responses.length; i++)
{
var response = currentGroup.responses[i];
var item = response.getItem();
if (item && !item.saveOptions.implicit && response.isDirty())
{
TestShell.UI.showWarningPrompt('NavigateUnsaved',
{
yes: function() { response.undo(); taskWorkflow.resume(); },
no: function() { TestShell.Navigation.reset(); taskWorkflow.cancel(); }
});
taskWorkflow.wait();
}
}
};
TestShell.Validation.checkRecorderQuality = function(taskWorkflow) {
var currentGroup = TestShell.PageManager.getCurrent();
if (currentGroup == null || currentGroup.responses == null) return;
var response = currentGroup.responses[0];
var item = response.getItem();
if (item == null || item.recorder == null || response.isDirty() == false) return;
var quality = TDS.Audio.Recorder.retrieveQuality(item.recorder       );
if (YAHOO.lang.isString(quality) && quality.toUpperCase() != 'GOOD') {
TestShell.UI.showWarningPrompt('SaveRecordingQuality', {
yes: function() {
taskWorkflow.resume();
},
yesLabel: 'Global.Prompt.Button.KeepIt',
no: function() {
TestShell.Navigation.reset();
taskWorkflow.cancel();
},
noLabel: 'Global.Prompt.Button.TryAgain'
});
taskWorkflow.wait();
}
};
TestShell.Validation.checkSegment = function(taskWorkflow, result, transition)
{
var fromGroup = transition.from;
var toGroup = transition.to;
if (fromGroup == null || toGroup == null) return;
var fromSegment = fromGroup.getSegment();
var toSegment = toGroup.getSegment();
if (fromSegment == toSegment) return;
if (fromSegment && !fromSegment.isPermeable() && !fromSegment.isFinished())
{
TestShell.Navigation.reset();
taskWorkflow.cancel();
var msgImpermeableIncomplete = 'Segment is not permeable so all the questions must be completed before going to another segment.';
msgImpermeableIncomplete = Messages.getAlt('TestShell.Segment.ImpermeableIncomplete', msgImpermeableIncomplete);
TestShell.UI.showWarning(msgImpermeableIncomplete);
}
else if ((fromSegment && !fromSegment.isPermeable()) ||
(fromSegment && fromSegment.requireExitApproval()) ||
(toSegment && toSegment.requireEntryApproval()))
{
var msgLeaveWarning = 'You are leaving the current segment, are you sure you want to do this?';
msgLeaveWarning = Messages.getAlt('TestShell.Segment.LeaveWarning', msgLeaveWarning);
TestShell.UI.showWarningPrompt(msgLeaveWarning,
{
yes: function() { taskWorkflow.resume(); },
yesLabel: 'Yes',
no: function() { TestShell.Navigation.reset(); taskWorkflow.cancel(); },
noLabel: 'No'
});
taskWorkflow.wait();
}
};
TestShell.Validation.checkOptionalUnanswered = function(taskWorkflow)
{
if (TDS.isSIRVE) return;
var currentGroup = TestShell.PageManager.getCurrent();
if (currentGroup == null || currentGroup.responses == null) return;
if (currentGroup.numRequired > 0) return;
var optionalUnansweredResponses = [];
for (var i = 0; i < currentGroup.responses.length; i++)
{
var response = currentGroup.responses[i];
if (response.isAnswered()) continue;
if (!response.isRequired) optionalUnansweredResponses.push(response);
}
if (optionalUnansweredResponses.length > 0)
{
var messageKey = 'OptionalUnansweredResponses';
var messageParam = optionalUnansweredResponses[0].position;
var messageText = ErrorCodes.get(messageKey, messageParam);
TestShell.UI.showErrorPrompt(messageText,
{
yes: function() { taskWorkflow.resume(); },
yesLabel: Messages.get('Global.Label.Yes'),
no: function() { TestShell.Navigation.reset(); taskWorkflow.cancel(); },
noLabel: Messages.get('Global.Label.No')
});
taskWorkflow.wait();
}
};
TestShell.Validation.checkSimulatorPlaying = function(taskWorkflow, result, errorMessage)
{
var currentGroup = TestShell.PageManager.getCurrent();
if (currentGroup == null || currentGroup.responses == null) return;
var response = currentGroup.responses[0];
var item = response.getItem();
if (item == null || item.simulator == null) return;
if (item.simulator.isPlaying())
{
errorMessage = errorMessage || 'SimulatorPlaying';
TestShell.UI.showWarning(ErrorCodes.get(errorMessage));
taskWorkflow.cancel();
}
};
TestShell.Validation.checkBlockPausing = function(taskWorkflow)
{
var page = TestShell.PageManager.getCurrent();
if (page == null) return;
var accs = TestShell.PageManager.getAccommodations(page);
if (accs == null || !accs.createProps().blockPausing()) return;
if (TestShell.PageManager.isCompleted(true, true)) return;
var validateStatus = function(status)
{
if (status == 5           )
{
taskWorkflow.resume();
}
else
{
TestShell.UI.showWarning(ErrorCodes.get('TestShell.Label.BlockPausing'));
taskWorkflow.cancel();
}
};
TestShell.xhrManager.getPauseStatus(validateStatus);
taskWorkflow.wait();
};
TestShell.Validation.checkIfPromptSelected = function(taskWorkflow) {
var page = TestShell.PageManager.getCurrent();
if (page == null) return;
if (page.isCompleted()) {
return;
}
var responses = page.responses;
if (responses == null || responses.length < 1) {
return;
}
var item = responses[0].getItem();
if ((item == null) ||  (item.responseType != "Prompt selection")) {
return;
}
for (var i = 0; i < responses.length; ++i) {
item = responses[i].getItem();
if (item.unit != null && item.unit.isSelected() == true) {
return;
}
}
TestShell.UI.showWarning(Messages.get('WritingNoPromptSelected'));
taskWorkflow.cancel();
};

// FILE: testshell_Print.js (52e1c936) 7/22/2014 5:26:22 PM

TestShell.Print = {};
TestShell.Print._getCallback = function()
{
var callback =
{
success: function(xhrObj)
{
TestShell.idleTimer.waitMins = TestShell.Config.requestInterfaceTimeout;
TestShell.idleTimer.reset();
},
failure: function(xhrObj)
{
TestShell.UI.showError(Messages.get('TDSShellUIJS.Label.PrintRequestFailed'));
},
timeout: 30000
};
return callback;
};
TestShell.Print._getAccommodations = function()
{
var page = ContentManager.getCurrentPage();
var accProps = page.getAccommodationProperties();
var printSize = page.getZoom().getCSS();
var fontType = accProps.getFontType();
var fontSize = accProps.getFontSize();
var parameters = [];
parameters.push('Print Size:' + printSize);
parameters.push('Font Type:' + fontType);
parameters.push('Font Size:' + fontSize);
return parameters.join(';');
};
TestShell.Print.getXhrUrl = function()
{
var urlBuilder = [];
urlBuilder.push(TDS.baseUrl);
urlBuilder.push('Pages/API/TestShell.axd/');
return urlBuilder.join('');
};
TestShell.Print.passage = function()
{
var url = this.getXhrUrl() + 'print?';
var group = TestShell.PageManager.getCurrent();
var urlParameters = [];
urlParameters.push('type=passage');
urlParameters.push('page=' + group.pageNum);
urlParameters.push('accommodations=' + this._getAccommodations());
url += urlParameters.join('&');
YUC.asyncRequest('POST', url, this._getCallback());
TestShell.UI.showAlert(Messages.get('TDSShellUIJS.Label.Notice'), Messages.get('Print'));
this.passageComplete(group);
};
TestShell.Print.item = function(position)
{
var url = this.getXhrUrl() + 'print?';
var group = TestShell.PageManager.getCurrent();
var response = group.getResponse(position);
var urlParameters = [];
urlParameters.push('type=item');
urlParameters.push('page=' + group.pageNum);
urlParameters.push('position=' + position);
urlParameters.push('accommodations=' + this._getAccommodations());
url += urlParameters.join('&');
YUC.asyncRequest('POST', url, this._getCallback());
TestShell.UI.showAlert(Messages.get('TDSShellUIJS.Label.Notice'), Messages.get('Print'));
if (response)
{
this.itemComplete(group, response);
}
};
TestShell.Print.passageComplete = function(group)
{
var contentPage = group.getContentPage();
if (contentPage.layout != 'WAI') return;
var pagePassage = contentPage.getPassage();
var passageElement = pagePassage.getElement();
var status = Util.Dom.getElementByClassName('status', 'div', passageElement);
if (status == null)
{
status = HTML.DIV({ className: 'status' });
status.setAttribute('role', 'status');
status.setAttribute('aria-atomic', 'false');
status.setAttribute('aria-relevant', 'additions text');
status.setAttribute('aria-live', 'assertive');
YUD.insertBefore(status, YUD.getFirstChild(passageElement));
}
status.innerHTML = 'Print request submitted';
};
TestShell.Print.itemComplete = function(group, response)
{
var contentPage = group.getContentPage();
if (contentPage.layout != 'WAI') return;
var item = response.getItem();
if (item == null) return;
var printLink = item.getPrintLink();
YUD.addClass(printLink, 'printSubmitted');
if (printLink)
{
setTimeout(function()
{
printLink.setAttribute('aria-label', 'This question has been submitted for printing.');
}, 0);
}
};

// FILE: testshell_Audit.js (1e5260f7) 7/22/2014 5:26:22 PM

TestShell.Audit =
{
_records: [],
_recordGroups: new Util.Structs.Map(),
_toolsUsed: []
};
TestShell.Audit.Record = function(id, event)
{
this.id = id;
this.event = event;
this.date = new Date();
};
TestShell.Audit.get = function(id)
{
var records = this._recordGroups.get(id);
return (records) ? records.slice(0) : null;
};
TestShell.Audit.getList = function()
{
return this._records;
};
TestShell.Audit.add = function(id, event)
{
var record = new TestShell.Audit.Record(id, event);
this._records.push(record);
var records = this._recordGroups.get(id);
if (records == null)
{
records = [];
this._recordGroups.set(id, records);
}
records.push(record);
};
TestShell.Audit.addToolUsage = function(page, accType, accCode)
{
var toolUsageToAdd = Util.Array.find(this._toolsUsed, function(toolUsage)
{
return (toolUsage.page == page &&
toolUsage.type == accType &&
toolUsage.code == accCode);
});
if (toolUsageToAdd)
{
toolUsageToAdd.count++;
}
else
{
toolUsageToAdd =
{
page: page,
type: accType,
code: accCode,
count: 1
};
this._toolsUsed.push(toolUsageToAdd);
}
};
TestShell.Audit.getToolsUsed = function() { return this._toolsUsed; };
TestShell.Audit.Latency = function()
{
this.itemPage = 0;
this.numItems = 0;
this.requestTime = 0;
this.loadAttempts = 0;
this.loadDate = null;
this.loadTime = 0;
this.createDate = null;
this.visitTime = 0;
this.visitCount = 0;
this.visitDate = null;
};
TestShell.Audit.Latency.prototype.toJson = function()
{
var json = [];
var properties = 0;
var addProperty = function(name, value, converter)
{
if (properties > 0) json.push(',');
json.push('"');
json.push(name);
json.push('":');
if (YAHOO.lang.isObject(value) && YAHOO.lang.isFunction(converter))
{
value = converter(value);
}
if (YAHOO.lang.isNull(value))
{
json.push('null');
}
else if (YAHOO.lang.isNumber(value))
{
json.push(value);
}
else
{
json.push('"');
json.push(value);
json.push('"');
}
properties++;
};
var dateToString = function(d)
{
return '\/Date(' + d.getTime() + ')\/';
};
json.push('{');
addProperty('itemPage', this.itemPage);
addProperty('numItems', this.numItems);
addProperty('requestTime', this.requestTime);
addProperty('loadAttempts', this.loadAttempts);
addProperty('loadDate', this.loadDate, dateToString);
addProperty('loadTime', this.loadTime);
addProperty('createDate', this.createDate, dateToString);
addProperty('visitCount', this.visitCount);
addProperty('visitDate', this.visitDate, dateToString);
addProperty('visitTime', this.visitTime);
json.push('}');
return json.join('');
};
TestShell.Audit.findEvent = function(id, event, minDate)
{
var records = TestShell.Audit.get(id);
if (records == null) return null;
records = records.reverse();
return Util.Array.find(records, function(record)
{
return (record.event == event && (minDate == null || record.date >= minDate));
});
};
TestShell.Audit.filterEvents = function(id, event)
{
var records = TestShell.Audit.get(id);
if (records == null) return [];
return Util.Array.filter(records, function(record) { return record.event == event; });
};
TestShell.Audit.aggregateEvents = function(id, event1, event2, fixEnd)
{
var records = TestShell.Audit.get(id);
if (records == null) return -1;
var total = 0;
var startRecord = null;
var endRecord = null;
Util.Array.each(records, function(record)
{
if (event1 == record.event)
{
startRecord = record;
endRecord = null;
}
if (event2 == record.event)
{
endRecord = record;
}
if (startRecord != null && endRecord != null)
{
total += (endRecord.date - startRecord.date);
startRecord = null;
endRecord = null;
}
});
if (fixEnd && startRecord != null && endRecord == null)
{
var now = new Date();
total += (now - startRecord.date);
}
return total;
};
TestShell.Audit.Latency.create = function(group)
{
var latency = new TestShell.Audit.Latency();
latency.itemPage = group.pageNum;
latency.numItems = group.responses.length;
var createRecord = TestShell.Audit.findEvent(group.id, 'content-requested');
if (createRecord == null) return null;
latency.createDate = createRecord.date;
var loadRecord = TestShell.Audit.findEvent(group.id, 'content-loaded', createRecord.date);
if (loadRecord != null) latency.loadDate = loadRecord.date;
var visitRecord = TestShell.Audit.findEvent(group.id, 'page-show');
if (visitRecord != null) latency.visitDate = visitRecord.date;
latency.requestTime = TestShell.Audit.aggregateEvents(group.id, 'page-requested', 'page-show');
latency.loadTime = TestShell.Audit.aggregateEvents(group.id, 'content-requested', 'content-loaded');
latency.visitTime = TestShell.Audit.aggregateEvents(group.id, 'page-show', 'page-hide', true);
latency.loadAttempts = TestShell.Audit.filterEvents(group.id, 'content-requested').length;
latency.visitCount = TestShell.Audit.filterEvents(group.id, 'page-show').length;
return latency;
};
TestShell.Audit.Latency.createCollection = function()
{
var latencies = [];
Util.Array.each(TestShell.PageManager.getGroups(), function(group)
{
var latency = null;
try { latency = TestShell.Audit.Latency.create(group); }
catch(ex)
{
Util.log('Latency error: ' + ex);
}
if (latency != null) latencies.push(latency);
});
return latencies;
};
TestShell.Audit.Latency.getJson = function()
{
var latencyCount = 0;
var latencies = TestShell.Audit.Latency.createCollection();
var json = [];
json.push('[');
Y.Array.each(latencies, function(latency)
{
if (latencyCount > 0) json.push(',');
json.push(latency.toJson());
latencyCount++;
});
json.push(']');
return json.join('');
};
TestShell.Audit.getJson = function()
{
var json = [];
json.push('{');
json.push('"latencies":');
json.push(TestShell.Audit.Latency.getJson());
json.push(',');
json.push('"toolsUsed":');
json.push(YAHOO.Lang.JSON.stringify(this._toolsUsed));
json.push('}');
return json.join('');
};
TestShell.ContentLoader._xhrManager.Events.subscribe('onSent', function(request)
{
TestShell.Audit.add(request.getId(), 'content-requested');
});
TestShell.ContentLoader._xhrManager.Events.subscribe('onSuccess', function(request)
{
TestShell.Audit.add(request.getId(), 'content-received');
});
TestShell.ContentLoader._xhrManager.Events.subscribe('onFailure', function(request)
{
TestShell.Audit.add(request.getId(), 'content-failed');
});
ContentManager.onPageEvent('init', function(contentPage)
{
TestShell.Audit.add(contentPage.id, 'content-init');
});
ContentManager.onPageEvent('rendering', function(contentPage)
{
TestShell.Audit.add(contentPage.id, 'content-rendering');
});
ContentManager.onPageEvent('rendered', function(contentPage)
{
TestShell.Audit.add(contentPage.id, 'content-rendered');
});
ContentManager.onPageEvent('available', function(contentPage)
{
TestShell.Audit.add(contentPage.id, 'content-available');
});
ContentManager.onPageEvent('loaded', function(contentPage)
{
TestShell.Audit.add(contentPage.id, 'content-loaded');
});
TestShell.PageManager.Events.subscribe('onShow', function(page)
{
TestShell.Audit.add(page.id, 'page-show');
});
TestShell.PageManager.Events.subscribe('onHide', function(page)
{
TestShell.Audit.add(page.id, 'page-hide');
});
TTS.Manager.Events.onStatusChange.subscribe(function(currentStatus)
{
if (currentStatus != TTS.Status.Playing) return;
var currentPage = ContentManager.getCurrentPage();
if (currentPage == null) return;
var page = TestShell.PageManager.get(currentPage.id);
if (page == null) return;
var currentEntity = currentPage.getActiveEntity();
if (currentEntity instanceof ContentPassage)
{
TestShell.Audit.addToolUsage(page.pageNum, 'TTS', 'TDS_TTS_Stim');
}
else if (currentEntity instanceof ContentItem)
{
TestShell.Audit.addToolUsage(page.pageNum, 'TTS', 'TDS_TTS_Item');
}
});

// FILE: testshell_Logging.js (a228996a) 7/22/2014 5:26:22 PM

(function(TestShell) {
function formatTime(d) {
var hour = d.getHours() % 12;
hour = Util.Date.xPad(hour === 0 ? 12 : hour, 0);
var time = hour + ':' +
Util.Date.xPad(d.getUTCMinutes(), 0) + ':' +
Util.Date.xPad(d.getUTCSeconds(), 0) + '.' +
Util.Date.xPad(d.getUTCMilliseconds(), 00);
return time;
}
function formatDate(dt) {
var formattedTime = formatTime(dt);
return dt.getUTCMonth() + '/' + dt.getUTCDate() + '/' + dt.getUTCFullYear()+ ' ' + formattedTime;
}
function getString(obj) {
if (obj == null) return '';
if (obj instanceof Date) return formatDate(obj);
return obj.toString();
}
function createTable(objArr) {
if (!YAHOO.lang.isArray(objArr)) return null;
if (objArr.length == 0) return null;
var columns = [];
var columnWidths = [];
for (var name in objArr[0]) {
columns.push(name);
columnWidths.push(name.length);
}
for (var i = 0; i < objArr.length; i++) {
var obj = objArr[i];
for (var j = 0; j < columns.length; j++) {
var columnName = columns[j];
var objValue = obj[columnName];
var objString = getString(objValue);
if (objString.length > columnWidths[j]) {
columnWidths[j] = objString.length;
}
}
}
var padding = 3;
var sb = [];
for (var i = 0; i < columns.length; i++) {
var columnName = columns[i];
var columnSize = columnName.length;
sb.push(columnName);
var columnWidthRemaining = (columnWidths[i] - columnSize) + padding;
for (var j = 0; j < columnWidthRemaining; j++) {
sb.push(' ');
}
}
sb.push('\n');
for (var i = 0; i < columns.length; i++) {
var columnName = columns[i];
var columnSize = columnName.length;
for (var j = 0; j < columnWidths[i]; j++) {
sb.push('-');
}
for (var j = 0; j < padding; j++) {
sb.push(' ');
}
}
sb.push('\n');
for (var i = 0; i < objArr.length; i++) {
var obj = objArr[i];
for (var j = 0; j < columns.length; j++) {
var columnName = columns[j];
var objValue = obj[columnName];
var objString = getString(objValue);
var columnSize = objString.length;
sb.push(objString);
var columnWidthRemaining = (columnWidths[j] - columnSize) + padding;
for (var k = 0; k < columnWidthRemaining; k++) {
sb.push(' ');
}
}
sb.push('\n');
}
return sb.join('');
}
function createReport(name, objArr) {
var sb = [];
sb.push('@' + name.toUpperCase() + ':\n\n');
var tableReport = createTable(objArr);
sb.push(tableReport);
sb.push('\n');
return sb.join('');
}
var consoleLog = console.log;
var consoleHistory = [];
var consoleMax = 20;
function enableConsoleHistory() {
console.log = function() {
consoleHistory.push(arguments);
if (consoleHistory.length > consoleMax) {
consoleHistory.slice();
}
consoleLog(Array.prototype.slice.call(arguments));
};
}
var responsesSent = [];
function trackResponsesSent(responses) {
if (!YAHOO.lang.isArray(responses)) return;
var now = formatDate(new Date());
for (var i = 0; i < responses.length; i++) {
var response = responses[i];
responsesSent.push({
date: now,
position: response.position,
sequence: response.sequence,
selected: response.isSelected,
valid: response.isValid,
length: (response.value != null) ? response.value.length : -1,
hash: (response.value != null) ? Util.String.hashCode(response.value) : -1
});
}
}
function enableResponseTracking() {
TestShell.ResponseManager.Events.onSend.subscribe(function(outgoingResponses) {
setTimeout(function() {
try {
trackResponsesSent(outgoingResponses);
} catch(ex) {
console.error(ex);
}
}, 0);
});
}
var contentReceived = [];
function trackItemReceived(itsItem)
{
var now = formatDate(new Date());
var debugItem = {
date: now,
id: itsItem.bankKey + '-' + itsItem.itemKey,
length: (itsItem.value != null) ? itsItem.value.length : -1,
hash: (itsItem.value != null) ? Util.String.hashCode(itsItem.value) : -1
};
contentReceived.push(debugItem);
}
function enableContentTracking() {
ContentManager.onItemEvent('init', function(page, item, itsItem) {
trackItemReceived(itsItem);
});
}
function getPages() {
var debugPages = [];
var pages = TestShell.PageManager.getPages();
for (var i = 0; i < pages.length; i++) {
var page = pages[i];
var debugPage = {
current: (page === TestShell.PageManager.getCurrent()),
page: page.pageNum,
id: page.id,
segment: null,
enabled: page.isEnabled(),
visible: page.isVisible(),
visited: page.isVisited(),
completed: page.isCompleted(),
items: null,
itemsAnswered: null,
itemsRequired: null,
groupRequired: null,
loaded: page.hasContent(),
layout: null,
passage: false,
coverPage: null
};
if (typeof page.getSegment == 'function') {
var segment = page.getSegment();
if (segment) {
debugPage.segment = segment.getId();
}
}
if (page instanceof TestShell.PageGroup) {
var groupInfo = page.getInfo();
debugPage.items = groupInfo.itemCount;
debugPage.itemsAnswered = groupInfo.itemsAnswered;
debugPage.itemsRequired = groupInfo.itemsRequired;
debugPage.groupRequired = groupInfo.groupRequired;
var coverPageInfo = page.getCoverPageInfo();
if (coverPageInfo) {
debugPage.coverPage = coverPageInfo.id;
}
}
if (page instanceof TestShell.PageContent) {
var contentPage = page.getContentPage();
if (contentPage) {
debugPage.layout = contentPage.layout;
debugPage.items = contentPage.getItems().length;
debugPage.passage = contentPage.getPassage() != null;
}
}
debugPages.push(debugPage);
}
return debugPages;
};
function getItems() {
var itemsDebug = [];
var pageGroups = TestShell.PageManager.getGroups();
for (var i = 0; i < pageGroups.length; i++) {
var page = pageGroups[i];
var responses = page.responses;
for (var j = 0; j < responses.length; j++) {
var response = responses[j];
var debugItem = {
page: page.pageNum,
position: response.position,
id: response.id,
prefetched: response.prefetched,
required: response.isRequired,
selected: response.isSelected,
valid: response.isValid,
sequence: response.sequence,
length: (response.value != null) ? response.value.length : -1,
hash: (response.value != null) ? Util.String.hashCode(response.value) : -1,
format: null,
responseType: null
};
var contentItem = response.getItem();
if (contentItem) {
debugItem.format = contentItem.format;
debugItem.responseType = contentItem.responseType;
}
itemsDebug.push(debugItem);
}
}
return itemsDebug;
}
function getPlugins() {
var pluginsInfo = [];
for (var i = 0; i < navigator.plugins.length; i++) {
var plugin = navigator.plugins[i];
pluginsInfo.push({
name: plugin.name,
version: plugin.version,
filename: plugin.filename
});
}
return pluginsInfo;
}
function createDebugReport() {
var sb = [];
var debugSegments = TestShell.SegmentManager.getDebug();
if (debugSegments.length > 0) {
sb.push(createReport('Segments', debugSegments));
}
var debugPages = getPages();
if (debugPages.length > 0) {
sb.push(createReport('Pages', debugPages));
}
var debugItems = getItems();
if (debugItems.length > 0) {
sb.push(createReport('Items', debugItems));
}
if (responsesSent.length > 0) {
sb.push(createReport('Responses Sent', responsesSent));
}
if (contentReceived.length > 0) {
sb.push(createReport('Content Received', contentReceived));
}
var auditRecords = TestShell.Audit.getList();
if (auditRecords.length > 0) {
sb.push(createReport('Pages Audit', auditRecords));
}
if (consoleHistory.length > 0) {
sb.push('@CONSOLE: \n\n');
for (var i = 0; i < consoleHistory.length; i++) {
sb.push(consoleHistory[i].toString() + '\n');
}
}
return sb.join('');
}
var Logging = {};
Logging.writeDebugReport = function() {
consoleLog(createDebugReport());
};
if (TestShell.Config.enableLogging) {
}
TestShell.Logging = Logging;
function enableLogShortcut() {
KeyManager.onKeyEvent.subscribe(function(keyObj) {
if (keyObj &&
keyObj.ctrlKey &&
keyObj.altKey &&
keyObj.shiftKey &&
keyObj.type == 'keyup' &&
keyObj.keyCode == 68) {
var details = createDebugReport();
TDS.Diagnostics.logServerError('TEST SHELL LOGS', details, true);
}
});
}
TestShell.Events.subscribe('init', function() {
if (TestShell.Config.enableLogging) {
console.info('TestShell logging is enabled');
enableLogShortcut();
enableContentTracking();
enableResponseTracking();
}
});
})(TestShell);

// FILE: testShell_SIRVE.js (d7b8f508) 7/22/2014 5:26:22 PM

TestShell.ResponseManager.Events.onSuccess.subscribe(function (results) {
function contains(arr, segmentPosition) {
for (var index = 0; index < arr.length; ++index) {
if (arr[index].position == segmentPosition)
return true;
}
return false;
};
function createTestSegment(segmentPosition, segmentId) {
var segment = {
id: segmentId,
position: segmentPosition,
label: segmentId,
itemReview: false,
isPermeable: true,
updatePermeable: false,
entryApproval: 0,
exitApproval: 0
};
return segment;
};
if (TDS.isSIRVE) {
var totalNumberOfItems = 0;
window.tdsSegments = [];
for (var groupIndex = 0; groupIndex < results.groups.length; ++groupIndex) {
var group = results.groups[groupIndex];
var segmentPosition = group.segment;
var segmentId = group.segmentID;
if (!contains(window.tdsSegments, segmentPosition))
window.tdsSegments.push(createTestSegment(segmentPosition, segmentId));
totalNumberOfItems += group.responses.length;
}
TestShell.Config.testLength = totalNumberOfItems;
TestShell.SegmentManager.init();
TestShell.PageManager.setCurrent(results.groups[0]);
}
});

// FILE: automute.js (dfb760cf) 7/22/2014 5:26:22 PM

(function (TS){
var Player = TDS.Audio.Player;
var Slideshow = window.slide;
function attemptPlay(){
subscribeEndAudio();
Util.log('unmuting...');
if(Util.SecureBrowser.unmute()){
TestShell.muted = false;
}
}
function engageAutomute(){
subscribePlayAudio();
doMute();
Util.log('Automute engaged');
}
function doMute()
{
unsubscribeEndAudio();
Util.log('muting...');
if(Util.SecureBrowser.mute()){
TestShell.muted = true;
}
}
function subscribePlayAudio(){
Player.onPlay.subscribe(attemptPlay);
Slideshow.onPlay.subscribe(attemptPlay);
}
function subscribeEndAudio(){
Player.onIdle.subscribe(doMute);
Player.onFail.subscribe(doMute);
Slideshow.onIdle.subscribe(doMute);
}
function unsubscribeEndAudio(){
Player.onIdle.unsubscribe(doMute);
Player.onFail.unsubscribe(doMute);
Slideshow.onIdle.unsubscribe(doMute);
}
function automute_init(){
var accProps = TDS.getAccommodationProperties();
if(accProps && accProps.isAutoMute()) {
engageAutomute();
}
}
TS.Events.subscribe('init', automute_init);
})(TestShell);

// FILE: fullscreen.js (0c825621) 7/22/2014 5:26:22 PM

(function (TS) {
var CSS_ENABLED = 'fs-enabled';
function getPassword() {
var info = $('.studentInfo').text();
if (info) {
return info.split(',')[1].split('(')[0].trim();
}
return '';
}
function showPasswordDialog() {
var msgRequest = Messages.get('TestShell.Fullscreen.PasswordRequest');
TDS.Dialog.showInput(msgRequest, function (text) {
if (text.toLowerCase() == getPassword().toLowerCase()) {
YUD.removeClass(document.body, CSS_ENABLED);
} else {
var msgDenied = Messages.get('TestShell.Fullscreen.PasswordDenied');
TDS.Dialog.showAlert(msgDenied);
}
});
}
function isEnabled() {
return YUD.hasClass(document.body, CSS_ENABLED);
}
function enable() {
YUD.addClass(document.body, CSS_ENABLED);
}
function disable() {
var accProps = TDS.getAccommodationProperties();
if (accProps && accProps.hasFullScreenPassword()) {
showPasswordDialog();
} else {
YUD.removeClass(document.body, CSS_ENABLED);
}
}
function toggle() {
if (isEnabled()) {
disable();
} else {
enable();
}
}
function init() {
var accProps = TDS.getAccommodationProperties();
if (accProps && accProps.hasFullScreenEnabled()) {
TestShell.UI.addButtonControl('btnFullScreen', 'Full Screen', 'fullscreen', toggle);
if (accProps.hasFullScreenPassword()) {
enable();
}
}
}
TS.Events.subscribe('init', init);
})(TestShell);

// FILE: masking.js (dff6702e) 7/22/2014 5:26:22 PM

(function (TS) {
if (window.TDS && !window.TDS.Mask) {
return;
}
var CSS_ENABLED = 'msk-enabled';
function isEnabled() {
return YUD.hasClass(document.body, CSS_ENABLED);
}
function enable() {
YUD.addClass(document.body, CSS_ENABLED);
}
function disable() {
YUD.removeClass(document.body, CSS_ENABLED);
}
function toggle() {
if (isEnabled()) {
disable();
} else {
enable();
}
TDS.Mask.toggle();
}
function init() {
var accProps = TDS.getAccommodationProperties();
if (accProps && accProps.hasMaskingEnabled()) {
TestShell.UI.addButtonTool('btnMask', 'Masking', 'maskingtool', toggle);
} else {
console.warn("Masking not enabled.");
return;
}
ContentManager.onPageEvent('hide', function() {
if (isEnabled()) {
disable();
}
});
}
TS.Events.subscribe('init', init);
})(TestShell);

// FILE: comments.js (e3245ac4) 3/7/2014 11:24:06 AM

TestShell.Comments =
{
_overlayManager: new YAHOO.widget.OverlayManager(),
_itemComments: null,
_globalComments: null
};
TestShell.Comments.init = function() {
this._itemComments = new TestShell.Comments.Item();
this._itemComments.render();
this._globalComments = new TestShell.Comments.Global();
this._globalComments.render();
};
TestShell.Comments.showItem = function(obj) {
this._itemComments.show(obj);
};
TestShell.Comments.showGlobal = function() {
this._globalComments.show();
};
TestShell.Comments.hide = function() {
this._itemComments.hide();
this._globalComments.hide();
};
TestShell.Comments.isShowing = function() {
return this._itemComments.isShowing() ||
this._globalComments.isShowing();
};

// FILE: base.js (f4d913a6) 3/7/2014 11:24:06 AM

TestShell.Comments.Base = function () {
this._dialog = null;
};
TestShell.Comments.Base.Type = {
None: 0,
DropDown: 1,
TextArea: 2
};
TestShell.Comments.Base.prototype.getId = function() {
return 'comment';
};
TestShell.Comments.Base.prototype.getElement = function() {
var commentId = this.getId();
return YUD.get(commentId);
};
TestShell.Comments.Base.prototype.getHeaderEl = function() {
var commentContainer = this.getElement();
return Util.Dom.getElementByClassName('comment-header', 'div', commentContainer);
};
TestShell.Comments.Base.prototype.getHeaderText = function() {
return '';
};
TestShell.Comments.Base.prototype.getBodyEl = function() {
var commentContainer = this.getElement();
return Util.Dom.getElementByClassName('comment-body', 'div', commentContainer);
};
TestShell.Comments.Base.prototype.getFormEl = function() {
var commentContainer = this.getElement();
return Util.Dom.getElementByClassName('comment-form', 'form', commentContainer);
};
TestShell.Comments.Base.prototype.getInputEl = function() {
var commentContainer = this.getElement();
return Util.Dom.getElementByClassName('comment-input', null, commentContainer);
};
TestShell.Comments.Base.prototype.getInputValue = function() {
var inputEl = this.getInputEl();
return (inputEl != null) ? inputEl.value : null;
};
TestShell.Comments.Base.prototype.render = function() {
var commentContainer = this.getElement();
if (commentContainer != null) return;
var dialog = new YAHOO.widget.SimpleDialog(this.getId(), {
visible: false,
draggable: false,
modal: true,
close: false,
fixedcenter: true,
width: '450px',
height: '150px',
zindex: 999,
postmethod: 'none',
autofillheight: false
});
this._dialog = dialog;
TestShell.Comments._overlayManager.register(dialog);
dialog.setHeader(this.getHeaderText());
var buttons = [
{ text: Messages.get('Cancel'), handler: { fn: this.hide, scope: this} },
{ text: Messages.get('Submit and Close'), handler: { fn: this.submit, scope: this }, isDefault: true }
];
dialog.cfg.queueProperty("buttons", buttons);
dialog.beforeShowEvent.subscribe(this._onBeforeShow, this, true);
dialog.showEvent.subscribe(this._onShow, this, true);
dialog.hideEvent.subscribe(this._onHide, this, true);
var commentsEl = YUD.get('comments');
dialog.render(commentsEl);
YUD.addClass(dialog.innerElement, 'comment');
YUD.addClass(dialog.header, 'comment-header');
YUD.addClass(dialog.body, 'comment-body');
YUD.addClass(dialog.form, 'comment-form');
var input = this._createInput();
if (input != null) {
dialog.form.appendChild(input);
}
};
TestShell.Comments.Base.prototype.getType = function() {
return TestShell.Comments.Base.Type.None;
};
TestShell.Comments.Base.prototype._createInput = function() {
var input = null;
var commentType = this.getType();
if (commentType == TestShell.Comments.Base.Type.DropDown) {
input = this._createDropDown();
}
else if (commentType == TestShell.Comments.Base.Type.TextArea) {
input = this._createTextArea();
} else {
console.warn('There is no student comment accommodation code found.');
}
return input;
};
TestShell.Comments.Base.prototype._createTextArea = function()
{
var textarea = HTML.TEXTAREA({
className: 'comment-input comment-textbox',
rows: '4',
cols: '',
style: 'resize: none;'
});
return textarea;
};
TestShell.Comments.Base.prototype._createDropDown = function()
{
var selectbox = HTML.SELECT({
className: 'comment-input comment-selectbox'
});
if (TDS.Comments) {
Util.Array.each(TDS.Comments, function(commentLine) {
var option = HTML.OPTION();
option.text = commentLine;
option.value = commentLine;
selectbox.appendChild(option);
});
}
return selectbox;
};
TestShell.Comments.Base.prototype.getModelValue = function() {
return null;
};
TestShell.Comments.Base.prototype._onBeforeShow = function()
{
var inputEl = this.getInputEl();
if (inputEl == null) return;
var value = this.getModelValue();
if (value == null || value == '') {
if (inputEl.nodeName == 'SELECT') inputEl.selectedIndex = 0;
else inputEl.value = '';
} else {
inputEl.value = value;
}
ContentManager.resetActiveComponent();
this._dialog.fillHeight(this._dialog.body);
};
TestShell.Comments.Base.prototype._onShow = function()
{
YUD.addClass(document.body, TestShell.UI.CSS.dialogShowing);
if (!Util.Browser.isTouchDevice()) {
var inputEl = this.getInputEl();
if (inputEl != null) {
setTimeout(function() { inputEl.focus(); }, 0);
}
}
};
TestShell.Comments.Base.prototype._onHide = function()
{
YUD.removeClass(document.body, TestShell.UI.CSS.dialogShowing);
Util.Dom.focusWindow(2);
};
TestShell.Comments.Base.prototype.show = function() {
this._dialog.show();
};
TestShell.Comments.Base.prototype.hide = function() {
if (this._dialog) this._dialog.hide();
};
TestShell.Comments.Base.prototype.isShowing = function() {
return (this._dialog) ? this._dialog.cfg.getProperty('visible') : false;
};
TestShell.Comments.Base.prototype.submit = function()
{
var text = this.getInputValue();
if (text != null) {
this.save(text);
}
this.hide();
};
TestShell.Comments.Base.prototype.save = function(text) {
};

// FILE: item.js (a8471eb3) 5/2/2014 12:55:57 PM

TestShell.Comments.Item = function() {
TestShell.Comments.Item.superclass.constructor.call(this);
this._response = null;
};
YAHOO.lang.extend(TestShell.Comments.Item, TestShell.Comments.Base);
TestShell.Comments.Item.prototype.getHeaderText = function() {
return ContentManager.getCommentLabel();
};
TestShell.Comments.Item.prototype.getType = function() {
var commentCode = ContentManager.getCommentCode();
if (commentCode != null)
{
if (commentCode == 'TDS_SCDropDown') {
return TestShell.Comments.Base.Type.DropDown;
}
else if (commentCode == 'TDS_SCTextArea' || commentCode == 'TDS_SCNotepad') {
return TestShell.Comments.Base.Type.TextArea;
}
}
return TestShell.Comments.Base.Type.None;
};
TestShell.Comments.Item.prototype.show = function(contentItem) {
this._response = TestShell.PageManager.getResponse(contentItem.position);
TestShell.Comments.Item.superclass.show.call(this);
};
TestShell.Comments.Item.prototype.hide = function() {
this._response = null;
TestShell.Comments.Item.superclass.hide.call(this);
};
TestShell.Comments.Item.prototype.getModelValue = function() {
return this._response.comment;
};
TestShell.Comments.Item.prototype.save = function(text)
{
var response = this._response;
if (response.comment == text) return;
TestShell.UI.showLoading('');
var commentData = {
position: response.position,
comment: text
};
if (typeof TDS.Student == 'object') {
var testee = TDS.Student.Storage.getTestee();
if (testee) {
commentData.testeeKey = testee.key;
commentData.testeeToken = testee.token;
}
}
TestShell.xhrManager.recordItemComment(commentData, function() {
TestShell.UI.hideLoading();
response.comment = text;
});
};

// FILE: global.js (4508ecbb) 5/2/2014 12:55:57 PM

TestShell.Comments.Global = function() {
TestShell.Comments.Global.superclass.constructor.call(this);
this._loaded = false;
this._text = null;
};
YAHOO.lang.extend(TestShell.Comments.Global, TestShell.Comments.Base);
TestShell.Comments.Global.prototype.getId = function() {
return 'global';
};
TestShell.Comments.Global.prototype.getHeaderText = function() {
return Messages.getAlt('TestShell.Comments.Global', 'Global Notes');
};
TestShell.Comments.Global.prototype.getType = function() {
return TestShell.Comments.Base.Type.TextArea;
};
TestShell.Comments.Global.prototype.getModelValue = function() {
return this._text;
};
TestShell.Comments.Global.prototype.show = function() {
var commentObj = this;
if (this._loaded) {
TestShell.Comments.Global.superclass.show.call(commentObj);
} else {
TestShell.UI.showLoading();
TestShell.xhrManager.getOppComment(function(text) {
TestShell.UI.hideLoading();
commentObj._loaded = true;
commentObj._text = text;
TestShell.Comments.Global.superclass.show.call(commentObj);
});
}
};
TestShell.Comments.Global.prototype.save = function(text)
{
if (this._text == text) return;
TestShell.UI.showLoading('');
var commentData = {
comment: text
};
if (typeof TDS.Student == 'object') {
var testee = TDS.Student.Storage.getTestee();
if (testee) {
commentData.testeeKey = testee.key;
commentData.testeeToken = testee.token;
}
}
var commentObj = this;
TestShell.xhrManager.recordOppComment(commentData, function() {
TestShell.UI.hideLoading();
commentObj._text = text;
});
};

// FILE: module.js (c3431cea) 5/2/2014 12:55:57 PM

(function (CM, TS) {
CM.onItemEvent('comment', function (page, item) {
TS.Comments.showItem(item);
});
CM.onPageEvent('beforeHide', function () {
TestShell.Comments.hide();
});
function load() {
TS.Comments.init();
TS.UI.addClick('btnGlobalNotes', function() {
TS.Comments.showGlobal();
});
}
TS.Events.subscribe('init', load);
})(ContentManager, TestShell);

