/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2016 Regents of the University of California
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 *
 * SmarterApp Open Source Assessment Software Project: http://smarterapp.org
 * Developed by Fairway Technologies, Inc. (http://fairwaytech.com)
 * for the Smarter Balanced Assessment Consortium (http://smarterbalanced.org)
 ******************************************************************************/
package tds.student.performance.services.impl;

import AIR.Common.DB.*;
import AIR.Common.DB.results.DbResultRecord;
import AIR.Common.DB.results.SingleDataResultSet;
import AIR.Common.Helpers._Ref;
import TDS.Shared.Exceptions.ReturnStatusException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import tds.dll.api.ICommonDLL;
import tds.dll.api.IRtsDLL;
import tds.dll.api.IStudentDLL;
import tds.student.performance.dao.ConfigurationDao;
import tds.student.performance.dao.ItemBankDao;
import tds.student.performance.dao.TestSessionDao;
import tds.student.performance.domain.*;
import tds.student.performance.services.DbLatencyService;
import tds.student.performance.services.OpenTestService;
import tds.student.performance.utils.DateUtility;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.*;

/**
 * Replacement code for StudentDll.T_OpenTestOpportunity_SP
 */
@Service
public class OpenTestServiceImpl extends AbstractDLL implements OpenTestService {
    private static Logger _logger       = LoggerFactory.getLogger (OpenTestServiceImpl.class);

    @Autowired
    private DateUtility dateUtility     = null;

    @Autowired
    private ICommonDLL _commonDll    = null;

    @Autowired
    private IStudentDLL _studentDll = null;

    @Autowired
    private IRtsDLL _rtsDll       = null;

    @Autowired
    private TestSessionDao testSessionDao;

    @Autowired
    private ConfigurationDao configurationDao;

    @Autowired
    private ItemBankDao itemBankDao;

    @Autowired
    private DbLatencyService dbLatencyService;

    /**
     * <p>
     *     Replaces StudentDll.T_OpenTestOpportunity_SP with some performance optimizations
     * </p>
     * @param connection
     * @param testee
     * @param testkey
     * @param sessionKey
     * @param browserKey
     * @param guestAccommodations
     * @return
     * @throws ReturnStatusException
     */
    public SingleDataResultSet openTestOpporunity (SQLConnection connection, Long testee, String testkey, UUID sessionKey, UUID browserKey,
                                                         String guestAccommodations) throws ReturnStatusException {
        Date starttime = dateUtility.getLocalDate();

        // Emulates logic on line 7188
        TestSession testSession = testSessionDao.get(sessionKey);
        String clientname = testSession.getClientName();


        String testId = null;
        final String SQL_QUERY2 = "select _efk_TestID from sessiontests where _fk_Session = ${sessionKey} and _efk_AdminSubject = ${testkey}";
        SqlParametersMaps parms2 = (new SqlParametersMaps ()).put ("sessionkey", sessionKey).put ("testkey", testkey);
        SingleDataResultSet result = executeStatement (connection, SQL_QUERY2, parms2, false).getResultSets ().next ();

        DbResultRecord record = (result.getCount () > 0 ? result.getRecords ().next () : null);
        if (record != null)
            testId = record.<String> get ("_efk_TestID");

        if (testee < 0 && _studentDll._AllowAnonymousTestee_FN (connection, clientname) == false) {
            return _commonDll._ReturnError_SP (connection, clientname, "T_OpenTestOpportunity", "Guest logins not allowed");
        }

        String testeeId = null, testeeName = null;
        if (testee < 0) {
            testeeId = "GUEST";
            testeeName = "GUEST";
        } else {
            _Ref<String> testeeIdRef = new _Ref<> ();
            _Ref<String> testeeNameRef = new _Ref<> ();
            _rtsDll._GetRTSAttribute_SP (connection, clientname, testee, "ExternalID", testeeIdRef);
            testeeId = testeeIdRef.get ();
            _rtsDll._GetRTSAttribute_SP (connection, clientname, testee, "--ENTITYNAME--", testeeNameRef);
            testeeName = testeeNameRef.get ();
        }

        ClientTestProperty clientTestProperty = configurationDao.getClientTestProperty(clientname, testId);
        Integer maxOpportunities = null;

        if (clientTestProperty != null)
            maxOpportunities = clientTestProperty.getMaxOpportunities();

        if (sessionKey != null && _studentDll.IsSessionOpen_FN (connection, sessionKey) == 0) {
            String reason = "The session is not available for testing. Please check with your test administrator.";

            return _commonDll._ReturnError_SP (connection, clientname, "T_OpenTestOpportunity", reason, null, null, "_CanOpenTestOpportunity");
        }

        _Ref<String> reasonRef = new _Ref<> ();
        _Ref<Boolean> isNewRef = new _Ref<> ();
        _Ref<Integer> oppnumRef = new _Ref<> ();

        // Call an optimized version within this same service instead of StudentDll._CanOpenTestOpportunity_SP
        canOpenTestOpportunity(connection, clientname, testee, testkey, sessionKey, maxOpportunities, isNewRef, oppnumRef, reasonRef);

        String reason = reasonRef.get ();
        Boolean isNew = isNewRef.get ();
        Integer oppnum = oppnumRef.get ();

        if (DbComparator.isEqual (oppnum, 0)) {
            // select 0 as opportunity, 'denied' as [status], @reason as reason,
            // '_CanOpenTestOpportunity' as [context], null as [argstring], null as
            // [delimiter];

            return _commonDll.ReturnStatusReason ("denied", reason, "_CanOpenTestOpportunity", null, 0);
        }

        // EMULATE line 7259
        Long proctor = testSession.getProctorId();
        String newstatus = null;
        UUID testoppKey = null;
        try {
            if (DbComparator.isEqual (isNew, true)) {
                // -- automatically approve proctorless session (for practice test)
                if (proctor == null)
                    newstatus = "approved";
                else
                    newstatus = "pending";

                // -- for operational tests, the student app does not pass along the
                // RTS-based accommodations
                if ((guestAccommodations == null || guestAccommodations.length () == 0) && testee > 0) {

                    _Ref<String> guestAccommodationsRef = new _Ref<> ();
                    _rtsDll._GetRTSAttribute_SP (connection, clientname, testee, "--ACCOMMODATIONS--", guestAccommodationsRef);
                    guestAccommodations = guestAccommodationsRef.get ();
                    if (guestAccommodations != null && guestAccommodations.length () == 0)
                        guestAccommodations = null;
                }
                _Ref<UUID> testoppKeyRef = new _Ref<> ();

                // Call our optimized version in this service instetad of StudnetDll.
                SingleDataResultSet r = openNewOpportunity(connection, clientname, testee, testkey, oppnum, sessionKey, browserKey, testeeId,
                        testeeName, newstatus, guestAccommodations, testoppKeyRef);
                // In caseof success OpenNewOpportunity returns null
                if (r != null) {
                    String errStatus = null;
                    String errReason = null;
                    DbResultRecord rec = r.getRecords ().next ();
                    errStatus = rec.<String> get ("status");
                    errReason = rec.<String> get ("reason");
                    if ("failed".equalsIgnoreCase (errStatus))
                        return _commonDll._ReturnError_SP (connection, clientname, "T_OpenTestOpportunity", errReason, null, null, "_OpenNewOpportunity");
                }
                testoppKey = testoppKeyRef.get ();

            } else {

                boolean restoreRts = _studentDll._RestoreRTSAccommodations_FN (connection, clientname);
                if (restoreRts == true && testee > 0) {

                    _Ref<String> guestAccommodationsRef = new _Ref<> ();
                    _rtsDll._GetRTSAttribute_SP (connection, clientname, testee, "--ACCOMMODATIONS--", guestAccommodationsRef);
                    guestAccommodations = guestAccommodationsRef.get ();
                    if (guestAccommodations != null && guestAccommodations.length () == 0)
                        guestAccommodations = null;
                }
                _Ref<String> newstatusRef = new _Ref<> ();
                _Ref<UUID> testoppKeyRef = new _Ref<> ();
                _studentDll._OpenExistingOpportunity_SP (connection, clientname, testee, testkey, oppnum, sessionKey, browserKey,
                        newstatusRef, guestAccommodations, restoreRts, testoppKeyRef);
                newstatus = newstatusRef.get ();
                testoppKey = testoppKeyRef.get ();

                if (proctor == null) {
                    // -- Note: This is not supposed to happen, but you never know when we
                    // will be expected to reopen opportunities for guest logins
                    newstatus = "approved";
                    // -- automatically approve proctorless session (for practice test)
                    final String SQL_QUERY5 = "update testopportunity set status = 'approved' where _Key = ${testoppkey}";
                    SqlParametersMaps parms5 = (new SqlParametersMaps ()).put ("testoppKey", testoppKey);
                    executeStatement (connection, SQL_QUERY5, parms5, false).getUpdateCount ();
                }
            }
        } catch (ReturnStatusException re) {
            // set @error = coalesce(ERROR_PROCEDURE(), 'UNKNOWN PROC') + ': ' +
            // coalesce(ERROR_MESSAGE(), 'UNKNOWN ERROR');
            StackTraceElement[] stackTrace = re.getStackTrace ();
            // String errorProcedure = stackTrace[0].toString();
            String error = String.format ("%s: %s", stackTrace[0].toString (), re.getMessage ());
            _commonDll._LogDBError_SP (connection, "T_OpenTestOpportunity", error, testee, testkey, oppnum, testoppKey, clientname, sessionKey);
            return _commonDll._ReturnError_SP (connection, clientname, "T_OpenTestOpportunity", "Unable to open the test opportunity");
        }

        // EMULATE line 7338
        String sessId = testSession.getSessionId();
        String proctorName = testSession.getProctorName();
        String lang = null;

        final String SQL_QUERY7 = " select AccValue from testeeaccommodations  where _fk_TestOpportunity = ${testoppkey} and AccType = 'Language'";
        SqlParametersMaps parms7 = (new SqlParametersMaps ()).put ("testoppKey", testoppKey);
        result = executeStatement (connection, SQL_QUERY7, parms7, false).getResultSets ().next ();

        record = (result.getCount () > 0 ? result.getRecords ().next () : null);
        if (record != null) {
            lang = record.<String> get ("accvalue");
        }

        final String SQL_QUERY8 = "update testopportunity set SessID = ${sessID}, Proctorname = ${proctorname}, Language = ${lang}, _fk_session = ${sessionKey} where _Key = ${testoppkey}";
        SqlParametersMaps parms8 = (new SqlParametersMaps ()).put ("testoppKey", testoppKey).put ("sessID", sessId).put ("proctorName", proctorName).
                put ("lang", lang).put ("sessionkey", sessionKey);
        executeStatement (connection, SQL_QUERY8, parms8, false).getUpdateCount ();

        dbLatencyService.logLatency("T_OpenTestOpportunity", starttime, testee, 0, testoppKey, null, clientname, null);

        // select @oppnum as opportunity, @newstatus as [status], null as reason,
        // @testoppkey as oppkey;
        SingleDataResultSet rs = _commonDll.ReturnStatusReason (newstatus, null, null, testoppKey, oppnum);
        return rs;
    }

    /**
     * Open a new test opportunity for testing. Main purpose of this function is
     * to apply business rules. -- Assumptions: -- the given opportunity does not
     * exist and is within testing limits, as verified by _CanOpenTestOpportunity
     * -- the session is open for business, as verified by _CanOpenTestOpportunity
     *
     * Replaces StudentDll._OpenNewOpportunity
     *
     * @param connection
     * @param clientname
     * @param testee
     * @param testkey
     * @param opportunity
     * @param sessionKey
     * @param browserKey
     * @param testeeID
     * @param testeeName
     * @param status
     * @param guestAccommodations
     * @param testoppkeyRef
     * @throws ReturnStatusException
     */
    private SingleDataResultSet openNewOpportunity (SQLConnection connection, String clientname, Long testee, String testkey, Integer opportunity,
                                                       UUID sessionKey, UUID browserKey, String testeeID, String testeeName, String status, String guestAccommodations, _Ref<UUID> testoppkeyRef)
            throws ReturnStatusException {
        if (status == null)
            status = "pending";

        Date starttime = dateUtility.getLocalDate();

        // This currently always returns true
        boolean auditProc = _commonDll.AuditProc_FN (connection, "_OpenNewOpportunity");

        // EMULATES line 6922
        Externs externs = configurationDao.getExterns(clientname);
        String environment = externs.getEnvironment();

        // EMULATES line 6925
        TestSession testSession = testSessionDao.get(sessionKey);
        Integer sessionType = testSession.getSessionType();

        testoppkeyRef.set (UUID.randomUUID ());

        // EMULATES: line 6940
        SetOfAdminSubject setOfAdminSubject = itemBankDao.get(testkey);

        // EMULATES TestSubject_FN which is called from _GetTestParam_SP
        String testSubject = itemBankDao.getTestSubject(testkey);

        DataBaseTable windowsTbl = getDataBaseTable ("newOppWindows").addColumn ("WID", SQL_TYPE_To_JAVA_TYPE.VARCHAR, 100).
                addColumn ("maxOpps", SQL_TYPE_To_JAVA_TYPE.INT).addColumn ("numOpps", SQL_TYPE_To_JAVA_TYPE.INT).
                addColumn ("startDate", SQL_TYPE_To_JAVA_TYPE.DATETIME).
                addColumn ("endDate", SQL_TYPE_To_JAVA_TYPE.DATETIME).addColumn ("formkey", SQL_TYPE_To_JAVA_TYPE.VARCHAR, 50).
                addColumn ("modeOpps", SQL_TYPE_To_JAVA_TYPE.INT).addColumn ("testmode", SQL_TYPE_To_JAVA_TYPE.VARCHAR, 100).
                addColumn ("modeMax", SQL_TYPE_To_JAVA_TYPE.INT).addColumn ("testkey", SQL_TYPE_To_JAVA_TYPE.VARCHAR, 250);

        final String clientnameFinal = clientname;
        final String testIDFinal = setOfAdminSubject.getTestId();
        final Long testeeFinal = testee;
        final Integer sessionTypeFinal = sessionType;
        executeMethodAndInsertIntoTemporaryTable (connection, new AbstractDataResultExecutor ()
        {
            @Override
            public SingleDataResultSet execute (SQLConnection connection) throws ReturnStatusException {
                // getting windowID, windowMax , startDate, endDate, formkey, mode,
                // modeMax, testkey from _GetTesteeTestWindows,
                // They will populate (WID, maxopps, startDate, endDate, formkey,
                // testmode, modeMax, testkey) columns in windows tbl
                // Still need numopps, and modeopps
                SingleDataResultSet result = _studentDll._GetTesteeTestWindows_SP (connection, clientnameFinal, testIDFinal, testeeFinal, sessionTypeFinal);
                result.resetColumnName (1, "wid");
                result.resetColumnName (2, "maxopps");
                result.resetColumnName (6, "testmode");

                result.addColumn ("numopps", SQL_TYPE_To_JAVA_TYPE.INT);
                result.addColumn ("modeopps", SQL_TYPE_To_JAVA_TYPE.INT);

                Iterator<DbResultRecord> records = result.getRecords ();
                while (records.hasNext ()) {
                    DbResultRecord record = records.next ();
                    record.addColumnValue ("numopps", 0);
                    record.addColumnValue ("modeopps", 0);
                }
                return result;
            }
        }, windowsTbl, true);

        Date minStartDate = null;
        final String SQL_QUERY2 = "select min(startDate)  as minStartDate from ${windowsTblName}";
        Map<String, String> unquotedParms2 = new HashMap<>();
        unquotedParms2.put ("windowsTblName", windowsTbl.getTableName ());
        SingleDataResultSet result = executeStatement (connection, fixDataBaseNames (SQL_QUERY2, unquotedParms2), null, false).getResultSets ().next ();
        DbResultRecord record = (result.getCount () > 0 ? result.getRecords ().next () : null);
        if (record != null) {
            minStartDate = record.<Date> get ("minStartDate");
        }

        String windowId = null;
        String mode = null;
        final String SQL_QUERY3 = "select  WID as windowID, testmode as mode from ${windowsTblName} where testkey = ${testkey} and startDate = ${minStartDate} limit 1";
        Map<String, String> unquotedParms3 = unquotedParms2;
        SqlParametersMaps parms3 = (new SqlParametersMaps ()).put ("testkey", testkey).put ("minStartDate", minStartDate);
        result = executeStatement (connection, fixDataBaseNames (SQL_QUERY3, unquotedParms3), parms3, false).getResultSets ().next ();
        record = (result.getCount () > 0 ? result.getRecords ().next () : null);
        if (record != null) {
            windowId = record.<String> get ("windowId");
            mode = record.<String> get ("mode");
        }
        connection.dropTemporaryTable (windowsTbl);

        if (windowId == null)
            return _commonDll._ReturnError_SP (connection, clientname, "_OpenNewOpportunity", "There is no active testing window for this student at this time");

        _Ref<Long> newIdRef = new _Ref<> ();
        //TODO Temporary Commented on 10.20.2014 per Larry's suggestion.
//    _CreateClientReportingID_SP (connection, clientname, testoppkeyRef.get (), newIdRef);
//
//    if (newIdRef.get () == null) {
//
//      _commonDll._LogDBError_SP (connection, "_OpenNewOpportunity", "Unable to create a unique reporting ID", testee, testkey, opportunity, null);
//      return _commonDll._ReturnError_SP (connection, clientname, "_OpenNewOpportunity", "Unable to create a unique reporting ID");
//    }

        // -- version is irrespective of deleted status
        Integer version = null;
        final String SQL_QUERY4 = "select max(_version)  as version from testopportunity "
                + " where _efk_Testee = ${testee} and _efk_TestID = ${testID} and Opportunity = ${opportunity} and clientname = ${clientname}";
        SqlParametersMaps parms4 = (new SqlParametersMaps ()).put ("testee", testee).put ("opportunity", opportunity).
                put ("clientname", clientname).put ("testid", setOfAdminSubject.getTestId());
        result = executeStatement (connection, SQL_QUERY4, parms4, false).getResultSets ().next ();
        record = (result.getCount () > 0 ? result.getRecords ().next () : null);
        if (record != null) {
            version = record.<Integer> get ("version");
        }

        if (version == null)
            version = 1;
        else
            version++;

        final String SQL_QUERY5 = "insert into testopportunity (_key, _version, clientname, _efk_Testee, _efk_TestID, Opportunity, "
                + "     Status,  Subject, TesteeID, TesteeName, _fk_Browser, DateChanged,  ReportingID,  windowID,"
                + "     mode, isSegmented, algorithm,_efk_AdminSubject, environment, SessID, ProctorName, waitingForSegment, datejoined) "
                + " select ${testoppkey}, ${version}, ${clientname}, ${testee}, ${testID}, ${opportunity},  "
                + "        'paused', ${subject}, ${testeeID}, ${testeeName}, ${browserKey}, now(3), ${newID}, ${windowID}, "
                + "         ${mode}, ${segmented}, ${algorithm}, ${testkey}, ${environment}, SessionID, ProctorName, 1, now(3)"
                + " from session where _Key = ${sessionKey}";
        SqlParametersMaps parms5 = (new SqlParametersMaps ()).put ("testoppkey", testoppkeyRef.get ()).put ("version", version).put ("clientname", clientname).
                put ("testee", testee).put ("testID", setOfAdminSubject.getTestId()).put ("opportunity", opportunity).put ("subject", testSubject).
                put ("testeeID", testeeID).put ("testeeName", testeeName).put ("browserKey", browserKey).put ("newID", newIdRef.get ()).
                put ("windowID", windowId).put ("mode", mode).put ("segmented", setOfAdminSubject.getSegmented()).put ("algorithm", setOfAdminSubject.getSelectionAlgorithm()).
                put ("testKey", testkey).put ("environment", environment).put ("sessionKey", sessionKey);
        executeStatement (connection, SQL_QUERY5, parms5, false).getUpdateCount ();

        String context = "INITIAL";
        _commonDll._SetTesteeAttributes_SP (connection, clientname, testoppkeyRef.get (), testee, context);

        final String SQL_QUERY6 = "select _fk_TestOpportunity from ${ArchiveDB}.systemerrors where procname = '_SetTesteeAttributes' and _fk_TestOpportunity = ${testoppkey} limit 1";
        SqlParametersMaps parms6 = (new SqlParametersMaps ()).put ("testoppkey", testoppkeyRef.get ());
        if (exists (executeStatement (connection, fixDataBaseNames (SQL_QUERY6), parms6, false))) {
            // -- we have had deadlock problems with this, try again?
            _commonDll._SetTesteeAttributes_SP (connection, clientname, testoppkeyRef.get (), testee, context);
        }

        // -- insert the given accommodations or defaults
        _studentDll._InitOpportunityAccommodations_SP (connection, testoppkeyRef.get (), guestAccommodations);


        Integer transactionIsolation = null;
        try {
            transactionIsolation = connection.getTransactionIsolation ();
            connection.setTransactionIsolation (Connection.TRANSACTION_READ_COMMITTED);

            final String SQL_QUERY7 = "update testopportunity set status = ${status} where _key = ${testoppkey}";
            SqlParametersMaps parms7 = (new SqlParametersMaps ()).put ("testoppkey", testoppkeyRef.get ()).put ("status", status);
            executeStatement (connection, SQL_QUERY7, parms7, false).getUpdateCount ();


        } catch (SQLException se) {
            throw new ReturnStatusException (se);
        } finally {
            try {
                if (transactionIsolation != null)
                    connection.setTransactionIsolation (transactionIsolation);

            } catch (SQLException e) {
                e.printStackTrace ();
            }
        }
        if (auditProc) {
            // String sessionDB = getAppSettings ().get ("TDSSessionDBName");
            String sessionDB = getTdsSettings ().getTDSSessionDBName ();
            final String SQL_QUERY8 = "insert into ${ArchiveDB}.opportunityaudit (_fk_TestOpportunity, _fk_Session, AccessType, hostname, _fk_Browser, dateaccessed, dbname) "
                    + " values (${testoppkey}, ${sessionKey}, ${status}, ${hostname}, ${browserKey}, now(3), ${dbname})";
            String localhost = _commonDll.getLocalhostName ();
            SqlParametersMaps parms8 = (new SqlParametersMaps ()).put ("testoppkey", testoppkeyRef.get ()).put ("status", status).put ("sessionKey", sessionKey).
                    put ("hostname", localhost).put ("browserKey", browserKey).put ("dbname", sessionDB);
            executeStatement (connection, fixDataBaseNames (SQL_QUERY8), parms8, false).getUpdateCount ();
        }

        dbLatencyService.logLatency("_OpenNewOpportunity", starttime, testee, 0, testoppkeyRef.get(), null, clientname, null);

        return null;
    }

    /**
     * <p>
     *     Replaces _CanOpenTestOpportunity_SP
     * </p>
     * @param connection
     * @param clientname
     * @param testee
     * @param testkey
     * @param sessionId
     * @param maxOpportunities
     * @param newRef
     * @param numberRef
     * @param reasonRef
     * @throws ReturnStatusException
     */
    private void canOpenTestOpportunity (SQLConnection connection, String clientname, Long testee, String testkey, UUID sessionId,
                                            Integer maxOpportunities, _Ref<Boolean> newRef, _Ref<Integer> numberRef, _Ref<String> reasonRef) throws ReturnStatusException {
        Date starttime = dateUtility.getLocalDate();

        newRef.set (false);
        numberRef.set (0);
        reasonRef.set (null);

        // EMULATES line 6521
        Externs externs = configurationDao.getExterns(clientname);
        String environment = externs.getEnvironment();

        // EMULATES line 6523
        // TODO: pass in TestSession instead of looking this up.  This will be cached so it will be fast at lesat
        TestSession testSession = testSessionDao.get(sessionId);
        Integer sessionType = testSession.getSessionType();

        // EMULATES line 6532
        SetOfAdminSubject setOfAdminSubject = itemBankDao.get(testkey);

        String testId = setOfAdminSubject.getTestId();

        // -- If simulation environment uses 'real' students then we want the test
        // to proceed anyway
        // _IsOpportunityBlocked_SP logic is performed by T_GETELIGIBLETESTS, Removing from here as per Jon Cohen's suggestion.
    /*if (DbComparator.notEqual (environment, "SIMULATION") && DbComparator.greaterThan (testee, 0)) {
      // -- only check eligibility on real students
      _IsOpportunityBlocked_SP (connection, clientname, testee, testId, maxOpportunities, reasonRef, sessionType);
    }*/
        if (reasonRef.get () != null) {
            if ("NA".equalsIgnoreCase (reasonRef.get ()))
                numberRef.set (-1); // -- this test is not applicable to the student
            else
                numberRef.set (0);
            return;
        }

        TestSessionTimeLimitConfiguration timelimits = testSessionDao.getTimeLimitConfiguration(clientname, testId);

        Integer delayDays = null;

        if (timelimits != null && timelimits.getOpportunityDelay() != null) {
            delayDays = timelimits.getOpportunityDelay();
        } else {
            timelimits = testSessionDao.getTimeLimitConfiguration(clientname);
            delayDays = timelimits.getOpportunityDelay();
        }

        // -- first try to open an existing opportunity of the main test
        // -- _CanOpenExistingOpportunity must use the test key, not testID, because
        // this will be resuming an actual physical test, not a logical one
        _studentDll._CanOpenExistingOpportunity_SP (connection, clientname, testee, testId, sessionId, maxOpportunities, numberRef, reasonRef);
        if (DbComparator.greaterThan (numberRef.get (), 0) || reasonRef.get () != null) {
            return;
        }
        // -- neither success nor a fatal error, so now try to open a new
        // opportunity
        // -- Important note: This function takes into account that an expired
        // opportunity may have to be closed first
        _studentDll._CanOpenNewOpportunity_SP (connection, clientname, testee, testId, maxOpportunities, delayDays, numberRef, reasonRef, sessionId);
        if (DbComparator.greaterThan (numberRef.get (), 0)) {
            newRef.set (true);
        }

        dbLatencyService.logLatency("_CanOpenTestOpportunity", starttime, testee, clientname);
    }
}
